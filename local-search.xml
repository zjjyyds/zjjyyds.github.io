<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS50AI note1</title>
    <link href="/2025/12/26/CS50%20AI%20note1/"/>
    <url>/2025/12/26/CS50%20AI%20note1/</url>
    
    <content type="html"><![CDATA[<h2 id="第-0-讲"><a href="#第-0-讲" class="headerlink" title="第 0 讲"></a><a href="https://cs50.harvard.edu/ai/notes/0/#lecture-0">第 0 讲</a></h2><h2 id="人工智能-Artificial-Intelligence"><a href="#人工智能-Artificial-Intelligence" class="headerlink" title="人工智能 (Artificial Intelligence)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#artificial-intelligence">人工智能 (Artificial Intelligence)</a></h2><p>人工智能 (AI) 涵盖了一系列让计算机表现出类似拥有“感知”行为的技术。例如，AI 被用于识别社交媒体照片中的人脸、在国际象棋中击败世界冠军，以及在你与手机上的 Siri 或 Alexa 对话时处理你的语音。</p><p>在本课程中，我们将探讨使 AI 成为可能的一些核心思想：</p><ol><li><p><strong>搜索 (Search)</strong></p><p>寻找问题的解决方案，例如导航应用程序寻找从起点到终点的最佳路线，或者在玩游戏时计算下一步该怎么走。</p></li><li><p><strong>知识 (Knowledge)</strong></p><p>表示信息并从中进行推理。</p></li><li><p><strong>不确定性 (Uncertainty)</strong></p><p>利用概率论处理不确定事件。</p></li><li><p><strong>优化 (Optimization)</strong></p><p>不仅要找到解决问题的正确方法，还要找到更好——甚至最好——的解决方法。</p></li><li><p><strong>学习 (Learning)</strong></p><p>通过访问数据和经验来提高性能。例如，你的电子邮件系统能够根据过去的经验区分垃圾邮件和非垃圾邮件。</p></li><li><p><strong>神经网络 (Neural Networks)</strong></p><p>一种受人脑启发的程序结构，能够有效地执行任务。</p></li><li><p><strong>语言 (Language)</strong></p><p>处理自然语言，即人类产生和理解的语言。</p></li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：这门课程的结构非常经典，不仅仅关注现在流行的“深度学习”，而是涵盖了 AI 的基础逻辑（如符号主义、概率推理等）。“搜索”是 AI 的基石，本质上是在无数种可能中找到达成目标的路径。</p></blockquote><h2 id="搜索-Search"><a href="#搜索-Search" class="headerlink" title="搜索 (Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#search">搜索 (Search)</a></h2><p>搜索问题涉及一个<strong>智能体 (Agent)</strong>，它被赋予一个<strong>初始状态</strong>和一个<strong>目标状态</strong>，它的任务是返回如何从前者到达后者的解决方案。导航应用就是典型的搜索过程，智能体（程序的思考部分）接收你当前的位置和想要去的目的地作为输入，并基于搜索算法返回建议的路径。当然，还有许多其他形式的搜索问题，如拼图或迷宫。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/15puzzle.png" alt="15 puzzle"></p><p>找到 15 数字推盘游戏的解法需要使用搜索算法。</p><ul><li><p><strong>智能体 (Agent)</strong></p><p>一个能够感知环境并对环境采取行动的实体。例如在导航应用中，智能体代表一辆需要决定采取哪些行动才能到达目的地的汽车。</p></li><li><p><strong>状态 (State)</strong></p><p>智能体在其环境中的一种配置。例如，在 <a href="https://en.wikipedia.org/wiki/15_puzzle">15 数字推盘</a>中，一个状态就是板上数字排列的任意一种方式。</p><ul><li><strong>初始状态 (Initial State)</strong><br>搜索算法开始的状态。在导航应用中，就是当前位置。</li></ul></li><li><p><strong>动作 (Actions)</strong></p><p>在一个状态下可以做出的选择。更准确地说，动作可以定义为一个函数。接收状态 <code>s</code> 作为输入，<code>Actions(s)</code> 返回在状态 <code>s</code> 下可执行的动作集合作为输出。例如，在 <em>15 数字推盘</em>中，给定状态的动作就是你滑动方块的方式（如果空位在中间则有 4 种，如果在边上则有 3 种，在角落则有 2 种）。</p></li><li><p><strong>转移模型 (Transition Model)</strong></p><p>描述在任何状态下执行任何适用动作后会产生什么状态。更准确地说，转移模型可以定义为一个函数。接收状态 <code>s</code> 和动作 <code>a</code> 作为输入，<code>Results(s, a)</code> 返回在状态 <code>s</code> 下执行动作 <code>a</code> 后产生的新状态。例如，给定 <em>15 数字推盘</em>的某种配置（状态 <code>s</code>），向任何方向移动一个方块（动作 <code>a</code>）都会带来拼图的新配置（新状态）。</p></li><li><p><strong>状态空间 (State Space)</strong></p><p>从初始状态通过任意动作序列可到达的所有状态的集合。例如，在 15 数字推盘中，状态空间由所有从初始状态可到达的 16!/2 种棋盘配置组成。状态空间可以可视化为一个有向图，状态表示为节点，动作表示为节点之间的箭头。</p></li></ul><p><img src="https://cs50.harvard.edu/ai/notes/0/statespace.png" alt="State Space"></p><ul><li><p><strong>目标测试 (Goal Test)</strong></p><p>确定给定状态是否为目标状态的条件。例如，在导航应用中，目标测试是检查智能体（汽车的代表）的当前位置是否在目的地。如果是——问题解决。如果不是——我们继续搜索。</p></li><li><p><strong>路径代价 (Path Cost)</strong></p><p>与给定路径相关的数值成本。例如，导航应用不仅带你到达目标；它会在最小化路径代价的同时这样做，即为你找到到达目标状态的最快方式。</p></li></ul><blockquote><p><strong>🔍 [译者注释]</strong>：理解这些术语至关重要。</p><ul><li><strong>状态 (State)</strong> 是“我们在哪里”。</li><li><strong>动作 (Action)</strong> 是“我们能做什么”。</li><li><strong>转移模型 (Transition)</strong> 是“做了之后会发生什么”。</li><li><strong>状态空间 (State Space)</strong> 是“所有可能情况的地图”。搜索算法本质上就是在这个巨大的“地图”中寻找一条路线。</li></ul></blockquote><h2 id="解决搜索问题"><a href="#解决搜索问题" class="headerlink" title="解决搜索问题"></a><a href="https://cs50.harvard.edu/ai/notes/0/#solving-search-problems">解决搜索问题</a></h2><ul><li><p><strong>解 (Solution)</strong></p><p>从初始状态导致目标状态的一系列动作。</p><ul><li><strong>最优解 (Optimal Solution)</strong><br>在所有解中具有最低路径代价的解。</li></ul></li></ul><p>在搜索过程中，数据通常存储在 <strong><em>节点 (Node)</em></strong> 中，这是一种包含以下数据的数据结构：</p><ul><li>一个 <em>状态 (state)</em></li><li>它的 <em>父节点 (parent node)</em>，即生成当前节点的那个节点</li><li>从父节点的状态应用到当前节点的 <em>动作 (action)</em></li><li>从初始状态到此节点的 <em>路径代价 (path cost)</em></li></ul><p><em>节点</em> 包含的信息使它们对搜索算法非常有用。它们包含一个 <em>状态</em>，可以使用 <em>目标测试</em> 来检查它是否是最终状态。如果是，该节点的 <em>路径代价</em> 可以与其他节点的 <em>路径代价</em> 进行比较，从而允许选择 <em>最优解</em>。一旦选择了节点，由于存储了 <em>父节点</em> 和导致从 <em>父节点</em> 到当前节点的 <em>动作</em>，就可以从 <em>初始状态</em> 一步步回溯到该节点，这个动作序列就是 <em>解</em>。</p><p>然而，<em>节点</em> 只是数据结构——它们不进行搜索，它们只是持有信息。为了实际进行搜索，我们使用 <strong>前沿 (frontier)</strong>（或称边界），这是一种“管理” <em>节点</em> 的机制。<em>前沿</em> 开始时包含一个初始状态和一个空的已探索项集合，然后重复以下操作直到找到解：</p><p><strong>重复 (Repeat):</strong></p><ol><li>如果前沿 (frontier) 为空，<ul><li><em>停止。</em> 问题无解。</li></ul></li><li>从前沿中移除一个节点。这是将被考虑的节点。</li><li><p>如果该节点包含目标状态，</p><ul><li>返回解。<em>停止</em>。</li></ul><p>否则 (Else)，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">* 扩展该节点（找到从该节点可以到达的所有新节点），并将结果节点添加到前沿中。<br>* 将当前节点添加到已探索集合 (explored set) 中。<br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li><strong>节点 vs 状态</strong>：这是一个常见的混淆点。<strong>状态</strong>是物理世界的配置（例如“我在 A 城市”）。<strong>节点</strong>是算法记录的账本（例如“我在 A 城市，我是从 B 城市过来的，目前花了 100 块钱”）。同一个状态（A 城市）可能对应多个节点（你可以从 B 来，也可以从 C 来）。</li><li><strong>前沿 (Frontier)</strong>：可以把它想象成一个“待办事项列表”。算法不断从这个列表中取出任务（节点）来处理，并把新发现的任务加进去。</li></ul></blockquote><h3 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索 (Depth-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#depth-first-search">深度优先搜索 (Depth-First Search)</a></h3><p>在前面关于 <em>前沿</em> 的描述中，有一件事没有提到。在伪代码的第 2 步，应该移除哪个节点？这个选择对解的质量以及找到解的速度有影响。有多种方法来决定应该首先考虑哪些节点，其中两种可以用 <strong>栈 (stack)</strong>（用于 <em>深度优先</em> 搜索）和 <strong>队列 (queue)</strong>（用于 <em>广度优先</em> 搜索）的数据结构来表示（<a href="https://www.google.com/search?q=dfs+vs+bfs+gif">这是一个可爱的卡通演示</a>）。</p><p>我们从 <em>深度优先</em> 搜索 (<em>DFS</em>) 方法开始。</p><p><em>深度优先</em> 搜索算法在尝试另一个方向之前会耗尽每一个方向。在这种情况下，前沿作为 <em>栈</em> 数据结构进行管理。你需要记住的口号是“<strong>后进先出 (Last-In First-Out)</strong>”。在节点被添加到前沿后，第一个被移除并考虑的节点是最后被添加的那一个。这导致搜索算法会在第一个阻碍它的方向上尽可能深地搜索，而将所有其他方向留待稍后处理。</p><p>（课程外的例子：假设你在找钥匙。在 <em>深度优先</em> 搜索方法中，如果你选择从裤子开始找，你会先检查每一个口袋，清空每个口袋并仔细检查内容物。只有当你完全检查完裤子的每一个口袋后，你才会停止在裤子里搜索并开始在其他地方搜索。）</p><ul><li><strong>优点</strong>:<ul><li>在最好的情况下，这个算法是最快的。如果它“运气好”并且总是（偶然地）选择通往解的正确路径，那么 <em>深度优先</em> 搜索花费的时间最少。</li></ul></li><li><strong>缺点</strong>:<ul><li>找到的解可能不是最优的。</li><li>在最坏的情况下，这个算法会在找到解之前探索每一条可能的路径，因此在到达解之前花费最长的时间。</li></ul></li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义从前沿移除节点并返回它的函数。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 如果前沿为空，则终止搜索，因为这意味着没有解。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;empty frontier&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 保存列表中的最后一项（即最新添加的节点）</span><br>        node = <span class="hljs-variable language_">self</span>.frontier[-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 保存列表中除了最后一个节点之外的所有项（即移除最后一个节点）</span><br>        <span class="hljs-variable language_">self</span>.frontier = <span class="hljs-variable language_">self</span>.frontier[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure><h3 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索 (Breadth-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#breadth-first-search">广度优先搜索 (Breadth-First Search)</a></h3><p><em>深度优先</em> 搜索的对立面是 <em>广度优先</em> 搜索 (<em>BFS</em>)。</p><p><em>广度优先</em> 搜索算法将同时沿着多个方向前进，在每个可能的方向上迈出一步，然后在每个方向上迈出第二步。在这种情况下，前沿作为 <em>队列</em> 数据结构进行管理。你需要记住的口号是“<strong>先进先出 (First-In First-Out)</strong>”。在这种情况下，所有新节点排队等候，根据添加的顺序来考虑节点（先到先得！）。这导致搜索算法在任何一个方向采取第二步之前，先在每个可能的方向上采取一步。</p><p>（课程外的例子：假设你在找钥匙。在这种情况下，如果你从裤子开始，你会看一眼右口袋。之后，你不会接着看左口袋，而是会看一眼抽屉。然后是桌子上。依此类推，在你通过所有想到的位置各看一眼之后。只有当你遍历了所有位置后，你才会回到裤子并搜索下一个口袋。）</p><ul><li><strong>优点</strong>:<ul><li>该算法<strong>保证</strong>找到最优解。</li></ul></li><li><strong>缺点</strong>:<ul><li>该算法几乎肯定比最小运行时间要长。</li><li>在最坏的情况下，该算法需要最长的时间运行。</li></ul></li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义从前沿移除节点并返回它的函数。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 如果前沿为空，则终止搜索，因为这意味着没有解。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;empty frontier&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 保存列表中的最老项（即第一个被添加的项）</span><br>        node = <span class="hljs-variable language_">self</span>.frontier[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 保存列表中除了第一项之外的所有项（即移除第一个节点）</span><br>        <span class="hljs-variable language_">self</span>.frontier = <span class="hljs-variable language_">self</span>.frontier[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li><strong>DFS (深度优先)</strong> 就像走迷宫时“一条路走到黑”，撞墙了再退回来。如果你运气好选对了路，很快就能到；运气不好，可能会绕很远。<strong>它不保证找到最近的路。</strong></li><li><strong>BFS (广度优先)</strong> 就像水波纹扩散，一圈一圈向外找。因为它是按距离（步数）一层层找的，所以它<strong>一定能找到步数最少的解</strong>（最优解），但通常比较耗费内存。</li></ul></blockquote><h3 id="贪婪最佳优先搜索-Greedy-Best-First-Search"><a href="#贪婪最佳优先搜索-Greedy-Best-First-Search" class="headerlink" title="贪婪最佳优先搜索 (Greedy Best-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#greedy-best-first-search">贪婪最佳优先搜索 (Greedy Best-First Search)</a></h3><p>广度优先和深度优先都是 <strong>无信息 (uninformed)</strong> 搜索算法。也就是说，这些算法除了通过自身探索获得的信息外，不利用任何关于问题的知识。然而，通常情况下，关于问题的一些知识实际上是可用的。例如，当人类迷宫解决者进入一个路口时，人类可以看到哪条路通向解的大致方向，哪条路不是。AI 也可以做同样的事情。一种考虑额外知识以试图提高其性能的算法称为 <strong>有信息 (informed)</strong> 搜索算法。</p><p><strong>贪婪最佳优先</strong> 搜索扩展那个由 <strong>启发式函数 (heuristic function)</strong> <em>h(n)</em> 确定为最接近目标的节点。顾名思义，该函数估计下一个节点距离目标有多近，但它可能会出错。<em>贪婪最佳优先</em> 算法的效率取决于启发式函数的好坏。例如，在迷宫中，算法可以使用一个依赖于可能节点与迷宫终点之间的 <strong>曼哈顿距离 (Manhattan distance)</strong> 的启发式函数。<em>曼哈顿距离</em> 忽略墙壁，计算从一个位置到达目标位置需要向上、向下或向两侧走多少步。这是一个基于当前位置和目标位置的 (x, y) 坐标可以得出的简单估算。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/manhattandistance.png" alt="Manhattan Distance"></p><p>曼哈顿距离</p><p>然而，必须强调的是，与任何启发式方法一样，它可能会出错并导致算法走上一条比其他路径更慢的路径。有可能 <em>无信息</em> 搜索算法会更快地提供更好的解，但它这样做的可能性比 <em>有信息</em> 算法要小。</p><blockquote><p><strong>🔍 [译者注释]</strong>：为什么叫“贪婪”？因为它只看眼前哪个节点离目标最近（由 $h(n)$ 决定），而不考虑它是怎么到达那个节点的（忽略了已经走过的成本）。这就像为了去某个地方，总是选择直线距离最近的路口，哪怕那条路其实很堵或者要绕远路。</p></blockquote><h3 id="A-搜索-A-Search"><a href="#A-搜索-A-Search" class="headerlink" title="A* 搜索 (A* Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#a-search">A* 搜索 (A* Search)</a></h3><p>作为 <em>贪婪最佳优先</em> 算法的发展，<em>A* 搜索</em> 不仅考虑 <em>h(n)</em>（从当前位置到目标的估计成本），还考虑 <em>g(n)</em>（直到当前位置所累积的成本）。通过结合这两个值，算法有一种更准确的方法来确定解的成本并动态优化其选择。算法跟踪 (<em>至今路径成本</em> + <em>到目标的估计成本</em>)，一旦它超过某个先前选项的估计成本，算法就会放弃当前路径并回到先前的选项，从而防止自己沿着 <em>h(n)</em> 错误地标记为最佳的一条长且低效的路径走下去。</p><p>同样，由于该算法也依赖于启发式，它的好坏取决于它所采用的启发式。在某些情况下，它可能比 <em>贪婪最佳优先</em> 搜索甚至 <em>无信息</em> 算法效率低。为了使 <em>A* 搜索</em> 成为最优的，启发式函数 <em>h(n)</em> 必须是：</p><ol><li><em>可采纳的 (Admissible)</em>，即通过不高估真实成本（即永远不大于实际成本）。</li><li><em>一致的 (Consistent)</em>，这意味着新节点到目标的估计路径成本加上从前一个节点转移到它的成本，大于或等于前一个节点到目标的估计路径成本。用方程形式表示，如果对于每个节点 <em>n</em> 和步长成本为 <em>c</em> 的后继节点 <em>n’</em>，都有 <em>h(n) ≤ h(n’) + c</em>，则 <em>h(n)</em> 是一致的。</li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：A* 是目前最流行的寻路算法。</p><ul><li>公式：$f(n) = g(n) + h(n)$。<ul><li>$g(n)$：我已经走了多远（实际成本）。</li><li>$h(n)$：我估计还要走多远（启发式）。</li></ul></li><li><strong>可采纳性 (Admissible)</strong>：意味着你的估计必须是“乐观”的。如果你估计还需要走 10 步，但实际需要 5 步，那就不行；但如果你估计 10 步，实际需要 20 步，那是可以的。只要不高估，A* 就能保证找到最优解。</li></ul></blockquote><h3 id="对抗搜索-Adversarial-Search"><a href="#对抗搜索-Adversarial-Search" class="headerlink" title="对抗搜索 (Adversarial Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#adversarial-search">对抗搜索 (Adversarial Search)</a></h3><p>此前，我们讨论的算法需要找到问题的答案，而在 <strong>对抗搜索</strong> 中，算法面临着试图实现相反目标的对手。通常，使用对抗搜索的 AI 会出现在游戏中，例如井字棋 (Tic-Tac-Toe)。</p><h4 id="极小化极大算法-Minimax"><a href="#极小化极大算法-Minimax" class="headerlink" title="极小化极大算法 (Minimax)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#minimax">极小化极大算法 (Minimax)</a></h4><p>作为对抗搜索中的一种算法，<strong>Minimax</strong> 将胜利条件表示为一方 (-1) 和另一方 (+1)。进一步的行动将由这些条件驱动，最小化方试图获得最低分，最大化方试图获得最高分。</p><p><strong>表示井字棋 AI</strong>:</p><ul><li><em>S₀</em>: 初始状态（在我们的例子中，空的 3X3 棋盘）</li><li><em>Players(s)</em>: 给定状态 <em>s</em>，返回轮到哪个玩家（X 或 O）的函数。</li><li><em>Actions(s)</em>: 给定状态 <em>s</em>，返回该状态下所有合法移动（棋盘上哪些位置是空的）的函数。</li><li><em>Result(s, a)</em>: 给定状态 <em>s</em> 和动作 <em>a</em>，返回新状态的函数。这是在状态 <em>s</em> 上执行动作 <em>a</em>（在游戏中走一步）后产生的棋盘。</li><li><em>Terminal(s)</em>: 给定状态 <em>s</em>，检查这是否是游戏的最后一步（即是否有人赢了或平局）的函数。如果游戏结束返回 <em>True</em>，否则返回 <em>False</em>。</li><li><em>Utility(s)</em>: 给定终端状态 <em>s</em>，返回状态的效用值的函数：-1、0 或 1。</li></ul><p><strong>算法如何工作</strong>:</p><p>该算法递归地模拟从当前状态开始直到达到终端状态的所有可能发生的游戏。每个终端状态被赋值为 (-1)、0 或 (+1)。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/minimax_tictactoe.png" alt="Minimax in Tic Tac Toe"></p><p>井字棋中的 Minimax 算法</p><p>根据状态知道轮到谁，算法可以知道当前玩家在进行最佳操作时，会选择导致值更低还是更高的状态的动作。这样，在最小化和最大化之间交替，算法为每个可能动作导致的状态创建值。举个更具体的例子，我们可以想象最大化玩家在每一轮都会问：“如果我采取这个行动，将会产生一个新状态。如果最小化玩家玩得最好，那个玩家会采取什么行动来带来最低的值？”然而，要回答这个问题，最大化玩家必须问：“要知道最小化玩家会做什么，我需要在最小化玩家的脑海中模拟相同的过程：最小化玩家会试图问：‘如果我采取这个行动，最大化玩家可以采取什么行动来带来最高的值？’”这是一个递归过程，可能很难理解；看下面的伪代码会有所帮助。最终，通过这个递归推理过程，最大化玩家为当前状态下所有可能动作可能导致的状态生成值。拥有这些值后，最大化玩家选择最高的一个。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/minimax_theoretical.png" alt="Minimax Algorithm"></p><p>最大化者考虑未来状态的可能值。</p><p>用伪代码表示，Minimax 算法的工作方式如下：</p><ul><li>给定状态 <em>s</em><ul><li>最大化玩家在 <em>Actions(s)</em> 中选择动作 <em>a</em>，该动作产生 <em>Min-Value(Result(s, a))</em> 的最高值。</li><li>最小化玩家在 <em>Actions(s)</em> 中选择动作 <em>a</em>，该动作产生 <em>Max-Value(Result(s, a))</em> 的最低值。</li></ul></li><li>函数 <em>Max-Value(state)</em><ul><li><em>v = -∞</em></li><li>如果 <em>Terminal(state)</em>:<br>返回 <em>Utility(state)</em></li><li>对于 <em>Actions(state)</em> 中的 <em>action</em>:<br><em>v = Max(v, Min-Value(Result(state, action)))</em><br>返回 <em>v</em></li></ul></li><li>函数 <em>Min-Value(state)</em>:<ul><li><em>v = ∞</em></li><li>如果 <em>Terminal(state)</em>:<br>返回 <em>Utility(state)</em></li><li>对于 <em>Actions(state)</em> 中的 <em>action</em>:<br><em>v = Min(v, Max-Value(Result(state, action)))</em><br>返回 <em>v</em></li></ul></li></ul><blockquote><p><strong>🔍 [译者注释]</strong>：Minimax 的核心逻辑是“换位思考”。</p><ul><li><strong>Max (我)</strong>：我想赢（得分 +1）。</li><li><strong>Min (对手)</strong>：想让我输（得分 -1）。</li><li>在做决定时，我会假设对手极其聪明。如果我走 A 步，对手可能会走 X、Y 或 Z。我会看 X、Y、Z 中哪个对我<strong>最不利</strong>（因为对手会选那个）。然后我在所有可能的 A、B、C 步中，选择那个“最坏情况中最好的”结果。</li></ul></blockquote><h4 id="Alpha-Beta-剪枝-Alpha-Beta-Pruning"><a href="#Alpha-Beta-剪枝-Alpha-Beta-Pruning" class="headerlink" title="Alpha-Beta 剪枝 (Alpha-Beta Pruning)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#alpha-beta-pruning">Alpha-Beta 剪枝 (Alpha-Beta Pruning)</a></h4><p>作为优化 <em>Minimax</em> 的一种方法，<strong>Alpha-Beta 剪枝</strong> 跳过一些明显不利的递归计算。在确定了一个动作的值之后，如果有初步证据表明随后的动作可能让对手获得比已经确定的动作更好的分数，那么就没有必要进一步调查这个动作了，因为它肯定比先前确定的那个更不有利。</p><p>这用一个例子最容易展示：一个最大化玩家知道，在下一步，最小化玩家将试图获得最低分。假设最大化玩家有三个可能的动作，第一个动作的值为 4。然后玩家开始生成下一个动作的值。为此，玩家生成如果当前玩家采取此动作后最小化玩家动作的值，知道最小化者会选择最低的那个。然而，在完成最小化玩家所有可能动作的计算之前，玩家看到其中一个选项的值为 3。这意味着没有理由继续探索最小化玩家的其他可能动作了。尚未估值的动作的值是多少并不重要，无论是 10 还是 (-10)。如果值为 10，最小化者会选择最低的选项 3，这已经比预先确定的 4 差了。如果尚未估值的动作结果是 (-10)，最小化者将选择这个选项 (-10)，这对最大化者来说更加不利。因此，此时计算最小化者的其他可能动作对最大化者来说是无关紧要的，因为最大化玩家已经有了一个明确更好的选择，其值为 4。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/alphabeta.png" alt="Alpha Beta Pruning"></p><blockquote><p><strong>🔍 [译者注释]</strong>：想象你在挑苹果，你想挑个最大的。</p><ul><li>第一筐里最小的苹果是 5 两重（所以这筐至少能给你 5 两）。</li><li>你开始看第二筐，拿起来第一个苹果是 3 两。</li><li><strong>剪枝</strong>：你不需要再看第二筐剩下的苹果了。因为你是最大化者（想要最大的），而这一步是对手（最小化者）在选。对手既然能在第二筐找到 3 两的，那他绝对不会让你在这一筐得到超过 3 两的结果。既然 3 两已经比第一筐的 5 两差了，第二筐就被你放弃了。</li></ul></blockquote><h4 id="深度受限-Minimax-Depth-Limited-Minimax"><a href="#深度受限-Minimax-Depth-Limited-Minimax" class="headerlink" title="深度受限 Minimax (Depth-Limited Minimax)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#depth-limited-minimax">深度受限 Minimax (Depth-Limited Minimax)</a></h4><p>井字棋共有 255,168 种可能的游戏过程，而国际象棋有 10²⁹⁰⁰⁰ 种可能的游戏。目前所介绍的 Minimax 算法需要生成从某一点到终端条件的所有假设游戏。虽然现代计算机计算所有井字棋游戏并不构成挑战，但对国际象棋这样做目前是不可能的。</p><p><strong>深度受限 Minimax</strong> 仅考虑预定义数量的步数后就停止，而不必到达终端状态。然而，这不允许为每个动作获得精确的值，因为尚未到达假设游戏的结尾。为了解决这个问题，<em>深度受限 Minimax</em> 依赖于一个 <strong>评估函数 (evaluation function)</strong>，该函数估计从给定状态开始的游戏的预期效用，换句话说，为状态赋值。例如，在国际象棋游戏中，效用函数将接收棋盘的当前配置作为输入，尝试评估其预期效用（基于每个玩家拥有的棋子及其在棋盘上的位置），然后返回一个正值或负值，表示该棋盘对一个玩家相对于另一个玩家的有利程度。这些值可用于决定正确的动作，评估函数越好，依赖它的 Minimax 算法就越好。</p><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li>这就是现实中下棋软件（如早期的“深蓝”）的工作原理。它算不了无限远，只能算往后 10 步或 20 步。</li><li><strong>评估函数</strong> 是关键：当我看不到结局时，我必须凭经验判断现在的局势是好是坏。例如：“我有皇后，对方没有，所以我这局势+9分”。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>课程讲义</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50 AI</tag>
      
      <tag>讲义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序算法</title>
    <link href="/2025/12/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2025/12/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="🧩-归并排序（Merge-Sort）：分而治之的艺术"><a href="#🧩-归并排序（Merge-Sort）：分而治之的艺术" class="headerlink" title="🧩 归并排序（Merge Sort）：分而治之的艺术"></a>🧩 归并排序（Merge Sort）：分而治之的艺术</h1><p>归并排序的核心思想是：<strong>先拆分，后合并</strong>。<br>它将一个大数组不断二分，直到每个小数组只有一个元素（此时每个小数组都是有序的），然后将这些有序的小数组两两合并，最终得到完整的有序数组。<br><img src="../img/归并排序/2025-12-25-12-27-32.png" alt=""></p><h2 id="1-核心原理：两个阶段"><a href="#1-核心原理：两个阶段" class="headerlink" title="1. 核心原理：两个阶段"></a>1. 核心原理：两个阶段</h2><ol><li><strong>分（Divide）</strong>：找到数组的中点，把数组一分为二。递归地对左右两半进行同样的操作，直到数组长度为 1。</li><li><strong>治/合（Merge）</strong>：这是最关键的一步。将两个<strong>已经排好序</strong>的子数组合并成一个新的有序数组。</li></ol><h3 id="💡-生动比喻"><a href="#💡-生动比喻" class="headerlink" title="💡 生动比喻"></a>💡 生动比喻</h3><p>想象你要整理一副乱序的扑克牌：</p><ul><li><strong>分</strong>：你把牌堆不断对半切开，直到每个人手里都只拿<strong>一张牌</strong>（一张牌自然是有序的）。</li><li><strong>合</strong>：两个拿牌的人比较谁手里的牌小，谁先放在桌上。接着四个人的两组牌再进行比较合并……最终整副牌就排好了。</li></ul><hr><h2 id="2-核心语法与实现（Java）"><a href="#2-核心语法与实现（Java）" class="headerlink" title="2. 核心语法与实现（Java）"></a>2. 核心语法与实现（Java）</h2><p>归并排序通常使用<strong>递归</strong>来实现。我们需要一个辅助函数来执行“合并”操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前：&quot;</span> + Arrays.toString(arr));<br>        <br>        mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;排序后：&quot;</span> + Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-comment">// 递归拆分函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">// 找到中间索引，防止溢出的写法</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">// 递归拆分左半部分</span><br>            mergeSort(arr, left, mid);<br>            <span class="hljs-comment">// 递归拆分右半部分</span><br>            mergeSort(arr, mid + <span class="hljs-number">1</span>, right);<br><br>            <span class="hljs-comment">// 合并左右两部分</span><br>            merge(arr, left, mid, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 核心合并函数：将两个有序区间 [left, mid] 和 [mid+1, right] 合并</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建临时数组存放合并结果</span><br>        <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left;      <span class="hljs-comment">// 左子数组的起点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 右子数组的起点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;         <span class="hljs-comment">// 临时数组的索引</span><br><br>        <span class="hljs-comment">// 2. 比较两个子数组，谁小就谁进 temp</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) &#123;<br>                temp[k++] = arr[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp[k++] = arr[j++];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 将左边剩余元素放入 temp（如果有）</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            temp[k++] = arr[i++];<br>        &#125;<br><br>        <span class="hljs-comment">// 4. 将右边剩余元素放入 temp（如果有）</span><br>        <span class="hljs-keyword">while</span> (j &lt;= right) &#123;<br>            temp[k++] = arr[j++];<br>        &#125;<br><br>        <span class="hljs-comment">// 5. 把排好序的 temp 复制回原数组 arr</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; p &lt; temp.length; p++) &#123;<br>            arr[left + p] = temp[p];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3. 性能分析"></a>3. 性能分析</h2><ul><li><strong>时间复杂度</strong>：始终是 $O(n \log n)$。不管原数组是乱序还是已经排好序，它的表现都非常稳定。</li><li><strong>空间复杂度</strong>：$O(n)$。因为合并过程中需要一个和原数组一样大的临时数组。</li><li><strong>稳定性</strong>：<strong>稳定</strong>排序。在合并逻辑中，如果 <code>arr[i] == arr[j]</code>，我们先放左边的 <code>arr[i]</code>，保证了相同元素的相对顺序不变。</li></ul><hr><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ol><li><strong>大规模数据排序</strong>：当内存装不下所有数据时，归并排序的思想可以用于<strong>外部排序</strong>（从磁盘读入部分数据排序后再合并）。</li><li><strong>求逆序对</strong>：这是归并排序的一个典型算法变种题。</li><li><strong>链表排序</strong>：在 LeetCode 中，排序链表的最佳选择通常是归并排序，因为链表不需要连续的内存空间。</li></ol><hr><h2 id="⚠️-讲师提醒：新手易错点"><a href="#⚠️-讲师提醒：新手易错点" class="headerlink" title="⚠️ 讲师提醒：新手易错点"></a>⚠️ 讲师提醒：新手易错点</h2><ol><li><strong>递归终止条件</strong>：一定要写 <code>if (left &lt; right)</code>，否则会进入死循环（栈溢出）。</li><li><strong>中点计算</strong>：使用 <code>mid = left + (right - left) / 2</code> 能够有效避免 <code>(left + right)</code> 导致的整数溢出风险。</li><li><strong>区间闭合</strong>：合并时注意 <code>while (i &lt;= mid)</code> 的等于号，漏掉会导致数组元素丢失。</li></ol>]]></content>
    
    
    <categories>
      
      <category>DS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数组常用API</title>
    <link href="/2025/12/24/Java%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8API/"/>
    <url>/2025/12/24/Java%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h1 id="🚀-Java-进阶：数组常用-API-与经典操作实战"><a href="#🚀-Java-进阶：数组常用-API-与经典操作实战" class="headerlink" title="🚀 Java 进阶：数组常用 API 与经典操作实战"></a>🚀 Java 进阶：数组常用 API 与经典操作实战</h1><blockquote><p><strong>导读</strong>：<br>这一节我们将解锁 Java 数组的“瑞士军刀”——<code>java.util.Arrays</code> 类，它可以让你一行代码搞定排序、查找和打印。<br>同时，我们也会深入底层，手写几个经典的数组算法（如反转、扩容），这是理解数据结构逻辑的关键。</p></blockquote><hr><h2 id="第一部分：Java-数组的“瑞士军刀”-常用-API"><a href="#第一部分：Java-数组的“瑞士军刀”-常用-API" class="headerlink" title="第一部分：Java 数组的“瑞士军刀” (常用 API)"></a>第一部分：Java 数组的“瑞士军刀” (常用 API)</h2><p>Java 官方为了不让我们重复造轮子，提供了一个强大的工具类 <code>java.util.Arrays</code>。使用前请记得 <code>import java.util.Arrays;</code>。</p><h3 id="1-🔍-查看与打印：toString-amp-deepToString"><a href="#1-🔍-查看与打印：toString-amp-deepToString" class="headerlink" title="1. 🔍 查看与打印：toString() &amp; deepToString()"></a>1. 🔍 查看与打印：<code>toString()</code> &amp; <code>deepToString()</code></h3><p>直接打印数组变量只能看到内存地址，必须用这个方法才能看到“真面目”。</p><ul><li><strong>场景</strong>：调试代码，查看数组里的内容。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(Arrays.toString(arr)); <br><span class="hljs-comment">// 输出: [1, 2, 3]</span><br><br><span class="hljs-type">int</span>[][] matrix = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;;<br><span class="hljs-comment">// 注意：多维数组要用 deepToString，否则里面的数组还是显示地址</span><br>System.out.println(Arrays.deepToString(matrix)); <br><span class="hljs-comment">// 输出: [[1, 2], [3, 4]]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-🔢-排序：sort"><a href="#2-🔢-排序：sort" class="headerlink" title="2. 🔢 排序：sort()"></a>2. 🔢 排序：<code>sort()</code></h3><p>将数组元素按照从小到大（升序）排列。底层使用了双轴快速排序等高效算法。</p><ul><li><strong>场景</strong>：排行榜、数据整理。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] scores = &#123;<span class="hljs-number">88</span>, <span class="hljs-number">50</span>, <span class="hljs-number">99</span>, <span class="hljs-number">70</span>&#125;;<br>Arrays.sort(scores);<br>System.out.println(Arrays.toString(scores)); <br><span class="hljs-comment">// 输出: [50, 70, 88, 99] (自动变成有序了)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-🔎-查找：binarySearch-二分查找"><a href="#3-🔎-查找：binarySearch-二分查找" class="headerlink" title="3. 🔎 查找：binarySearch() (二分查找)"></a>3. 🔎 查找：<code>binarySearch()</code> (二分查找)</h3><p>在一个<strong>有序</strong>的数组中快速查找某个元素的位置。</p><ul><li><strong>⚠️ 注意</strong>：使用此方法前，<strong>必须先排序</strong>！如果数组是乱序的，结果不可预测。</li><li><p><strong>返回值</strong>：如果找到，返回索引；如果找不到，返回负数。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;; <span class="hljs-comment">// 必须是有序的</span><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums, <span class="hljs-number">30</span>);<br>System.out.println(<span class="hljs-string">&quot;30的下标是：&quot;</span> + index); <span class="hljs-comment">// 输出: 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">errorIndex</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums, <span class="hljs-number">25</span>);<br>System.out.println(<span class="hljs-string">&quot;找不存在的数：&quot;</span> + errorIndex); <span class="hljs-comment">// 输出负数 (例如 -3)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-👯-比较：equals"><a href="#4-👯-比较：equals" class="headerlink" title="4. 👯 比较：equals()"></a>4. 👯 比较：<code>equals()</code></h3><p>判断两个数组的<strong>内容</strong>是否完全一致（长度相同，且对应位置元素相同）。</p><ul><li><p><strong>注意</strong>：直接用 <code>==</code> 比较的是两个数组的内存地址，通常都是 <code>false</code>。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] arr2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>System.out.println(arr1 == arr2);       <span class="hljs-comment">// false (它是两个不同的对象)</span><br>System.out.println(Arrays.equals(arr1, arr2)); <span class="hljs-comment">// true (内容一样)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5-🛠-填充：fill"><a href="#5-🛠-填充：fill" class="headerlink" title="5. 🛠 填充：fill()"></a>5. 🛠 填充：<code>fill()</code></h3><p>快速把数组的所有位置（或指定范围）都填成同一个值。</p><ul><li><strong>场景</strong>：初始化游戏地图、重置数据。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>Arrays.fill(box, <span class="hljs-number">666</span>); <span class="hljs-comment">// 把整个数组都填满 666</span><br><span class="hljs-comment">// 输出: [666, 666, 666, 666, 666]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6-📋-复制与截取：copyOf-amp-copyOfRange"><a href="#6-📋-复制与截取：copyOf-amp-copyOfRange" class="headerlink" title="6. 📋 复制与截取：copyOf() &amp; copyOfRange()"></a>6. 📋 复制与截取：<code>copyOf()</code> &amp; <code>copyOfRange()</code></h3><ul><li><code>copyOf(原数组, 新长度)</code>：从头开始复制，可用于扩容或截断。</li><li><p><code>copyOfRange(原数组, start, end)</code>：复制中间某一段（含头不含尾）。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><br><span class="hljs-comment">// 复制前3个</span><br><span class="hljs-type">int</span>[] newArr = Arrays.copyOf(src, <span class="hljs-number">3</span>); <br><span class="hljs-comment">// 结果: [10, 20, 30]</span><br><br><span class="hljs-comment">// 扩容复制 (后面补默认值)</span><br><span class="hljs-type">int</span>[] bigArr = Arrays.copyOf(src, <span class="hljs-number">7</span>);<br><span class="hljs-comment">// 结果: [10, 20, 30, 40, 50, 0, 0]</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="⚡-补充：一个高效的底层-API"><a href="#⚡-补充：一个高效的底层-API" class="headerlink" title="⚡ 补充：一个高效的底层 API"></a>⚡ 补充：一个高效的底层 API</h2><p>在阅读 Java 源码时，你会经常看到 <code>System.arraycopy</code>。它是最底层的数组复制方法，性能极高（直接操作内存），但参数比较多，容易写错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法：</span><br><span class="hljs-comment">// System.arraycopy(原数组, 原数组起始位置, 目标数组, 目标数组起始位置, 复制多少个);</span><br><br><span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span>[] dest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">// 把 src 的后两个元素 (3,4) 复制到 dest 的开头</span><br>System.arraycopy(src, <span class="hljs-number">2</span>, dest, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br><br>System.out.println(Arrays.toString(dest)); <br><span class="hljs-comment">// 输出: [3, 4, 0, 0]</span><br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>日常开发</strong>：首选 <code>java.util.Arrays</code> 类，代码简洁，可读性高。</li><li><strong>性能敏感/底层开发</strong>：使用 <code>System.arraycopy</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>语法知识</tag>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java生成随机数</title>
    <link href="/2025/12/24/Java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <url>/2025/12/24/Java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="🎲-Java-核心：生成随机数的-4-种姿势"><a href="#🎲-Java-核心：生成随机数的-4-种姿势" class="headerlink" title="🎲 Java 核心：生成随机数的 4 种姿势"></a>🎲 Java 核心：生成随机数的 4 种姿势</h1><blockquote><p><strong>导读</strong>：<br>并不是所有的随机数都是“真随机”。<br>在 Java 中，你需要根据你的应用场景（是写个小Demo，还是写银行支付系统）来选择不同的随机数生成器。</p></blockquote><hr><h2 id="1-简易入门：Math-random"><a href="#1-简易入门：Math-random" class="headerlink" title="1. 简易入门：Math.random()"></a>1. 简易入门：Math.random()</h2><h3 id="📖-概念定义"><a href="#📖-概念定义" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是 Java 最基础的工具类 <code>Math</code> 提供的一个静态方法。它不需要 <code>new</code> 对象，直接调用即可。</p><h3 id="⚙️-核心规则"><a href="#⚙️-核心规则" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>返回值</strong>：它固定返回一个 <code>0.0</code> (包含) 到 <code>1.0</code> (不包含) 之间的 <code>double</code> 小数。</li><li><strong>底层</strong>：其实它底层也是调用了 <code>java.util.Random</code>，只是做了一层简单的封装。</li></ul><h3 id="💻-代码示例"><a href="#💻-代码示例" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathRandomDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 基础用法：生成 0.0 ~ 1.0 之间的小数</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Math.random();<br>        System.out.println(<span class="hljs-string">&quot;随机小数: &quot;</span> + d);<br><br>        <span class="hljs-comment">// 2. 进阶用法：生成 [0, 100) 之间的整数</span><br>        <span class="hljs-comment">// 逻辑：先把 0.x 放大100倍，再强制转成 int 去掉小数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>);<br>        System.out.println(<span class="hljs-string">&quot;0到99的整数: &quot;</span> + num);<br><br>        <span class="hljs-comment">// 3. 必背公式：生成 [min, max] 之间的整数 (包含两端)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">// 公式：(int)(Math.random() * (最大值 - 最小值 + 1)) + 最小值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rangeNum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * (max - min + <span class="hljs-number">1</span>)) + min;<br>        System.out.println(<span class="hljs-string">&quot;50到100的整数: &quot;</span> + rangeNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景"><a href="#🚀-应用场景" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li>快速测试、简单的脚本。</li><li><strong>缺点</strong>：写区间公式太麻烦，容易算错。</li></ul><hr><h2 id="2-标准通用：java-util-Random"><a href="#2-标准通用：java-util-Random" class="headerlink" title="2. 标准通用：java.util.Random"></a>2. 标准通用：java.util.Random</h2><h3 id="📖-概念定义-1"><a href="#📖-概念定义-1" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是 Java 面向对象标准的随机数生成器。你需要先创建一个“骰子”对象，然后摇它。</p><h3 id="⚙️-核心规则-1"><a href="#⚙️-核心规则-1" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>灵活性</strong>：可以直接生成 <code>int</code>, <code>boolean</code>, <code>float</code> 等多种类型，不需要像 <code>Math.random</code> 那样手动转换。</li><li><strong>种子 (Seed)</strong>：如果你在 new 的时候传入一个固定的数字（种子），那么每次运行生成的随机数序列是<strong>一模一样</strong>的（常用于复现 Bug）。</li></ul><h3 id="💻-代码示例-1"><a href="#💻-代码示例-1" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UtilRandomDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建随机数对象 (不带种子，默认以当前时间为种子)</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>        <span class="hljs-comment">// 2. 生成各种类型的随机数</span><br>        System.out.println(<span class="hljs-string">&quot;随机布尔值: &quot;</span> + r.nextBoolean()); <span class="hljs-comment">// true 或 false</span><br>        System.out.println(<span class="hljs-string">&quot;随机Double: &quot;</span> + r.nextDouble()); <span class="hljs-comment">// 0.0 ~ 1.0</span><br><br>        <span class="hljs-comment">// 3. 最好用的方法：nextInt(bound)</span><br>        <span class="hljs-comment">// 生成 [0, 10) 之间的整数 (不包含10)</span><br>        <span class="hljs-comment">// 也就是 0 ~ 9</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>); <br>        System.out.println(<span class="hljs-string">&quot;0到9的整数: &quot;</span> + i);<br>        <br>        <span class="hljs-comment">// ------------------------------------</span><br>        <span class="hljs-comment">// 特殊情况：带种子的随机 (伪随机的真相)</span><br>        <span class="hljs-comment">// 只要种子一样，生成的随机数顺序永远一样</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">rFixed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">100</span>); <br>        System.out.println(<span class="hljs-string">&quot;固定随机数1: &quot;</span> + rFixed.nextInt(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 每次运行都是同一个数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-1"><a href="#🚀-应用场景-1" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li>大多数业务开发、游戏逻辑、模拟数据。</li></ul><hr><h2 id="3-高性能并发：ThreadLocalRandom-Java-7"><a href="#3-高性能并发：ThreadLocalRandom-Java-7" class="headerlink" title="3. 高性能并发：ThreadLocalRandom (Java 7+)"></a>3. 高性能并发：ThreadLocalRandom (Java 7+)</h2><h3 id="📖-概念定义-2"><a href="#📖-概念定义-2" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是为了解决多线程问题而生的工具。</p><h3 id="💡-通俗理解"><a href="#💡-通俗理解" class="headerlink" title="💡 通俗理解"></a>💡 通俗理解</h3><p><code>java.util.Random</code> 是线程安全的，但在多线程高并发时（比如 1000 个人同时去抢一个骰子），会产生<strong>竞争</strong>，导致性能下降。<br><code>ThreadLocalRandom</code> 相当于<strong>给每个线程发了一个专用的骰子</strong>，互不干扰，速度极快。</p><h3 id="💻-代码示例-2"><a href="#💻-代码示例-2" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TLRDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 注意：不能 new，要用 current() 获取当前线程的实例</span><br>        <span class="hljs-type">ThreadLocalRandom</span> <span class="hljs-variable">tlr</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current();<br><br>        <span class="hljs-comment">// 用法和 Random 几乎一样，但性能更高</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> tlr.nextInt(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 直接支持生成 [10, 20) 的范围，超方便！</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;10到19的整数: &quot;</span> + val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-2"><a href="#🚀-应用场景-2" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li><strong>高并发系统</strong>、多线程环境。</li><li>在 JDK 7 之后，<strong>强烈推荐</strong>在多线程能替代 <code>Random</code> 的地方都用这个。</li></ul><hr><h2 id="4-银行级安全：java-security-SecureRandom"><a href="#4-银行级安全：java-security-SecureRandom" class="headerlink" title="4. 银行级安全：java.security.SecureRandom"></a>4. 银行级安全：java.security.SecureRandom</h2><h3 id="📖-概念定义-3"><a href="#📖-概念定义-3" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>真·随机数生成器。前面的 <code>Random</code> 实际上是根据算法算出来的（伪随机），如果黑客知道了算法和种子，就能预测下一个数。<br><code>SecureRandom</code> 利用操作系统的随机源（如鼠标移动、键盘敲击、CPU热噪声等）来生成随机数。</p><h3 id="⚙️-核心规则-2"><a href="#⚙️-核心规则-2" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>不可预测性</strong>：极其难以被破解。</li><li><strong>性能</strong>：比普通的 Random 慢很多（因为生成过程很复杂）。</li></ul><h3 id="💻-代码示例-3"><a href="#💻-代码示例-3" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">sr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>        <br>        <span class="hljs-comment">// 用法和 Random 一样</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">passwordPart</span> <span class="hljs-operator">=</span> sr.nextInt(<span class="hljs-number">10000</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;安全随机数: &quot;</span> + passwordPart);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-3"><a href="#🚀-应用场景-3" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li><strong>生成密码、Token、Session ID、加密密钥</strong>。</li><li>凡是涉及到<strong>钱</strong>和<strong>安全</strong>的地方，严禁使用 <code>Math.random</code> 或 <code>Random</code>，必须用 <code>SecureRandom</code>。</li></ul><hr><h2 id="📝-总结：我该用哪个？"><a href="#📝-总结：我该用哪个？" class="headerlink" title="📝 总结：我该用哪个？"></a>📝 总结：我该用哪个？</h2><div class="table-container"><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">推荐方式</th><th style="text-align:left">理由</th></tr></thead><tbody><tr><td style="text-align:left"><strong>写个小Demo / 教学</strong></td><td style="text-align:left"><code>Math.random()</code></td><td style="text-align:left">代码最短，不用导包。</td></tr><tr><td style="text-align:left"><strong>一般业务 / 单线程</strong></td><td style="text-align:left"><code>java.util.Random</code></td><td style="text-align:left">API 丰富，符合直觉。</td></tr><tr><td style="text-align:left"><strong>高并发 / 多线程</strong></td><td style="text-align:left"><code>ThreadLocalRandom</code></td><td style="text-align:left"><strong>性能王者</strong>，不堵车。</td></tr><tr><td style="text-align:left"><strong>生成密码 / 涉及钱</strong></td><td style="text-align:left"><code>SecureRandom</code></td><td style="text-align:left"><strong>安全王者</strong>，黑客猜不到。</td></tr></tbody></table></div><h3 id="💡-讲师提示"><a href="#💡-讲师提示" class="headerlink" title="💡 讲师提示"></a>💡 讲师提示</h3><p>作为新手，你现阶段主要掌握 <strong><code>java.util.Random</code></strong> 就足够应对 90% 的学习场景了。但记住，等到以后做Web项目生成验证码时，一定要想起来用 <code>SecureRandom</code> 哦！</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>语法知识</tag>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java为什么不用const</title>
    <link href="/2025/12/23/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8const/"/>
    <url>/2025/12/23/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8const/</url>
    
    <content type="html"><![CDATA[<p>在学习 Java 时，很多从 C++ 或 C# 转过来的小伙伴都会下意识地去找 <code>const</code>。但在 Java 中，情况有点特殊。</p><hr><h2 id="1-const：有名无实的“保留字”"><a href="#1-const：有名无实的“保留字”" class="headerlink" title="1. const：有名无实的“保留字”"></a>1. <code>const</code>：有名无实的“保留字”</h2><p><strong>概念定义</strong>：在 Java 中，<code>const</code> 被称为<strong>保留字（Reserved Word）</strong>，而不是<strong>关键字（Keyword）</strong>。</p><ul><li><strong>现状</strong>：它在 Java 源码中存在，但没有任何语法功能。</li><li><strong>规则</strong>：你不能用 <code>const</code> 来定义常量，同时你也<strong>不能</strong>用 <code>const</code> 作为你的变量名。</li><li><strong>为什么保留它？</strong>：主要是为了防止程序员在写 Java 时误用了 C++ 的习惯，或者为了将来可能的版本升级预留位置。</li></ul><hr><h2 id="2-真正的常量主角：final"><a href="#2-真正的常量主角：final" class="headerlink" title="2. 真正的常量主角：final"></a>2. 真正的常量主角：<code>final</code></h2><p><strong>概念定义</strong>：在 Java 中，如果你想定义一个“一旦赋值就不能改变”的量，必须使用关键字 <strong><code>final</code></strong>。</p><h3 id="核心规则："><a href="#核心规则：" class="headerlink" title="核心规则："></a>核心规则：</h3><ol><li><strong>不可变性</strong>：被 <code>final</code> 修饰的变量，只能被赋值一次，之后再尝试修改会直接报错。</li><li><strong>命名规范</strong>：Java 中的常量通常要求<strong>全部大写</strong>，多个单词之间用下划线 <code>_</code> 分隔（例如：<code>MAX_SPEED</code>）。</li><li><strong>修饰位置</strong>：<code>final</code> 既可以修饰局部变量，也可以修饰类成员变量。</li></ol><hr><h2 id="3-代码示例：如何正确定义常量"><a href="#3-代码示例：如何正确定义常量" class="headerlink" title="3. 代码示例：如何正确定义常量"></a>3. 代码示例：如何正确定义常量</h2><p>在实际开发中，我们通常结合 <code>static</code> 和 <code>final</code> 来定义一个全局常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstantDemo</span> &#123;<br>    <span class="hljs-comment">// 1. 类级别的全局常量（最常见用法）</span><br>    <span class="hljs-comment">// static 让它属于类，final 保证它不可变</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926535</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_LOGIN_ATTEMPTS</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 2. 局部常量</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <br>        <span class="hljs-comment">// age = 21; // ❌ 编译报错：无法为最终变量 age 分配值</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;圆周率是：&quot;</span> + PI);<br>        System.out.println(<span class="hljs-string">&quot;我的年龄是：&quot;</span> + age);<br>        <br>        <span class="hljs-comment">// 3. 错误示范（如果你非要用 const）</span><br>        <span class="hljs-comment">// int const = 10; // ❌ 编译报错：const 是保留字，不能用作标识符</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-final-与-const-的对比-Java-vs-其他语言"><a href="#4-final-与-const-的对比-Java-vs-其他语言" class="headerlink" title="4. final 与 const 的对比 (Java vs 其他语言)"></a>4. <code>final</code> 与 <code>const</code> 的对比 (Java vs 其他语言)</h2><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Java 的 <code>final</code></th><th style="text-align:left">C++/C# 的 <code>const</code></th></tr></thead><tbody><tr><td style="text-align:left"><strong>定义常量</strong></td><td style="text-align:left">✅ 完美支持</td><td style="text-align:left">✅ 完美支持</td></tr><tr><td style="text-align:left"><strong>运行期赋值</strong></td><td style="text-align:left">✅ 支持（可以在运行时计算值再锁定）</td><td style="text-align:left">❌ 通常要求编译期确定值</td></tr><tr><td style="text-align:left"><strong>修饰类/方法</strong></td><td style="text-align:left">✅ 可以（防止类被继承或方法被重写）</td><td style="text-align:left">❌ 通常只修饰变量</td></tr></tbody></table></div><h1 id="进阶笔记：Java-final-vs-C-C-const-的三大本质区别"><a href="#进阶笔记：Java-final-vs-C-C-const-的三大本质区别" class="headerlink" title="进阶笔记：Java final vs C++/C# const 的三大本质区别"></a>进阶笔记：Java <code>final</code> vs C++/C# <code>const</code> 的三大本质区别</h1><p>很多编程语言都有 <code>const</code>，但在 Java 中，<code>final</code> 承担了更多的职责。你提到的“运行期赋值”和“修饰类/方法”正是它的灵魂所在。</p><hr><h3 id="4-1-运行期赋值：不仅仅是“死板”的常量"><a href="#4-1-运行期赋值：不仅仅是“死板”的常量" class="headerlink" title="4.1. 运行期赋值：不仅仅是“死板”的常量"></a>4.1. 运行期赋值：不仅仅是“死板”的常量</h3><p>在 C# 等语言中，<code>const</code> 要求在<strong>编译时</strong>就确定值（比如 <code>3.14</code>）。但 Java 的 <code>final</code> 允许你在<strong>运行时</strong>再决定它的值，一旦定下来，就不再更改。</p><p><strong>比喻</strong>：<code>const</code> 是“出厂即刻字”，而 <code>final</code> 是“发货前才填写的终身快递单”。</p><p><strong>代码示例</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalRuntimeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 运行期赋值：每次运行，value 的值可能都不一样</span><br>        <span class="hljs-comment">// 但在同一个生命周期内，value 一旦被赋值就不能再改</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;本次运行确定的常量值：&quot;</span> + value);<br>        <br>        <span class="hljs-comment">// value = 200; // ❌ 依然会报错，因为它已经是 final 了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><strong>应用场景</strong>：比如根据用户的输入、数据库的查询结果、或者是当前系统的年份来初始化一个“只读变量”。</p><hr><h3 id="2-架构防线：修饰类与方法"><a href="#2-架构防线：修饰类与方法" class="headerlink" title="2. 架构防线：修饰类与方法"></a>2. 架构防线：修饰类与方法</h3><p>这是 <code>const</code> 完全无法触及的领域。在 Java 中，<code>final</code> 被用来保护代码的<strong>继承结构</strong>。</p><h4 id="A-修饰方法-Prevent-Overriding"><a href="#A-修饰方法-Prevent-Overriding" class="headerlink" title="A. 修饰方法 (Prevent Overriding)"></a>A. 修饰方法 (Prevent Overriding)</h4><p><strong>规则</strong>：父类的方法被 <code>final</code> 修饰后，子类<strong>不能重写</strong>它。<br><strong>意义</strong>：锁定核心逻辑，防止子类“乱改”导致逻辑崩溃。</p><h4 id="B-修饰类-Prevent-Inheritance"><a href="#B-修饰类-Prevent-Inheritance" class="headerlink" title="B. 修饰类 (Prevent Inheritance)"></a>B. 修饰类 (Prevent Inheritance)</h4><p><strong>规则</strong>：类被 <code>final</code> 修饰后，<strong>不能被继承</strong>。<br><strong>意义</strong>：比如 <code>String</code> 类就是 <code>final</code> 的。如果人人都能继承并修改 <code>String</code> 的行为，整个 Java 世界就乱套了。</p><p><strong>代码示例</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是一个 final 类，不能有“儿子”</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecuritySystem</span> &#123;<br>    <br>    <span class="hljs-comment">// 这是一个 final 方法，子类即便能继承（如果类不是 final），也不能修改</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verifyIdentity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行极其严格的身份核验逻辑，禁止修改！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class HackSystem extends SecuritySystem &#123; &#125; // ❌ 报错：无法从最终类继承</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="3-深度对比表：为什么-final-比-const-更强大？"><a href="#3-深度对比表：为什么-final-比-const-更强大？" class="headerlink" title="3. 深度对比表：为什么 final 比 const 更强大？"></a>3. 深度对比表：为什么 <code>final</code> 比 <code>const</code> 更强大？</h3><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Java <code>final</code></th><th style="text-align:left">典型 <code>const</code> (如 C#)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>赋值时机</strong></td><td style="text-align:left"><strong>编译期 或 运行期</strong></td><td style="text-align:left">通常只能是 <strong>编译期</strong></td></tr><tr><td style="text-align:left"><strong>修饰变量</strong></td><td style="text-align:left">✅ 锁定引用/值</td><td style="text-align:left">✅ 锁定值</td></tr><tr><td style="text-align:left"><strong>修饰类</strong></td><td style="text-align:left">✅ 禁止继承</td><td style="text-align:left">❌ 不支持 (C# 用 <code>sealed</code>)</td></tr><tr><td style="text-align:left"><strong>修饰方法</strong></td><td style="text-align:left">✅ 禁止重写</td><td style="text-align:left">❌ 不支持</td></tr><tr><td style="text-align:left"><strong>对象控制</strong></td><td style="text-align:left">只能锁定“盒子”不换，不能锁“内容”</td><td style="text-align:left">深度锁定（C++ 的 const 语义更强）</td></tr></tbody></table></div><hr><h3 id="4-重点避坑：引用不变-vs-内容不变"><a href="#4-重点避坑：引用不变-vs-内容不变" class="headerlink" title="4. 重点避坑：引用不变 vs 内容不变"></a>4. 重点避坑：引用不变 vs 内容不变</h3><p>这是新手最容易掉坑的地方：<strong><code>final</code> 修饰对象时，只是锁定了“地址”，没锁定“属性”。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>user.setName(<span class="hljs-string">&quot;Jerry&quot;</span>); <span class="hljs-comment">// ✅ 允许！内容可以变</span><br><span class="hljs-comment">// user = new User(&quot;Jack&quot;); // ❌ 报错！不能把 user 指向新对象</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>javatomd 总结</strong>：</p><h2 id="C-等语言追求的是“数据的绝对不可变”（Const-correctness），而-Java-的-final-追求的是-“引用的稳定性”-和-“架构的安全性”。"><a href="#C-等语言追求的是“数据的绝对不可变”（Const-correctness），而-Java-的-final-追求的是-“引用的稳定性”-和-“架构的安全性”。" class="headerlink" title="C++ 等语言追求的是“数据的绝对不可变”（Const-correctness），而 Java 的 final 追求的是 “引用的稳定性” 和 “架构的安全性”。"></a>C++ 等语言追求的是“数据的绝对不可变”（Const-correctness），而 Java 的 <code>final</code> 追求的是 <strong>“引用的稳定性”</strong> 和 <strong>“架构的安全性”</strong>。</h2></blockquote><h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><ul><li><strong>固定配置</strong>：如数据库连接地址、API 的基础 URL。</li><li><strong>数学常数</strong>：如 $\pi$、自然对数 $e$ 等。</li><li><strong>业务逻辑限制</strong>：如订单的最大重试次数、用户的最小注册年龄。</li></ul><blockquote><p><strong>javatomd 总结</strong>：<br>记住一句话：<strong>在 Java 里想定义常量，请把 <code>final</code> 请出来，让 <code>const</code> 继续在角落里吃灰吧！</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo每次一定要“三件套”吗？</title>
    <link href="/2025/12/22/%E6%AF%8F%E6%AC%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E2%80%9C%E4%B8%89%E4%BB%B6%E5%A5%97%E2%80%9D%E5%90%97%EF%BC%9F/"/>
    <url>/2025/12/22/%E6%AF%8F%E6%AC%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E2%80%9C%E4%B8%89%E4%BB%B6%E5%A5%97%E2%80%9D%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>很多新手在开始使用 Hexo 时，习惯性地每次修改都执行 <code>hexo clean</code>, <code>hexo g</code>, <code>hexo s</code>。但在实际开发和写作中，这样做非常浪费时间。以下是根据不同场景推荐的最佳工作流，帮你把时间花在写作上，而不是等待编译。</p><h2 id="1-场景一：日常写文章-修改内容（最常见）"><a href="#1-场景一：日常写文章-修改内容（最常见）" class="headerlink" title="1. 场景一：日常写文章 / 修改内容（最常见）"></a>1. 场景一：日常写文章 / 修改内容（最常见）</h2><p><strong>场景描述</strong>：你在 <code>source/_posts</code> 下新建了一个 <code>.md</code>，或者修改了已有的文章内容、错别字。</p><ul><li><strong>是否需要三连？</strong>：<strong>完全不需要。</strong></li><li><strong>最佳操作</strong>：<ol><li>保持终端里的 <code>hexo s</code> 运行着不要关闭。</li><li>在编辑器里直接修改并保存 <code>.md</code> 文件。</li><li><strong>直接刷新浏览器页面</strong>。</li></ol></li><li><strong>原理</strong>：<code>hexo s</code> 带有“局部监听”功能，它会自动检测 <code>source</code> 文件夹的变化并实时渲染，速度极快。</li></ul><h2 id="2-场景二：修改了配置文件"><a href="#2-场景二：修改了配置文件" class="headerlink" title="2. 场景二：修改了配置文件"></a>2. 场景二：修改了配置文件</h2><p><strong>场景描述</strong>：你修改了根目录的 <code>_config.yml</code> 或主题的 <code>_config.fluid.yml</code>（例如改了网站标题、换了封面图路径）。</p><ul><li><strong>是否需要三连？</strong>：<strong>建议重启并 Clean。</strong></li><li><strong>最佳操作</strong>：<ol><li>在终端按下 <code>Ctrl + C</code> 关闭当前预览服务。</li><li>执行 <code>hexo clean</code>（确保清除旧的配置缓存）。</li><li>执行 <code>hexo s</code> 重新启动。</li></ol></li><li><strong>原理</strong>：配置文件只在服务器启动的一瞬间被读取，热重载通常无法捕捉到这些全局参数的变化。</li></ul><h2 id="3-场景三：删除了文件或移动了文件夹"><a href="#3-场景三：删除了文件或移动了文件夹" class="headerlink" title="3. 场景三：删除了文件或移动了文件夹"></a>3. 场景三：删除了文件或移动了文件夹</h2><p><strong>场景描述</strong>：你删除了某篇旧文章，或者把 <code>source/img</code> 里的图片重命名了。</p><ul><li><strong>是否需要三连？</strong>：<strong>必须执行。</strong></li><li><strong>原因</strong>：如果不执行 <code>clean</code>，<code>public</code>（生成的静态文件夹）里还会残留以前生成的旧文件。这会导致预览时出现已经删掉的文章依然存在，或者图片出现 404 的情况。</li></ul><h2 id="4-场景四：发布到正式环境（如-GitHub-Pages）"><a href="#4-场景四：发布到正式环境（如-GitHub-Pages）" class="headerlink" title="4. 场景四：发布到正式环境（如 GitHub Pages）"></a>4. 场景四：发布到正式环境（如 GitHub Pages）</h2><p><strong>场景描述</strong>：你在本地预览一切完美，准备部署上线。</p><ul><li><strong>最佳操作</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo d  <span class="hljs-comment"># 部署命令</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="⚡-提高效率的小技巧"><a href="#⚡-提高效率的小技巧" class="headerlink" title="⚡ 提高效率的小技巧"></a>⚡ 提高效率的小技巧</h2><h3 id="1-复合命令"><a href="#1-复合命令" class="headerlink" title="1. 复合命令"></a>1. 复合命令</h3><p>你可以用 <code>&amp;&amp;</code> 符号把命令连起来，输入一次回车，电脑会自动按顺序执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改了配置想重启预览</span><br>hexo clean &amp;&amp; hexo s<br><br><span class="hljs-comment"># 准备一键部署</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure></p><h3 id="2-什么时候才必须用-clean？"><a href="#2-什么时候才必须用-clean？" class="headerlink" title="2. 什么时候才必须用 clean？"></a>2. 什么时候才必须用 <code>clean</code>？</h3><ul><li><p>修改了主题的源码（如 CSS 或 JS 文件）。</p></li><li><p>发现网页显示莫名其妙。</p></li><li><p>在准备提交发布（<code>hexo d</code>）之前。</p></li></ul><hr><p><strong>总结</strong>：<strong>写文只需 <code>Ctrl + S</code> + 刷新；改配置才需要 <code>Clean</code> 重启。</strong> </p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>教程</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 主题更换Fluid</title>
    <link href="/2025/12/22/%E6%9B%B4%E6%8D%A2Fluid%E4%B8%BB%E9%A2%98/"/>
    <url>/2025/12/22/%E6%9B%B4%E6%8D%A2Fluid%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天对 Hexo 博客进行了“大整容”，将默认主题更换为了 <strong>Fluid</strong>。过程中由于安装方式和文件路径问题踩了不少坑，现将完整的更换流程与解决方案总结如下。</p><h2 id="1-主题更换流程"><a href="#1-主题更换流程" class="headerlink" title="1 主题更换流程"></a>1 主题更换流程</h2><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">主题官网</a></p><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 安装主题</h3><p>按照官网教程，Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><br>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><h3 id="1-2-配置文件初始化"><a href="#1-2-配置文件初始化" class="headerlink" title="1.2. 配置文件初始化"></a>1.2. 配置文件初始化</h3><p>由于 <code>themes</code> 文件夹为空，需要在博客根目录下手动创建 <strong><code>_config.fluid.yml</code></strong>。<br><strong>关键点</strong>：可以前往 Fluid 官方 GitHub 仓库复制完整的<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">配置模板内容</a>并粘贴进 <strong><code>_config.fluid.yml</code></strong>。</p><h2 id="2-标题修改"><a href="#2-标题修改" class="headerlink" title="2. 标题修改"></a>2. 标题修改</h2><p>标题分为三个层级：浏览器标签页标题、导航栏文字、封面大标题。</p><h3 id="2-1-浏览器标签页标题-Browser-Tab-Title"><a href="#2-1-浏览器标签页标题-Browser-Tab-Title" class="headerlink" title="2.1 浏览器标签页标题 (Browser Tab Title)"></a>2.1 浏览器标签页标题 (Browser Tab Title)</h3><p>这是显示在浏览器最顶端标签上的文字。</p><ul><li><strong>修改文件</strong>：根目录下的 <code>_config.yml</code> (全局配置)。</li><li><strong>操作</strong>：修改 <code>title</code> 字段。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># _config.yml</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">大雪深埋</span>  <span class="hljs-comment"># 这里的修改会直接改变浏览器标签页显示的内容</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="3-首页封面-Banner-修改"><a href="#3-首页封面-Banner-修改" class="headerlink" title="3. 首页封面 (Banner) 修改"></a>3. 首页封面 (Banner) 修改</h2><h3 id="3-1-封面背景图修改-banner-img"><a href="#3-1-封面背景图修改-banner-img" class="headerlink" title="3.1 封面背景图修改 (banner_img)"></a>3.1 封面背景图修改 (banner_img)</h3><p>这是最容易踩坑的地方，涉及路径和存放位置。</p><ul><li><strong>正确存放</strong>：将图片放入 <code>source/img/</code>（例如 <code>guts.png</code>）。</li><li><strong>路径配置</strong>：在 <code>_config.fluid.yml</code> 中搜索 <code>banner_img</code>。</li><li><strong>注意事项</strong>：必须使用<strong>正斜杠 <code>/</code></strong>。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># _config.fluid.yml</span><br><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/guts.png</span>  <span class="hljs-comment"># 路径必须从 /img 开始</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-问题——封面图消失"><a href="#4-问题——封面图消失" class="headerlink" title="4.问题——封面图消失"></a>4.问题——封面图消失</h2><p>在配置 <code>banner_img</code> 封面图时遇到了图片在预览时消失的问题，总结原因如下：</p><ul><li><strong>存放路径错误</strong>：图片不能直接放在 <code>public</code> 文件夹中，因为每次执行 <code>hexo clean</code> 时，该文件夹都会被清空。</li><li><strong>正确位置</strong>：必须将图片存放在 <strong><code>source/img/</code></strong> 文件夹下，由 Hexo 编译后自动同步到 public 目录。</li><li><strong>路径语法限制</strong>：在配置文件中，路径必须使用<strong>正斜杠 <code>/</code></strong>（例如 <code>/img/guts.png</code>），不能使用 Windows 风格的反斜杠 <code>\</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo和GitHub搭建博客全记录</title>
    <link href="/2025/12/21/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/12/21/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>确保你的电脑环境已经安装了以下软件：</p><ul><li><strong>Node.js</strong>: 建议安装 LTS 版本。</li><li><strong>Git</strong>: 用于将代码推送到 GitHub。</li></ul><h2 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h2><p>在终端依次输入以下命令进行初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全局安装脚手架</span><br>npm install -g hexo-cli<br><br><span class="hljs-comment"># 初始化项目文件夹</span><br>hexo init myblog<br><span class="hljs-built_in">cd</span> myblog<br><br><span class="hljs-comment"># 安装依赖</span><br>npm install<br></code></pre></td></tr></table></figure><h2 id="3-联动-GitHub-关键步骤"><a href="#3-联动-GitHub-关键步骤" class="headerlink" title="3. 联动 GitHub (关键步骤)"></a>3. 联动 GitHub (关键步骤)</h2><p>在本地搭建好 Hexo 后，需要通过以下配置将其发布到 GitHub。</p><h3 id="3-1-创建-GitHub-仓库"><a href="#3-1-创建-GitHub-仓库" class="headerlink" title="3.1 创建 GitHub 仓库"></a>3.1 创建 GitHub 仓库</h3><ol><li><p>登录 GitHub，新建一个仓库（New repository）。</p></li><li><p><strong>仓库名（Repository Name）</strong> 必须填：<code>你的用户名.github.io</code>。</p></li><li><p>确保仓库设为 <strong>Public</strong>。</p></li></ol><h3 id="3-2-安装-Git-部署插件"><a href="#3-2-安装-Git-部署插件" class="headerlink" title="3.2 安装 Git 部署插件"></a>3.2 安装 Git 部署插件</h3><p>在你的博客根目录（<code>myblog</code>）下运行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="3-3-修改站点配置文件"><a href="#3-3-修改站点配置文件" class="headerlink" title="3.3 修改站点配置文件"></a>3.3 修改站点配置文件</h3><p>打开目录下的 <code>_config.yml</code> 文件，拉到最底部，修改 <code>deploy</code> 部分：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:你的用户名/你的用户名.github.io.git<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：YAML 格式要求冒号 <code>:</code> 后必须留一个空格。建议使用 SSH 链接以避免频繁输入密码。</p></blockquote><h2 id="4-遇到的坑与解决方法"><a href="#4-遇到的坑与解决方法" class="headerlink" title="4. 遇到的坑与解决方法"></a>4. 遇到的坑与解决方法</h2><h3 id="问题一：无法连接-GitHub"><a href="#问题一：无法连接-GitHub" class="headerlink" title="问题一：无法连接 GitHub"></a>问题一：无法连接 GitHub</h3><p>报错信息：fatal: unable to access … Failed to connect to port 443</p><p>解决方法：</p><p>这是因为网络问题导致无法直接访问 GitHub。如果你有代理服务器（例如端口是 10808），可以设置 Git 全局代理：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-selector-attr">[http://127.0.0.1:10808]</span>(http:<span class="hljs-comment">//127.0.0.1:10808)</span><br>git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-selector-attr">[https://127.0.0.1:10808]</span>(https:<span class="hljs-comment">//127.0.0.1:10808)</span><br></code></pre></td></tr></table></figure><h3 id="问题二：部署后-404-或样式乱码"><a href="#问题二：部署后-404-或样式乱码" class="headerlink" title="问题二：部署后 404 或样式乱码"></a>问题二：部署后 404 或样式乱码</h3><p><strong>原因</strong>：</p><ol><li><p>仓库设为了 Private（私有）。</p></li><li><p>_config.yml 中的 url 配置不正确。</p><p> 解决方法：</p></li><li><p>进入 GitHub 仓库 Settings -&gt; Danger Zone -&gt; Change visibility，改为 <strong>Public</strong>。</p></li><li><p>检查 <code>_config.yml</code> 中的 <code>url</code> 是否填写的为 <code>https://你的用户名.github.io</code>。</p></li></ol><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5. 常用命令"></a>5. 常用命令</h2><p>每次更新博客只需要这三步：</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>命令</strong></td><td><strong>作用</strong></td><td><strong>简写</strong></td></tr><tr><td><code>hexo clean</code></td><td>清除缓存（推荐部署前执行）</td><td>无</td></tr><tr><td><code>hexo generate</code></td><td>生成静态网页文件</td><td><code>hexo g</code></td></tr><tr><td><code>hexo server</code></td><td>启动本地预览（localhost:4000）</td><td><code>hexo s</code></td></tr><tr><td><code>hexo deploy</code></td><td>推送到 GitHub 线上</td><td><code>hexo d</code></td></tr></tbody></table></div><p><strong>标准发布流程：</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
