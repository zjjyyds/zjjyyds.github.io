<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二分思想不只能查找</title>
    <link href="/2026/01/03/%E4%BA%8C%E5%88%86/"/>
    <url>/2026/01/03/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="1-四种需求通用转换公式"><a href="#1-四种需求通用转换公式" class="headerlink" title="1. 四种需求通用转换公式"></a>1. 四种需求通用转换公式</h3><p>无论使用开区间还是闭区间写法，核心逻辑都是通过 <code>lowerBound</code> 来实现的。以下公式适用于所有情况：</p><div class="table-container"><table><thead><tr><th style="text-align:left">你的需求</th><th style="text-align:left">转化为 <code>lowerBound</code></th><th style="text-align:left">结果下标处理</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><strong>找 $\ge x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x)</code></td><td style="text-align:left">无</td><td style="text-align:left">标准定义</td></tr><tr><td style="text-align:left"><strong>找 $&gt; x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1)</code></td><td style="text-align:left">无</td><td style="text-align:left">整数性质：$&gt;x \Leftrightarrow \ge x+1$</td></tr><tr><td style="text-align:left"><strong>找 $&lt; x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x)</code></td><td style="text-align:left"><code>- 1</code></td><td style="text-align:left">$\ge x$ 的左边就是 $&lt; x$</td></tr><tr><td style="text-align:left"><strong>找 $\le x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1)</code></td><td style="text-align:left"><code>- 1</code></td><td style="text-align:left">$&gt; x$ 的左边就是 $\le x$</td></tr></tbody></table></div><hr><h3 id="2-开区间写法-Open-Interval"><a href="#2-开区间写法-Open-Interval" class="headerlink" title="2. 开区间写法 (Open Interval)"></a>2. 开区间写法 (Open Interval)</h3><p><strong>特点</strong>：逻辑最统一，无需考虑 <code>+1/-1</code> 细节，不易死循环。<br><strong>区间定义</strong>：<code>(-1, n)</code>。<code>left</code> 始终指向红色（不满足），<code>right</code> 始终指向蓝色（满足）。</p><h4 id="2-1-Java-开区间"><a href="#2-1-Java-开区间" class="headerlink" title="2.1 Java (开区间)"></a>2.1 Java (开区间)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 初始化：开区间 (left, right)</span><br>    <span class="hljs-comment">// left = -1 代表红色区域（&lt; target）</span><br>    <span class="hljs-comment">// right = n 代表蓝色区域（&gt;= target）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, right = nums.length;<br>    <br>    <span class="hljs-comment">// 循环不变量：left + 1 &lt; right (区间不为空)</span><br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// 核心判断：mid 在哪边？</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid; <span class="hljs-comment">// mid 满足条件(蓝色)，可能是答案，向左收缩</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// mid 不满足条件(红色)，答案在右边，向右收缩</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 循环结束时 left + 1 == right</span><br>    <span class="hljs-comment">// right 指向第一个满足 &gt;= target 的位置</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-C语言-开区间"><a href="#2-2-C语言-开区间" class="headerlink" title="2.2 C语言 (开区间)"></a>2.2 C语言 (开区间)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = numsSize;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid; <span class="hljs-comment">// 蓝色区域，更新右边界</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// 红色区域，更新左边界</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 返回蓝色区域的起点</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-闭区间写法-Closed-Interval-——-教科书经典"><a href="#3-闭区间写法-Closed-Interval-——-教科书经典" class="headerlink" title="3. 闭区间写法 (Closed Interval) —— 教科书经典"></a>3. 闭区间写法 (Closed Interval) —— 教科书经典</h3><p><strong>特点</strong>：最常见，面试中常用。<br><strong>区间定义</strong>：<code>[0, n-1]</code>。每次更新必须排除 <code>mid</code>。</p><h4 id="3-1-Java-闭区间"><a href="#3-1-Java-闭区间" class="headerlink" title="3.1 Java (闭区间)"></a>3.1 Java (闭区间)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 循环结束条件：left &gt; right</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 尝试查找更小的下标</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 必须查找更大的下标</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// left 指向第一个 &gt;= target 的位置</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-C语言-闭区间"><a href="#3-2-C语言-闭区间" class="headerlink" title="3.2 C语言 (闭区间)"></a>3.2 C语言 (闭区间)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = numsSize - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li><strong>开区间</strong>：初始化 <code>(-1, n)</code>，更新 <code>left=mid</code> / <code>right=mid</code>，返回 <code>right</code>。记忆口诀：<strong>check 成功更新谁，最后就返回谁</strong>（针对 <code>lowerBound</code> 求最小，check 成功更新 right，故返回 right）。</li><li><strong>闭区间</strong>：初始化 <code>[0, n-1]</code>，更新 <code>mid+1</code> / <code>mid-1</code>，返回 <code>left</code>。</li></ul><h3 id="5-找不到时的返回值"><a href="#5-找不到时的返回值" class="headerlink" title="5. 找不到时的返回值"></a>5. 找不到时的返回值</h3><p>无论是<strong>开区间</strong>还是<strong>闭区间</strong>，标准的 <code>lowerBound</code>（寻找第一个 $\ge target$ 的下标）算法在“找不到”时的表现是<strong>一致的</strong>：</p><ol><li><strong>如果数组中所有数都小于 <code>target</code></strong>（即目标值太大，越界）：返回 <strong>数组长度 <code>n</code></strong>。</li><li><strong>如果数组中所有数都大于等于 <code>target</code></strong>（即目标值比谁都小）：返回 <strong><code>0</code></strong>。</li><li><strong>如果目标值在数组范围内但不存在</strong>：返回它<strong>按顺序应该插入的位置</strong>（即第一个大于它的数的下标）。</li></ol><hr><h4 id="5-1-详细对比与解释"><a href="#5-1-详细对比与解释" class="headerlink" title="5.1 详细对比与解释"></a>5.1 详细对比与解释</h4><h5 id="5-1-1-开区间写法-Open-Interval"><a href="#5-1-1-开区间写法-Open-Interval" class="headerlink" title="5.1.1 开区间写法 (Open Interval)"></a>5.1.1 开区间写法 (Open Interval)</h5><ul><li><strong>初始化</strong>：<code>left = -1</code>, <code>right = n</code>。</li><li><strong>循环结束</strong>：<code>left + 1 == right</code>。</li><li><strong>返回值</strong>：<strong><code>right</code></strong>。</li><li><strong>“找不到”的情况</strong>：<ul><li><strong>Target 太大</strong>（所有数都 <code>&lt; target</code>）：<code>check(mid)</code> 永远为 <code>False</code>，<code>right</code> 从未被更新，始终保持初始值 <strong><code>n</code></strong>。</li><li><strong>Target 太小</strong>（所有数都 <code>≥ target</code>）：<code>check(mid)</code> 永远为 <code>True</code>，<code>right</code> 不断向左收缩，最终变为 <strong><code>0</code></strong>（此时 <code>left</code> 仍为 <code>-1</code>）。</li></ul></li></ul><h5 id="5-1-2-闭区间写法-Closed-Interval"><a href="#5-1-2-闭区间写法-Closed-Interval" class="headerlink" title="5.1.2 闭区间写法 (Closed Interval)"></a>5.1.2 闭区间写法 (Closed Interval)</h5><ul><li><strong>初始化</strong>：<code>left = 0</code>, <code>right = n - 1</code>。</li><li><strong>循环结束</strong>：<code>left &gt; right</code>。</li><li><strong>返回值</strong>：<strong><code>left</code></strong>。</li><li><strong>“找不到”的情况</strong>：<ul><li><strong>Target 太大</strong>：<code>nums[mid] &lt; target</code> 始终成立，<code>left</code> 不断右移（<code>mid + 1</code>），直到最后一次循环时 <code>left</code> 变为 <strong><code>n</code></strong>，循环结束。</li><li><strong>Target 太小</strong>：<code>nums[mid] &gt;= target</code> 始终成立，<code>right</code> 不断左移，<code>left</code> 保持初始值 <strong><code>0</code></strong> 不动。</li></ul></li></ul><hr><h4 id="5-2-特殊变种的“找不到”返回值"><a href="#5-2-特殊变种的“找不到”返回值" class="headerlink" title="5.2 特殊变种的“找不到”返回值"></a>5.2 特殊变种的“找不到”返回值</h4><p>根据资料，基于 <code>lowerBound</code> 衍生出的其他三种查找需求，其“找不到”的返回值如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">查找需求</th><th style="text-align:left">转化公式</th><th style="text-align:left"><strong>找不到时的返回值</strong></th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>$\ge x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x)</code></td><td style="text-align:left"><strong><code>n</code></strong></td><td style="text-align:left">所有数都 $&lt; x$</td></tr><tr><td style="text-align:left"><strong>$&gt; x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1)</code></td><td style="text-align:left"><strong><code>n</code></strong></td><td style="text-align:left">所有数都 $\le x$</td></tr><tr><td style="text-align:left"><strong>$&lt; x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x) - 1</code></td><td style="text-align:left"><strong><code>-1</code></strong></td><td style="text-align:left">所有数都 $\ge x$ (即 <code>lowerBound</code> 返回 0)</td></tr><tr><td style="text-align:left"><strong>$\le x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1) - 1</code></td><td style="text-align:left"><strong><code>-1</code></strong></td><td style="text-align:left">所有数都 $&gt; x$ (即 <code>lowerBound</code> 返回 0)</td></tr></tbody></table></div><h4 id="5-3-如何判断“精确查找（Equal）”失败？"><a href="#5-3-如何判断“精确查找（Equal）”失败？" class="headerlink" title="5.3 如何判断“精确查找（Equal）”失败？"></a>5.3 如何判断“精确查找（Equal）”失败？</h4><p>如果你需要的是“找到返回下标，<strong>找不到返回 -1</strong>”的逻辑（即标准的 <code>indexOf</code>），无论使用开区间还是闭区间，都需要在拿到返回值后增加一步判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设 idx 是 lowerBound 的返回值 (无论开闭区间)</span><br>idx = lower_bound(nums, target)<br><br><span class="hljs-comment"># 必须同时满足两个条件才算“找到了”：</span><br><span class="hljs-comment"># 1. idx 不越界 (idx &lt; n)</span><br><span class="hljs-comment"># 2. 该位置的值确实等于 target</span><br><span class="hljs-keyword">if</span> idx &lt; <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">and</span> nums[idx] == target:<br>    <span class="hljs-keyword">return</span> idx<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># 真正的“找不到”</span><br></code></pre></td></tr></table></figure><h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><h3 id="1-核心概念与思维模型"><a href="#1-核心概念与思维模型" class="headerlink" title="1. 核心概念与思维模型"></a>1. 核心概念与思维模型</h3><ul><li><strong>基本定义</strong>：“花费一个 $\log$ 的时间，增加了一个条件”。我们将求解最优解（求最小/最大）的问题，转化为在一个<strong>虚拟的有序数组</strong> <code>[check(min), ..., check(max)]</code> 中寻找分界点的问题。</li><li><strong>红蓝染色法</strong>：与数组二分一样，我们将解空间分为两部分：<ul><li><strong>红色</strong>：不满足题目要求的区域。</li><li><strong>蓝色</strong>：满足题目要求的区域。</li><li><strong>目标</strong>：寻找红蓝分界线。</li></ul></li></ul><hr><h3 id="2-两大核心类型"><a href="#2-两大核心类型" class="headerlink" title="2. 两大核心类型"></a>2. 两大核心类型</h3><p>根据题目要求寻找的是“最小值”还是“最大值”，解题模型分为两类。资料强烈推荐使用<strong>开区间</strong>写法，因为它逻辑最统一。</p><h4 id="2-1-类型一：求最小-Find-Minimum"><a href="#2-1-类型一：求最小-Find-Minimum" class="headerlink" title="2.1 类型一：求最小 (Find Minimum)"></a>2.1 类型一：求最小 (Find Minimum)</h4><ul><li><strong>适用场景</strong>：<ul><li>求满足条件的<strong>最小值</strong>（如：完成任务的最少时间、最小花费）。</li><li><strong>最小化最大值</strong>（如：分割数组的最大值最小是多少）。</li><li><strong>第 K 小</strong>（转化为：求最小的 $x$，使得 $\le x$ 的数至少有 $k$ 个）。</li></ul></li><li><strong>染色模型</strong>：左边 <code>False</code>（红色），<strong>右边 <code>True</code>（蓝色）</strong>。</li><li><strong>核心逻辑</strong>：我们要找<strong>蓝色区域的起点</strong>。</li><li><strong>开区间口诀</strong>：<code>check</code> 成功更新 <code>right</code>，最后返回 <code>right</code>。</li></ul><h4 id="2-2-类型二：求最大-Find-Maximum"><a href="#2-2-类型二：求最大-Find-Maximum" class="headerlink" title="2.2 类型二：求最大 (Find Maximum)"></a>2.2 类型二：求最大 (Find Maximum)</h4><ul><li><strong>适用场景</strong>：<ul><li>求满足条件的<strong>最大值</strong>（如：最大收益、H指数）。</li><li><strong>最大化最小值</strong>（如：两球之间的最大磁力、让所有人分到的最小值最大）。</li></ul></li><li><strong>染色模型</strong>：<strong>左边 <code>True</code>（蓝色）</strong>，右边 <code>False</code>（红色）。</li><li><strong>核心逻辑</strong>：我们要找<strong>蓝色区域的终点</strong>。</li><li><strong>开区间口诀</strong>：<code>check</code> 成功更新 <code>left</code>，最后返回 <code>left</code>。</li></ul><hr><h3 id="3-四种常见应用模式"><a href="#3-四种常见应用模式" class="headerlink" title="3. 四种常见应用模式"></a>3. 四种常见应用模式</h3><div class="table-container"><table><thead><tr><th style="text-align:left">模式名称</th><th style="text-align:left">本质归属</th><th style="text-align:left">典型题目描述</th><th style="text-align:left">核心 Check 思路</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基础最值</strong></td><td style="text-align:left">求最小/最大</td><td style="text-align:left">x 秒能否完成？</td><td style="text-align:left">模拟过程，判断是否可行</td></tr><tr><td style="text-align:left"><strong>最小化最大值</strong></td><td style="text-align:left"><strong>求最小</strong></td><td style="text-align:left">限制最大负荷，求这个负荷的最小值</td><td style="text-align:left">设阈值为 <code>mid</code>，用贪心判断能否将所有组的数值都压在 <code>mid</code> 以下</td></tr><tr><td style="text-align:left"><strong>最大化最小值</strong></td><td style="text-align:left"><strong>求最大</strong></td><td style="text-align:left">保证每人至少分到 x，求 x 的最大值</td><td style="text-align:left">设下界为 <code>mid</code>，用贪心判断能否选出足够多的元素满足间距/大小 $\ge mid$</td></tr><tr><td style="text-align:left"><strong>第 K 小/大</strong></td><td style="text-align:left"><strong>求最小</strong>/最大</td><td style="text-align:left">乘法表第 K 小、第 K 小数对距离</td><td style="text-align:left">设答案为 <code>x</code>，计算 $\le x$ 的元素个数是否 $\ge k$</td></tr></tbody></table></div><hr><h3 id="4-代码模板（开区间）"><a href="#4-代码模板（开区间）" class="headerlink" title="4. 代码模板（开区间）"></a>4. 代码模板（开区间）</h3><p><strong>开区间二分法</strong>因其逻辑统一（“check更新谁，最后就返回谁”）被强烈推荐。</p><h4 id="4-1-求最小-Find-Minimum-Lower-Bound"><a href="#4-1-求最小-Find-Minimum-Lower-Bound" class="headerlink" title="4.1 求最小 (Find Minimum) / Lower Bound"></a>4.1 求最小 (Find Minimum) / Lower Bound</h4><p><strong>适用场景</strong>：</p><ul><li>求满足条件的<strong>最小值</strong>（如：完成任务的最少时间）。</li><li><strong>最小化最大值</strong>。</li><li><strong>第 K 小</strong>。</li><li>红蓝染色：<strong>左红（False）右蓝（True）</strong>，目标是寻找蓝色区域的起点。</li></ul><p><strong>核心口诀</strong>：<code>check(mid)</code> 成功时更新 <code>right</code>，最后返回 <code>right</code>。</p><h5 id="4-1-1-Java-代码"><a href="#4-1-1-Java-代码" class="headerlink" title="4.1.1 Java 代码"></a>4.1.1 Java 代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 模板：计算满足 check(x) == true 的最小整数 x</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1. 定义解空间范围 (根据题目具体要求设定)</span><br>        <span class="hljs-comment">// left 指向红色区域(不满足)，right 指向蓝色区域(满足)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length; <span class="hljs-comment">// 或者根据题目范围，如 max(nums) 等</span><br>        <br>        <span class="hljs-comment">// 2. 循环不变量：left + 1 &lt; right</span><br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <br>            <span class="hljs-comment">// 3. 核心判定</span><br>            <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>                right = mid; <span class="hljs-comment">// 满足条件，尝试更小的（收缩右边界）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid;  <span class="hljs-comment">// 不满足，需要更大的（收缩左边界）</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 4. 返回 right (最小的满足值)</span><br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-comment">// 具体的判断逻辑</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-1-2-C语言-代码"><a href="#4-1-2-C语言-代码" class="headerlink" title="4.1.2 C语言 代码"></a>4.1.2 C语言 代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-comment">// 具体的判断逻辑</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 模板：计算满足 check(x) == true 的最小整数 x</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMin</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-comment">// 1. 定义解空间 (开区间)</span><br>    <span class="hljs-comment">// left 始终不满足，right 始终满足</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = numsSize; <br>    <br>    <span class="hljs-comment">// 2. 循环不变量</span><br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>            right = mid; <span class="hljs-comment">// 满足条件，记录并在左侧继续找</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// 不满足，去右侧找</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 返回 right</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-2-求最大-Find-Maximum"><a href="#4-2-求最大-Find-Maximum" class="headerlink" title="4.2 求最大 (Find Maximum)"></a>4.2 求最大 (Find Maximum)</h4><p><strong>适用场景</strong>：</p><ul><li>求满足条件的<strong>最大值</strong>（如：最大化收益）。</li><li><strong>最大化最小值</strong>（如：磁力球最大距离）。</li><li>红蓝染色：<strong>左蓝（True）右红（False）</strong>，目标是寻找蓝色区域的终点。</li></ul><p><strong>核心口诀</strong>：<code>check(mid)</code> 成功时更新 <code>left</code>，最后返回 <code>left</code>。</p><h5 id="4-2-1-Java-代码"><a href="#4-2-1-Java-代码" class="headerlink" title="4.2.1 Java 代码"></a>4.2.1 Java 代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 模板：计算满足 check(x) == true 的最大整数 x</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1. 定义解空间 (根据题目范围设定)</span><br>        <span class="hljs-comment">// left 指向蓝色区域(满足)，right 指向红色区域(不满足)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length; <br>        <br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <br>            <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>                left = mid;  <span class="hljs-comment">// 满足条件，尝试更大的（收缩左边界）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid; <span class="hljs-comment">// 不满足，需要更小的（收缩右边界）</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 4. 返回 left (最大的满足值)</span><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-2-C语言-代码"><a href="#4-2-2-C语言-代码" class="headerlink" title="4.2.2 C语言 代码"></a>4.2.2 C语言 代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 模板：计算满足 check(x) == true 的最大整数 x</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMax</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-comment">// 1. 定义解空间</span><br>    <span class="hljs-comment">// left 始终满足，right 始终不满足</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = numsSize;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>            left = mid;  <span class="hljs-comment">// 满足条件，记录答案并在右侧继续找更大值</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid; <span class="hljs-comment">// 不满足，去左侧找</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 返回 left</span><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h4><p>根据资料推荐的<strong>开区间</strong>写法：</p><ul><li><strong>求最小</strong>：<code>right</code> 维护满足条件的值，<code>check</code> 成功更新 <code>right</code>，返回 <code>right</code>。</li><li><strong>求最大</strong>：<code>left</code> 维护满足条件的值，<code>check</code> 成功更新 <code>left</code>，返回 <code>left</code>。</li></ul><h3 id="5-最小化最大值-Minimize-the-Maximum"><a href="#5-最小化最大值-Minimize-the-Maximum" class="headerlink" title="5. 最小化最大值 (Minimize the Maximum)"></a>5. 最小化最大值 (Minimize the Maximum)</h3><p>这类问题通常描述为：“在满足某种分组或分配限制下，让某个最大指标（如最大负荷、最大距离、最大花费）尽可能小”。</p><ul><li><strong>本质归属</strong>：<strong>二分答案求最小</strong>（Find Minimum）。</li><li><strong>思维模型</strong>：<strong>“压盖子”</strong>。<ul><li>二分的 <code>mid</code> 是一个<strong>上界</strong>（Upper Bound）。</li><li>我们试图用这个盖子去“压”住所有元素，看能否在限制条件（如分组成 $k$ 份）下把所有数值都压在 <code>mid</code> 之下。</li></ul></li><li><strong>Check 函数逻辑</strong>：<ul><li>通常使用 <strong>贪心 + 模拟</strong>。</li><li>判断：<strong>“如果最大值不能超过 <code>mid</code>，我最少需要多少组/多少时间？”</strong></li><li>如果需要的组数 $\le k$，说明 <code>mid</code> 给的预算太宽裕或者刚好，尝试<strong>更小</strong>的（收缩右边界 <code>right = mid</code>）。</li><li>如果需要的组数 $&gt; k$，说明 <code>mid</code> 太严苛了，压不住，必须<strong>更大</strong>（收缩左边界 <code>left = mid</code>）。</li></ul></li><li><strong>典型题目</strong>：分割数组的最大值、完成任务的最少时间、爱吃香蕉的珂珂。</li><li><strong>代码行为 (开区间)</strong>：<ul><li><code>check(mid)</code> 成功（True）时更新 <code>right = mid</code>。</li><li>最终返回 <strong><code>right</code></strong>。</li></ul></li></ul><hr><h3 id="6-最大化最小值-Maximize-the-Minimum"><a href="#6-最大化最小值-Maximize-the-Minimum" class="headerlink" title="6. 最大化最小值 (Maximize the Minimum)"></a>6. 最大化最小值 (Maximize the Minimum)</h3><p>这类问题通常描述为：“在选取 $k$ 个元素或进行某种分配时，让其中最小的指标（如最小间距、最小得分）尽可能大”。</p><ul><li><strong>本质归属</strong>：<strong>二分答案求最大</strong>（Find Maximum）。</li><li><strong>思维模型</strong>：<strong>“抬地板”</strong>。<ul><li>二分的 <code>mid</code> 是一个<strong>下界</strong>（Lower Bound）。</li><li>我们试图把标准“抬”高，看能否找到足够多的元素/方案，使得它们都<strong>至少</strong>达到 <code>mid</code> 的水平。</li></ul></li><li><strong>Check 函数逻辑</strong>：<ul><li>通常使用 <strong>贪心</strong>。</li><li>判断：<strong>“如果要求所有选中的元素都 $\ge mid$，我最多能选出多少个？”</strong></li><li>如果选出的个数 $\ge k$，说明 <code>mid</code> 这个标准是可行的，尝试<strong>更大</strong>的（收缩左边界 <code>left = mid</code>）。</li><li>如果选出的个数 $&lt; k$，说明 <code>mid</code> 定太高了，凑不齐，必须<strong>更小</strong>（收缩右边界 <code>right = mid</code>）。</li></ul></li><li><strong>典型题目</strong>：两球之间的磁力、木头切割、H指数。</li><li><strong>代码行为 (开区间)</strong>：<ul><li><code>check(mid)</code> 成功（True）时更新 <code>left = mid</code>。</li><li>最终返回 <strong><code>left</code></strong>。</li></ul></li></ul><hr><h3 id="7-对比总结表"><a href="#7-对比总结表" class="headerlink" title="7. 对比总结表"></a>7. 对比总结表</h3><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left"><strong>最小化最大值</strong> (Min-Max)</th><th style="text-align:left"><strong>最大化最小值</strong> (Max-Min)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>问题类型</strong></td><td style="text-align:left"><strong>求最小</strong> (Find Minimum)</td><td style="text-align:left"><strong>求最大</strong> (Find Maximum)</td></tr><tr><td style="text-align:left"><strong>物理含义</strong></td><td style="text-align:left">限制上限，越小越好</td><td style="text-align:left">保证下限，越大越好</td></tr><tr><td style="text-align:left"><strong>Check方向</strong></td><td style="text-align:left">$\le mid$ 是否可行？</td><td style="text-align:left">$\ge mid$ 是否可行？</td></tr><tr><td style="text-align:left"><strong>更新逻辑</strong></td><td style="text-align:left">Check成功 $\to$ <code>right = mid</code> (试更小)</td><td style="text-align:left">Check成功 $\to$ <code>left = mid</code> (试更大)</td></tr><tr><td style="text-align:left"><strong>开区间返回</strong></td><td style="text-align:left"><strong><code>right</code></strong></td><td style="text-align:left"><strong><code>left</code></strong></td></tr><tr><td style="text-align:left"><strong>闭区间返回</strong></td><td style="text-align:left"><strong><code>left</code></strong></td><td style="text-align:left"><strong><code>right</code></strong></td></tr></tbody></table></div><h3 id="8-代码模板建议-开区间"><a href="#8-代码模板建议-开区间" class="headerlink" title="8. 代码模板建议 (开区间)"></a>8. 代码模板建议 (开区间)</h3><p>根据资料推荐，使用<strong>开区间</strong>写法可以避免复杂的边界判断。</p><p><strong>最小化最大值（求最小）：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心：Check成功更新 right，返回 right</span><br><span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (check(mid)) right = mid; <span class="hljs-comment">// 满足条件，试探更小的</span><br>    <span class="hljs-keyword">else</span> left = mid;<br>&#125;<br><span class="hljs-keyword">return</span> right;<br></code></pre></td></tr></table></figure></p><p><strong>最大化最小值（求最大）：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心：Check成功更新 left，返回 left</span><br><span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (check(mid)) left = mid;  <span class="hljs-comment">// 满足条件，试探更大的</span><br>    <span class="hljs-keyword">else</span> right = mid;<br>&#125;<br><span class="hljs-keyword">return</span> left;<br></code></pre></td></tr></table></figure></p><p><strong>记忆口诀</strong>：</p><ul><li>求最小（压盖子）：返回右边的 <code>right</code>。</li><li>求最大（抬地板）：返回左边的 <code>left</code>。</li></ul><h3 id="9-第-K-小-大"><a href="#9-第-K-小-大" class="headerlink" title="9. 第 K 小/大"></a>9. 第 K 小/大</h3><h4 id="9-1-核心转换逻辑"><a href="#9-1-核心转换逻辑" class="headerlink" title="9.1 核心转换逻辑"></a>9.1 核心转换逻辑</h4><h5 id="9-1-1-第-K-小-Kth-Smallest"><a href="#9-1-1-第-K-小-Kth-Smallest" class="headerlink" title="9.1.1 第 K 小 (Kth Smallest)"></a>9.1.1 第 K 小 (Kth Smallest)</h5><ul><li><strong>定义</strong>：在一个（可能虚拟的）有序序列中，第 K 小的数是 $x$。</li><li><strong>转化公式</strong>：等价于求 <strong>最小</strong> 的 $x$，满足 <strong>$\le x$ 的数至少有 $k$ 个</strong>。</li><li><strong>归属类型</strong>：<strong>求最小</strong>（Find Minimum）。</li><li><strong>单调性</strong>：$x$ 越大，$\le x$ 的数的个数越多（单调递增）。我们要找的是刚刚达到 $k$ 个的那个临界点。</li></ul><h5 id="9-1-2-第-K-大-Kth-Largest"><a href="#9-1-2-第-K-大-Kth-Largest" class="headerlink" title="9.1.2 第 K 大 (Kth Largest)"></a>9.1.2 第 K 大 (Kth Largest)</h5><ul><li><strong>定义</strong>：第 K 大的数是 $x$。</li><li><strong>转化公式</strong>：等价于求 <strong>最大</strong> 的 $x$，满足 <strong>$\ge x$ 的数至少有 $k$ 个</strong>。</li><li><strong>归属类型</strong>：<strong>求最大</strong>（Find Maximum）。</li><li><strong>实际技巧</strong>：虽然可以直接按“求最大”做，但工程和竞赛中常将其转换为 <strong>第 $N - K + 1$ 小</strong> 的问题，从而统一使用“求最小”的模板。</li></ul><hr><h4 id="9-2-代码模板（开区间写法）"><a href="#9-2-代码模板（开区间写法）" class="headerlink" title="9.2 代码模板（开区间写法）"></a>9.2 代码模板（开区间写法）</h4><h5 id="9-2-1-第-K-小模板（推荐）"><a href="#9-2-1-第-K-小模板（推荐）" class="headerlink" title="9.2.1 第 K 小模板（推荐）"></a>9.2.1 第 K 小模板（推荐）</h5><p>这是最常用的形式。例如：乘法表中第 K 小的数、第 K 小的数对距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标：求最小的 x，使得 count(&lt;= x) &gt;= k</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minVal, <span class="hljs-type">int</span> maxVal)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> minVal - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxVal + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// Check逻辑：计算 &lt;= mid 的元素个数是否达到了 k</span><br>        <span class="hljs-keyword">if</span> (countLessOrEqual(mid) &gt;= k) &#123;<br>            right = mid; <span class="hljs-comment">// 够了，甚至多了 -&gt; 尝试更小的（收缩右边界）</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// 不够 -&gt; 必须更大（收缩左边界）</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// Check成功更新的是 right，故返回 right</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9-2-2-第-K-大模板（直接法）"><a href="#9-2-2-第-K-大模板（直接法）" class="headerlink" title="9.2.2 第 K 大模板（直接法）"></a>9.2.2 第 K 大模板（直接法）</h5><p>如果不进行转换，直接求第 K 大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标：求最大的 x，使得 count(&gt;= x) &gt;= k</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minVal, <span class="hljs-type">int</span> maxVal)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> minVal - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxVal + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// Check逻辑：计算 &gt;= mid 的元素个数是否达到了 k</span><br>        <span class="hljs-keyword">if</span> (countGreaterOrEqual(mid) &gt;= k) &#123;<br>            left = mid;  <span class="hljs-comment">// 够了 -&gt; 尝试更大的（收缩左边界）</span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            right = mid; <span class="hljs-comment">// 不够 -&gt; 必须更小（收缩右边界）</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// Check成功更新的是 left，故返回 left</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h3><p><strong>“第 K 小”本质上是二分答案求最小</strong>。<br>只需记住：我们二分一个数值 <code>mid</code>，计算“小于等于 <code>mid</code> 的数有多少个”。</p><ul><li>如果个数 $\ge k$，说明 <code>mid</code> 可能是答案，甚至答案比 <code>mid</code> 还小（<strong>Right = mid</strong>）。</li><li>如果个数 $&lt; k$，说明 <code>mid</code> 太小了，不够排到第 $k$ 位（<strong>Left = mid</strong>）。</li><li>最后返回 <strong>Right</strong>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS</tag>
      
      <tag>算法</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java怎么实现Stirng不变的</title>
    <link href="/2026/01/03/Java%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81String%E4%B8%8D%E5%8F%98%E7%9A%84/"/>
    <url>/2026/01/03/Java%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81String%E4%B8%8D%E5%8F%98%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>这是一个<strong>问到 Java 设计“核心骨架”的问题</strong>。<br>我先给你一句<strong>结论级答案</strong>，然后我们像拆发动机一样，把每一层都拆开。</p><blockquote><p><strong><code>String</code> 的不可变性不是靠一句 <code>final</code>，<br>而是靠一整套“多层封锁 + JVM 协同”的设计体系共同保证的。</strong></p></blockquote><p>下面我们分 <strong>5 道防线</strong> 来看。</p><hr><h2 id="第一层防线：String-类本身是-final"><a href="#第一层防线：String-类本身是-final" class="headerlink" title="第一层防线：String 类本身是 final"></a>第一层防线：<code>String</code> 类本身是 <code>final</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="这意味着什么？"><a href="#这意味着什么？" class="headerlink" title="这意味着什么？"></a>这意味着什么？</h3><ul><li>❌ 不能被继承</li><li>❌ 不能通过子类添加“破坏性方法”</li><li>❌ 不能 override 任何行为</li></ul><h3 id="为什么这是第一道防线？"><a href="#为什么这是第一道防线？" class="headerlink" title="为什么这是第一道防线？"></a>为什么这是第一道防线？</h3><p>假如 <code>String</code> <strong>可以被继承</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilString</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 改内部 char[]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么：</p><ul><li>JVM</li><li>HashMap</li><li>ClassLoader</li><li>安全管理器</li></ul><p>都会被<strong>彻底破坏</strong></p><p>📌 <strong>第一层作用</strong>：<br>👉 <strong>防止通过继承破坏不可变性</strong></p><hr><h2 id="第二层防线：内部状态是-private-final"><a href="#第二层防线：内部状态是-private-final" class="headerlink" title="第二层防线：内部状态是 private final"></a>第二层防线：内部状态是 <code>private final</code></h2><h3 id="早期-JDK（≤8）："><a href="#早期-JDK（≤8）：" class="headerlink" title="早期 JDK（≤8）："></a>早期 JDK（≤8）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] value;<br></code></pre></td></tr></table></figure><h3 id="JDK-9-（压缩字符串）："><a href="#JDK-9-（压缩字符串）：" class="headerlink" title="JDK 9+（压缩字符串）："></a>JDK 9+（压缩字符串）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] value;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> coder; <span class="hljs-comment">// LATIN1 / UTF16</span><br></code></pre></td></tr></table></figure><h3 id="这两点非常关键："><a href="#这两点非常关键：" class="headerlink" title="这两点非常关键："></a>这两点非常关键：</h3><ol><li><p><strong><code>final</code></strong></p><ul><li>引用不能被替换</li></ul></li><li><p><strong><code>private</code></strong></p><ul><li>外界完全无法访问</li></ul></li></ol><p>📌 注意：<br><code>final</code> 只保证“引用不变”，<br><strong>真正防修改的是 <code>private</code> + 不暴露引用</strong>。</p><hr><h2 id="第三层防线：没有任何“修改自身”的方法"><a href="#第三层防线：没有任何“修改自身”的方法" class="headerlink" title="第三层防线：没有任何“修改自身”的方法"></a>第三层防线：没有任何“修改自身”的方法</h2><p>你仔细想一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="String-提供的方法是什么？"><a href="#String-提供的方法是什么？" class="headerlink" title="String 提供的方法是什么？"></a>String 提供的方法是什么？</h3><ul><li><code>substring</code></li><li><code>replace</code></li><li><code>toUpperCase</code></li><li><code>concat</code></li></ul><p><strong>它们全部：</strong></p><blockquote><p>❌ 不修改原对象<br>✅ 返回一个新 <code>String</code></p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">s.toUpperCase();<br></code></pre></td></tr></table></figure><p>实际等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(...);<br></code></pre></td></tr></table></figure><p>📌 <strong>这是不可变设计的“行为层保证”</strong>。</p><hr><h2 id="第四层防线：构造阶段的“防御性拷贝”"><a href="#第四层防线：构造阶段的“防御性拷贝”" class="headerlink" title="第四层防线：构造阶段的“防御性拷贝”"></a>第四层防线：构造阶段的“防御性拷贝”</h2><h3 id="你以为这样能破坏-String？"><a href="#你以为这样能破坏-String？" class="headerlink" title="你以为这样能破坏 String？"></a>你以为这样能破坏 String？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] arr = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr);<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;<br>System.out.println(s);<br></code></pre></td></tr></table></figure><h3 id="实际输出："><a href="#实际输出：" class="headerlink" title="实际输出："></a>实际输出：</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abc</span><br></code></pre></td></tr></table></figure><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>因为 <code>String</code> 构造器里做了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.value = Arrays.copyOf(arr, arr.length);<br></code></pre></td></tr></table></figure><p>📌 <strong>String 永远不信任外部传入的数据</strong></p><blockquote><p>这是“不可变类”的黄金法则之一。</p></blockquote><hr><h2 id="第五层防线（终极）：JVM-amp-语言层级的“特权协作”"><a href="#第五层防线（终极）：JVM-amp-语言层级的“特权协作”" class="headerlink" title="第五层防线（终极）：JVM &amp; 语言层级的“特权协作”"></a>第五层防线（终极）：JVM &amp; 语言层级的“特权协作”</h2><p>这是很多人<strong>不知道但最关键的一层</strong>。</p><hr><h3 id="1️⃣-字符串常量池（String-Pool）"><a href="#1️⃣-字符串常量池（String-Pool）" class="headerlink" title="1️⃣ 字符串常量池（String Pool）"></a>1️⃣ 字符串常量池（String Pool）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>a</code> 和 <code>b</code> 指向 <strong>同一个对象</strong></li><li><p>如果 String 可变：</p><ul><li>改一个，全世界跟着改</li></ul></li></ul><p>👉 所以 <strong>String 必须不可变</strong></p><hr><h3 id="2️⃣-hashCode-缓存"><a href="#2️⃣-hashCode-缓存" class="headerlink" title="2️⃣ hashCode 缓存"></a>2️⃣ <code>hashCode</code> 缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash;<br></code></pre></td></tr></table></figure><ul><li><code>hashCode()</code> 只算一次</li><li>之后直接缓存</li></ul><p>如果 String 可变：</p><ul><li>hash 失效</li><li>HashMap 直接崩溃</li></ul><hr><h3 id="3️⃣-ClassLoader-安全模型依赖-String"><a href="#3️⃣-ClassLoader-安全模型依赖-String" class="headerlink" title="3️⃣ ClassLoader / 安全模型依赖 String"></a>3️⃣ ClassLoader / 安全模型依赖 String</h3><ul><li>类名</li><li>方法名</li><li>权限名</li><li>文件路径</li></ul><p>📌 <strong>如果 String 可变，Java 的安全模型不成立</strong></p><hr><h2 id="一句话拆穿所有误解（非常重要）"><a href="#一句话拆穿所有误解（非常重要）" class="headerlink" title="一句话拆穿所有误解（非常重要）"></a>一句话拆穿所有误解（非常重要）</h2><blockquote><p><strong>String 的不可变性不是“防你”，<br>而是“防整个 Java 世界被你不小心炸掉”。</strong></p></blockquote><hr><h2 id="用一个“完整类比”帮你彻底定型"><a href="#用一个“完整类比”帮你彻底定型" class="headerlink" title="用一个“完整类比”帮你彻底定型"></a>用一个“完整类比”帮你彻底定型</h2><p>把 <code>String</code> 想成：</p><blockquote><p><strong>法律里的“身份证号码”</strong></p></blockquote><ul><li>不能改</li><li>可以复制</li><li>可以传递</li><li>可以比较</li><li>但绝不允许“修改原值”</li></ul><p>而：</p><ul><li><code>StringBuilder</code> = 草稿纸</li><li><code>char[]</code> = 可随意涂改的纸</li></ul><hr><h2 id="最容易被忽略的一点（高手标志）"><a href="#最容易被忽略的一点（高手标志）" class="headerlink" title="最容易被忽略的一点（高手标志）"></a>最容易被忽略的一点（高手标志）</h2><h3 id="为什么-String-的-value-数组不是暴露的？"><a href="#为什么-String-的-value-数组不是暴露的？" class="headerlink" title="为什么 String 的 value 数组不是暴露的？"></a>为什么 <code>String</code> 的 <code>value</code> 数组不是暴露的？</h3><p>如果有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] getValue();<br></code></pre></td></tr></table></figure><p>哪怕是 <code>final</code>，<strong>整个设计立刻崩塌</strong>。</p><p>📌 所以不可变性的真正核心是：</p><blockquote><p><strong>不暴露任何可变内部状态的引用</strong></p></blockquote><hr><h2 id="终极总结（请记住）"><a href="#终极总结（请记住）" class="headerlink" title="终极总结（请记住）"></a>终极总结（请记住）</h2><p><code>String</code> 的不可变性 =</p><ol><li>类是 <code>final</code></li><li>内部状态 <code>private final</code></li><li>不提供修改自身的方法</li><li>构造期防御性拷贝</li><li>JVM / 常量池 / hash / 安全模型共同依赖</li></ol><blockquote><p><strong>它是 Java 中“不可变设计”的教科书级范例。</strong></p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50X project0 Tic-Tac-Toe</title>
    <link href="/2026/01/01/CS50X%20project0%20TicTacToc/"/>
    <url>/2026/01/01/CS50X%20project0%20TicTacToc/</url>
    
    <content type="html"><![CDATA[<h1 id="项目-0-Tic-Tac-Toe-井字棋"><a href="#项目-0-Tic-Tac-Toe-井字棋" class="headerlink" title="项目 0: Tic-Tac-Toe (井字棋)"></a>项目 0: Tic-Tac-Toe (井字棋)</h1><p>使用 Minimax 算法实现一个能够以最优策略玩井字棋的 AI。</p><p><img src="https://cs50.harvard.edu/ai/projects/0/tictactoe/images/game.png" alt="Tic-Tac-Toe 游戏界面"></p><h2 id="截止时间"><a href="#截止时间" class="headerlink" title="[截止时间]"></a>[截止时间]</h2><p><a href="https://time.cs50.io/20260630T235900Z">2026 年 7 月 1 日，星期三，北京时间 07:59</a></p><h2 id="如何寻求帮助"><a href="#如何寻求帮助" class="headerlink" title="[如何寻求帮助]"></a>[如何寻求帮助]</h2><ol><li>通过 <a href="https://cs50.edx.org/ed">Ed</a> 平台提问。</li><li>在 CS50 的任何<a href="https://cs50.harvard.edu/ai/communities/">社区</a>中交流。</li></ol><hr><h2 id="入门指南"><a href="#入门指南" class="headerlink" title="[入门指南]"></a>[入门指南]</h2><ul><li>从 <a href="https://cdn.cs50.net/ai/2023/x/projects/0/tictactoe.zip">此处</a> 下载分发代码并解压。</li><li>进入项目目录后，运行以下命令安装所需的 Python 库（<code>pygame</code>）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install -r requirements.txt<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="项目理解"><a href="#项目理解" class="headerlink" title="[项目理解]"></a>[项目理解]</h2><p>该项目有两个主要文件：<code>runner.py</code> 和 <code>tictactoe.py</code>。</p><ul><li><code>runner.py</code>：已由课程方实现，包含运行图形化界面所需的所有代码。</li><li><code>tictactoe.py</code>：包含游戏的所有逻辑以及 AI 做出最优决策的逻辑。完成该文件中的所有函数后，运行 <code>python runner.py</code> 即可与你的 AI 对弈。</li></ul><h3 id="初始数据"><a href="#初始数据" class="headerlink" title="初始数据"></a>初始数据</h3><p>在 <code>tictactoe.py</code> 中，我们定义了三个变量：<code>X</code>、<code>O</code> 和 <code>EMPTY</code> 来表示棋盘上的状态。棋盘被表示为一个包含三个列表的列表（即 3x3 矩阵）。</p><hr><h2 id="任务要求-Specification"><a href="#任务要求-Specification" class="headerlink" title="[任务要求 (Specification)]"></a>[任务要求 (Specification)]</h2><p>你需要完成 <code>player</code>、<code>actions</code>、<code>result</code> <code>winner</code>、<code>terminal</code>、<code>utility</code> 和 <code>minimax</code> 函数的实现。</p><ul><li><strong><code>player(board)</code></strong>：返回当前轮到哪位玩家（<code>X</code> 或 <code>O</code>）。<ul><li>初始状态下由 <code>X</code> 先手。</li></ul></li><li><strong><code>actions(board)</code></strong>：返回当前棋盘上所有可能的动作。<ul><li>动作应表示为元组 <code>(i, j)</code>，其中 <code>i</code> 是行，<code>j</code> 是列（范围均在 0-2 之间）。</li></ul></li><li><strong><code>result(board, action)</code></strong>：返回一个新棋盘状态，而不修改原棋盘。<ul><li>如果动作无效，应 <a href="https://docs.python.org/3/tutorial/errors.html#raising-exceptions">抛出异常</a>。</li><li><strong>重要</strong>：Minimax 需要考虑许多不同的状态，因此必须在不改变原始数据的情况下生成新棋盘。建议使用 <code>copy.deepcopy()</code>。</li></ul></li><li><strong><code>winner(board)</code></strong>：如果有赢家，返回 <code>X</code> 或 <code>O</code>；否则返回 <code>None</code>。<ul><li>获胜条件：在水平、垂直或对角线上连成三子。</li></ul></li><li><strong><code>terminal(board)</code></strong>：返回布尔值，判断游戏是否结束（有人获胜或棋盘填满）。</li><li><strong><code>utility(board)</code></strong>：返回终端棋盘的效用值。<ul><li><code>X</code> 获胜返回 <code>1</code>；<code>O</code> 获胜返回 <code>-1</code>；平局返回 <code>0</code>。</li></ul></li><li><strong><code>minimax(board)</code></strong>：返回当前玩家的最优动作 <code>(i, j)</code>。<ul><li>如果棋盘已结束，返回 <code>None</code>。</li></ul></li></ul><hr><h2 id="提示-Hints"><a href="#提示-Hints" class="headerlink" title="[提示 (Hints)]"></a>[提示 (Hints)]</h2><ul><li>如果你想在不同的文件中测试函数，可以使用 <code>from tictactoe import initial_state</code>。</li><li>你可以添加辅助函数，只要不与现有变量名冲突。</li><li><strong>Alpha-beta 剪枝</strong>（Alpha-beta pruning）是可选的，但它会让你的 AI 运行效率大幅提高！</li></ul><hr><h2 id="测试与提交"><a href="#测试与提交" class="headerlink" title="[测试与提交]"></a>[测试与提交]</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>使用 <code>check50</code> 检查正确性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">check50 ai50/projects/2024/x/tictactoe<br></code></pre></td></tr></table></figure></p><p>使用 <code>style50</code> 检查代码风格。</p><h3 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h3><ol><li>在 <a href="https://submit.cs50.io/invites/d03c31aef1984c29b5e7b268c3a87b7b">submit.cs50.io</a> 授权并加入课程。</li><li>使用 <code>submit50</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">submit50 ai50/projects/2024/x/tictactoe<br></code></pre></td></tr></table></figure></li></ol><hr><p><strong>注意</strong>：由于井字棋在双方均采取最优策略时必然会平局，因此当你完成代码后，你应该<strong>永远无法战胜</strong>你的 AI（但如果你失误了，它会打败你）。</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><strong>状态表示与追踪</strong>：<ul><li>利用 <code>player</code> 函数动态计算棋盘上 <code>X</code> 和 <code>O</code> 的数量差，从而确定当前回合。由于 X 先手且每次只能下一子，只需判断 <code>count(X) == count(O)</code> 即可确定轮到 X。</li></ul></li><li><strong>对抗搜索 (Minimax)</strong>：<ul><li><strong>递归回溯</strong>：通过 <code>max_value</code> 和 <code>min_value</code> 互相调用，模拟出所有可能的对弈分支。</li><li><strong>效用分配</strong>：游戏结束时，胜利、失败和平局分别被量化为 <code>1</code>, <code>-1</code>, <code>0</code>。X 作为 Max 玩家追求分值最大化，O 作为 Min 玩家追求分值最小化。</li></ul></li><li><strong>性能优化 (Alpha-Beta Pruning)</strong>：<ul><li>引入 <code>alpha</code>（Max 玩家保证能得到的最小值）和 <code>beta</code>（Min 玩家保证能允许的最大值）。</li><li>当 <code>v &gt;= beta</code> 或 <code>v &lt;= alpha</code> 时即刻停止搜索该分支，因为理性的对手绝不会允许局面进入这些分支，从而大幅减少计算量。</li></ul></li></ul><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Tic Tac Toe Player</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> math<br><br>X = <span class="hljs-string">&quot;X&quot;</span><br>O = <span class="hljs-string">&quot;O&quot;</span><br>EMPTY = <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">initial_state</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns starting state of the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> [[EMPTY, EMPTY, EMPTY],<br>            [EMPTY, EMPTY, EMPTY],<br>            [EMPTY, EMPTY, EMPTY]]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">player</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns player who has the next turn on a board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 计算当前棋盘上 X 和 O 的数量，决定下一位行动的玩家。</span><br>    <span class="hljs-comment"># 规则：若 X 和 O 的数量相等，则 X 先行；否则为 O。</span><br>    x_count = <span class="hljs-number">0</span><br>    o_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> board:<br>        <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row:<br>            <span class="hljs-keyword">if</span> cell == X:<br>                x_count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> cell == O:<br>                o_count += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 若 X 的数量不多于 O，说明轮到 X；否则轮到 O</span><br>    <span class="hljs-keyword">if</span> x_count &lt;= o_count:<br>        <span class="hljs-keyword">return</span> X<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> O<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">actions</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns set of all possible actions (i, j) available on the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 返回一个包含所有空位置的集合，集合元素为 (行, 列) 二元组。</span><br>    possible = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>            <span class="hljs-keyword">if</span> board[i][j] == EMPTY:<br>                possible.add((i, j))<br>    <span class="hljs-keyword">return</span> possible<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">result</span>(<span class="hljs-params">board, action</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the board that results from making move (i, j) on the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 返回一个新的棋盘（不修改原 board），表示在 action 位置下当前玩家的一步。</span><br>    <span class="hljs-comment"># 验证 action 格式并检查目标格是否为空。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-built_in">isinstance</span>(action, <span class="hljs-built_in">tuple</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(action) == <span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Action must be a tuple (i, j)&quot;</span>)<br><br>    i, j = action<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span> &lt;= i &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= j &lt; <span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Action indices out of bounds&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> board[i][j] != EMPTY:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Action must be on an empty cell&quot;</span>)<br><br>    <span class="hljs-comment"># 深拷贝棋盘以避免修改原对象</span><br>    new_board = [row.copy() <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> board]<br><br>    <span class="hljs-comment"># 将当前玩家的符号放到指定位置</span><br>    new_board[i][j] = player(board)<br>    <span class="hljs-keyword">return</span> new_board<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">winner</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the winner of the game, if there is one.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 检查行三连</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">if</span> board[i][<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[i][<span class="hljs-number">0</span>] == board[i][<span class="hljs-number">1</span>] == board[i][<span class="hljs-number">2</span>]:<br>            <span class="hljs-keyword">return</span> board[i][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 检查列三连</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][j] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[<span class="hljs-number">0</span>][j] == board[<span class="hljs-number">1</span>][j] == board[<span class="hljs-number">2</span>][j]:<br>            <span class="hljs-keyword">return</span> board[<span class="hljs-number">0</span>][j]<br><br>    <span class="hljs-comment"># 检查主对角线</span><br>    <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]:<br>        <span class="hljs-keyword">return</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 检查副对角线</span><br>    <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] == board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == board[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]:<br>        <span class="hljs-keyword">return</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]<br><br>    <span class="hljs-comment"># 若无胜者则返回 None</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">terminal</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns True if game is over, False otherwise.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 游戏结束的两种情况：存在胜者，或棋盘已满（无 EMPTY）。</span><br>    <span class="hljs-keyword">if</span> winner(board) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-comment"># 检查是否还有空位</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> board:<br>        <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row:<br>            <span class="hljs-keyword">if</span> cell == EMPTY:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 无空位且无胜者 -&gt; 平局，也视为游戏结束</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">utility</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns 1 if X has won the game, -1 if O has won, 0 otherwise.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用 winner() 判断胜者并返回对应效用值</span><br>    win = winner(board)<br>    <span class="hljs-keyword">if</span> win == X:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> win == O:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minimax</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the optimal action for the current player on the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 若棋局已结束，无可用动作，返回 None</span><br>    <span class="hljs-keyword">if</span> terminal(board):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 使用 Alpha-Beta 剪枝的递归实现。alpha 表示当前已知的最大下界，beta 表示最小上界。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">max_value</span>(<span class="hljs-params">state, alpha, beta</span>):<br>        <span class="hljs-keyword">if</span> terminal(state):<br>            <span class="hljs-keyword">return</span> utility(state)<br>        v = -math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(state):<br>            v = <span class="hljs-built_in">max</span>(v, min_value(result(state, action), alpha, beta))<br>            <span class="hljs-comment"># 如果当前值已经不小于 beta，后续分支不会被选中，剪枝</span><br>            <span class="hljs-keyword">if</span> v &gt;= beta:<br>                <span class="hljs-keyword">return</span> v<br>            alpha = <span class="hljs-built_in">max</span>(alpha, v)<br>        <span class="hljs-keyword">return</span> v<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">min_value</span>(<span class="hljs-params">state, alpha, beta</span>):<br>        <span class="hljs-keyword">if</span> terminal(state):<br>            <span class="hljs-keyword">return</span> utility(state)<br>        v = math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(state):<br>            v = <span class="hljs-built_in">min</span>(v, max_value(result(state, action), alpha, beta))<br>            <span class="hljs-comment"># 如果当前值已经不大于 alpha，后续分支不会被选中，剪枝</span><br>            <span class="hljs-keyword">if</span> v &lt;= alpha:<br>                <span class="hljs-keyword">return</span> v<br>            beta = <span class="hljs-built_in">min</span>(beta, v)<br>        <span class="hljs-keyword">return</span> v<br><br>    current = player(board)<br>    best_action = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 根节点初始化 alpha/beta</span><br>    alpha = -math.inf<br>    beta = math.inf<br><br>    <span class="hljs-keyword">if</span> current == X:<br>        best_val = -math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(board):<br>            value = min_value(result(board, action), alpha, beta)<br>            <span class="hljs-keyword">if</span> value &gt; best_val:<br>                best_val = value<br>                best_action = action<br>            alpha = <span class="hljs-built_in">max</span>(alpha, best_val)<br>            <span class="hljs-comment"># 找到必胜走法可提前结束</span><br>            <span class="hljs-keyword">if</span> best_val == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        best_val = math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(board):<br>            value = max_value(result(board, action), alpha, beta)<br>            <span class="hljs-keyword">if</span> value &lt; best_val:<br>                best_val = value<br>                best_action = action<br>            beta = <span class="hljs-built_in">min</span>(beta, best_val)<br>            <span class="hljs-keyword">if</span> best_val == -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">return</span> best_action<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50X</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50X project0 Degrees</title>
    <link href="/2026/01/01/CS50X%20project0%20Degrees/"/>
    <url>/2026/01/01/CS50X%20project0%20Degrees/</url>
    
    <content type="html"><![CDATA[<h1 id="项目-0-Degrees-六度分隔"><a href="#项目-0-Degrees-六度分隔" class="headerlink" title="项目 0: Degrees (六度分隔)"></a>项目 0: Degrees (六度分隔)</h1><p>编写一个程序，通过选择连接演员的电影序列，确定两个演员之间有多少“层”关系（即六度分隔理论）。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">$ python degrees.py large<br>Loading data...<br>Data loaded.<br><span class="hljs-section">Name: Emma Watson</span><br><span class="hljs-section">Name: Jennifer Lawrence</span><br>3 degrees of separation.<br><span class="hljs-section">1: Emma Watson and Brendan Gleeson starred in Harry Potter and the Order of the Phoenix</span><br><span class="hljs-section">2: Brendan Gleeson and Michael Fassbender starred in Trespass Against Us</span><br><span class="hljs-section">3: Michael Fassbender and Jennifer Lawrence starred in X-Men: First Class</span><br></code></pre></td></tr></table></figure><h2 id="截止时间"><a href="#截止时间" class="headerlink" title="[截止时间]"></a>[截止时间]</h2><p><a href="https://time.cs50.io/20260630T235900Z">2026 年 7 月 1 日，星期三，北京时间 07:59</a></p><h2 id="如何寻求帮助"><a href="#如何寻求帮助" class="headerlink" title="[如何寻求帮助]"></a>[如何寻求帮助]</h2><ol><li>通过 <a href="https://cs50.edx.org/ed">Ed</a> 平台提问。</li><li>在 CS50 的任何<a href="https://cs50.harvard.edu/ai/communities/">社区</a>中交流。</li></ol><hr><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="[背景介绍]"></a>[背景介绍]</h2><p>根据“<a href="https://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon">凯文·贝肯的六度分隔</a>”游戏，好莱坞电影业中的任何人都可以通过最多六个步骤连接到凯文·贝肯，其中每一步都由两位演员共同出演的一部电影组成。</p><p>在这个问题中，我们的目标是找到任意两个演员之间的<strong>最短路径</strong>。</p><p>通过使用<strong>广度优先搜索 (BFS)</strong>，我们可以找到从一个演员到另一个演员的最短路径：</p><ul><li><strong>状态 (States)</strong>：人（演员）。</li><li><strong>动作 (Actions)</strong>：电影（将我们从一个演员带到另一个演员）。</li><li><strong>初始状态与目标状态</strong>：我们要连接的两位演员。</li></ul><hr><h2 id="入门指南"><a href="#入门指南" class="headerlink" title="[入门指南]"></a>[入门指南]</h2><ul><li>从 <a href="https://cdn.cs50.net/ai/2023/x/projects/0/degrees.zip">此处</a> 下载分发代码并解压。</li></ul><hr><h2 id="理解代码"><a href="#理解代码" class="headerlink" title="[理解代码]"></a>[理解代码]</h2><p>分发代码包含两组 CSV 数据文件：<code>large</code>（大型）和 <code>small</code>（小型）。</p><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><ul><li><code>people.csv</code>：包含 <code>id</code>、<code>name</code> 和 <code>birth</code>（出生年份）。</li><li><code>movies.csv</code>：包含 <code>id</code>、<code>title</code> 和 <code>year</code>。</li><li><code>stars.csv</code>：关联演员和电影（<code>person_id</code> 与 <code>movie_id</code> 的对应关系）。</li></ul><h3 id="degrees-py"><a href="#degrees-py" class="headerlink" title="degrees.py"></a><code>degrees.py</code></h3><ul><li><code>names</code> 字典：将姓名映射到 <code>id</code> 集合（处理重名）。</li><li><code>people</code> 字典：映射 <code>id</code> 到演员详细信息。</li><li><code>movies</code> 字典：映射 <code>id</code> 到电影详细信息。</li><li><code>main</code> 函数：加载数据并调用 <code>shortest_path</code>。</li></ul><hr><h2 id="任务要求-Specification"><a href="#任务要求-Specification" class="headerlink" title="[任务要求 (Specification)]"></a>[任务要求 (Specification)]</h2><p>你需要实现 <code>shortest_path</code> 函数，使其返回从 <code>source</code> ID 到 <code>target</code> ID 的最短路径。</p><ul><li><strong>返回值</strong>：函数应返回一个列表，其中每个元素是一个 <code>(movie_id, person_id)</code> 元组。<ul><li>例如：<code>[(1, 2), (3, 4)]</code> 表示源演员通过电影 1 与演员 2 合作，演员 2 通过电影 3 与目标演员 4 合作。</li></ul></li><li><strong>多路径</strong>：如果存在多个等长的最短路径，返回其中任何一个即可。</li><li><strong>无路径</strong>：如果两人之间不连通，返回 <code>None</code>。</li><li><strong>辅助函数</strong>：你可以调用 <code>neighbors_for_person(person_id)</code>，它返回与该演员合作过的所有 <code>(movie_id, person_id)</code> 对。</li></ul><hr><h2 id="提示-Hints"><a href="#提示-Hints" class="headerlink" title="[提示 (Hints)]"></a>[提示 (Hints)]</h2><ul><li><strong>性能优化</strong>：在标准搜索中，算法在节点弹出边缘（Frontier）时检查目标。为了提高效率，你可以在<strong>节点加入边缘时</strong>就检查是否到达目标。</li><li><strong>借鉴代码</strong>：参考并修改课堂示例。<code>util.py</code> 中提供了 <code>Node</code>、<code>StackFrontier</code> 和 <code>QueueFrontier</code> 的实现。</li></ul><hr><h2 id="测试与提交"><a href="#测试与提交" class="headerlink" title="[测试与提交]"></a>[测试与提交]</h2><p>使用 <code>check50</code> 检查正确性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">check50 ai50/projects/2024/x/degrees<br></code></pre></td></tr></table></figure></p><h3 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h3><ol><li>在 <a href="https://submit.cs50.io/invites/d03c31aef1984c29b5e7b268c3a87b7b">submit.cs50.io</a> 授权并加入课程。</li><li>使用 <code>submit50</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">submit50 ai50/projects/2024/x/degrees<br></code></pre></td></tr></table></figure></li></ol><hr><p><strong>数据来源</strong>：信息由 <a href="https://www.imdb.com/">IMDb</a> 提供，经许可使用。</p><h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><p>用队列使用BFS，第一次遇到target时，返回路径。</p><blockquote><p>值得注意的是，Node使用的parent记录上一个结点的值，和一般的图的BFS使用一个path数组边走边记录路径不同。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">shortest_path</span>(<span class="hljs-params">source, target</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the shortest list of (movie_id, person_id) pairs</span><br><span class="hljs-string">    that connect the source to the target.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    If no possible path, returns None.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 使用广度优先搜索（BFS）和 QueueFrontier，保证按边数返回最短路径。</span><br><br>    <span class="hljs-comment"># 特殊情况：起点等于终点，返回空路径（没有边）。</span><br>    <span class="hljs-keyword">if</span> source == target:<br>        <span class="hljs-keyword">return</span> []<br><br>    <span class="hljs-comment"># 初始化 frontier，将起始节点加入队列</span><br>    start = Node(state=source, parent=<span class="hljs-literal">None</span>, action=<span class="hljs-literal">None</span>)<br>    frontier = QueueFrontier()<br>    frontier.add(start)<br><br>    <span class="hljs-comment"># explored 用于记录已访问的 person_id，避免重复扩展</span><br>    explored = <span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-comment"># 主循环：直到 frontier 为空</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> frontier.empty():<br>        node = frontier.remove()<br><br>        <span class="hljs-comment"># 如果当前节点是目标节点，则回溯构造路径并返回</span><br>        <span class="hljs-keyword">if</span> node.state == target:<br>            path = []<br>            <span class="hljs-comment"># 从目标回溯到起点，收集 (movie_id, person_id)</span><br>            <span class="hljs-keyword">while</span> node.parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                path.append((node.action, node.state))<br>                node = node.parent<br>            path.reverse()<br>            <span class="hljs-keyword">return</span> path<br><br>        <span class="hljs-comment"># 标记当前节点为已探索</span><br>        explored.add(node.state)<br><br>        <span class="hljs-comment"># 展开邻居：neighbors_for_person 返回 (movie_id, person_id)</span><br>        <span class="hljs-keyword">for</span> movie_id, person_id <span class="hljs-keyword">in</span> neighbors_for_person(node.state):<br>            <span class="hljs-comment"># 如果该人未被探索且不在 frontier 中，则创建子节点并加入 frontier</span><br>            <span class="hljs-keyword">if</span> person_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> explored <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> frontier.contains_state(person_id):<br>                child = Node(state=person_id, parent=node, action=movie_id)<br>                frontier.add(child)<br><br>    <span class="hljs-comment"># 遍历完仍未找到路径，返回 None 表示不连通</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50X</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WLS2网络配置</title>
    <link href="/2025/12/31/WLS2%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/12/31/WLS2%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="WSL2-网络代理一键配置指南"><a href="#WSL2-网络代理一键配置指南" class="headerlink" title="WSL2 网络代理一键配置指南"></a>WSL2 网络代理一键配置指南</h1><h2 id="1-背景与原理"><a href="#1-背景与原理" class="headerlink" title="1. 背景与原理"></a>1. 背景与原理</h2><p>WSL2 运行在 Hyper-V 虚拟机中，拥有独立的 IP 地址。因此，WSL2 不能直接通过 <code>127.0.0.1</code> 访问宿主机（Windows）上的代理软件。本配置通过自动抓取宿主机虚拟网卡 IP，实现代理的一键开关。</p><h2 id="2-前置准备"><a href="#2-前置准备" class="headerlink" title="2. 前置准备"></a>2. 前置准备</h2><p>在开始配置前，请确保 Windows 端的代理软件已完成以下设置：</p><ol><li><strong>允许局域网连接 (Allow LAN)</strong>：必须勾选，否则 Windows 会拒绝来自 WSL2 的连接。</li><li><strong>确认端口</strong>：确认你的代理软件监听端口（如 <code>10808</code> 或 <code>7890</code>）。</li></ol><hr><h2 id="3-配置步骤"><a href="#3-配置步骤" class="headerlink" title="3. 配置步骤"></a>3. 配置步骤</h2><h3 id="A-修改-Bash-配置文件"><a href="#A-修改-Bash-配置文件" class="headerlink" title="A. 修改 Bash 配置文件"></a>A. 修改 Bash 配置文件</h3><p>在 WSL 终端中运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano ~/.bashrc<br></code></pre></td></tr></table></figure></p><h3 id="B-写入配置脚本"><a href="#B-写入配置脚本" class="headerlink" title="B. 写入配置脚本"></a>B. 写入配置脚本</h3><p>将以下代码粘贴到文件末尾。注意将 <code>10808</code> 修改为你实际的代理端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ---------- WSL2 Proxy Helper ----------</span><br><span class="hljs-comment"># 建议端口与 Windows 代理软件保持一致</span><br><span class="hljs-built_in">export</span> PROXY_PORT=<span class="hljs-string">&quot;10808&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">proxy_on</span></span>() &#123;<br>    <span class="hljs-comment"># 1. 自动获取宿主机 IP (resolv.conf 中的 nameserver)</span><br>    <span class="hljs-built_in">export</span> host_ip=$(grep -m 1 nameserver /etc/resolv.conf | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 2. 设置环境变量 (HTTP/HTTPS/SOCKS5)</span><br>    <span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    <span class="hljs-built_in">export</span> ALL_PROXY=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    <br>    <span class="hljs-comment"># 3. 同步配置 Git 代理</span><br>    git config --global http.proxy <span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    git config --global https.proxy <span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br><br>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32m[√] Proxy Enabled\033[0m&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Host IP: <span class="hljs-variable">$&#123;host_ip&#125;</span>&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Port: <span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">proxy_off</span></span>() &#123;<br>    <span class="hljs-comment"># 1. 取消环境变量</span><br>    <span class="hljs-built_in">unset</span> http_proxy<br>    <span class="hljs-built_in">unset</span> https_proxy<br>    <span class="hljs-built_in">unset</span> ALL_PROXY<br>    <br>    <span class="hljs-comment"># 2. 取消 Git 代理</span><br>    git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>    git config --global --<span class="hljs-built_in">unset</span> https.proxy<br><br>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31m[×] Proxy Disabled\033[0m&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">proxy_test</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Testing connection to Google...&quot;</span><br>    curl -I https://www.google.com<br>&#125;<br><span class="hljs-comment"># --------------------------------------</span><br></code></pre></td></tr></table></figure><h3 id="C-使配置生效"><a href="#C-使配置生效" class="headerlink" title="C. 使配置生效"></a>C. 使配置生效</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><hr><h2 id="4-使用指南"><a href="#4-使用指南" class="headerlink" title="4. 使用指南"></a>4. 使用指南</h2><ul><li><strong>开启代理</strong>：输入 <code>proxy_on</code>。适用于 <code>apt update</code>、<code>git clone</code>、<code>pip install</code> 等。</li><li><strong>关闭代理</strong>：输入 <code>proxy_off</code>。</li><li><strong>检查状态</strong>：输入 <code>proxy_test</code>。</li></ul><hr><h2 id="5-常见问题排查"><a href="#5-常见问题排查" class="headerlink" title="5. 常见问题排查"></a>5. 常见问题排查</h2><h3 id="Q-proxy-on-后依然连接超时-Timeout-？"><a href="#Q-proxy-on-后依然连接超时-Timeout-？" class="headerlink" title="Q: proxy_on 后依然连接超时 (Timeout)？"></a>Q: proxy_on 后依然连接超时 (Timeout)？</h3><ol><li><strong>检查 Windows 防火墙</strong>：以管理员身份在 Windows PowerShell 运行以下命令，允许来自 WSL 的流量：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">New-NetFirewallRule</span> <span class="hljs-literal">-DisplayName</span> <span class="hljs-string">&quot;WSL&quot;</span> <span class="hljs-literal">-Direction</span> Inbound <span class="hljs-literal">-InterfaceAlias</span> <span class="hljs-string">&quot;vEthernet (WSL)&quot;</span> <span class="hljs-literal">-Action</span> Allow<br></code></pre></td></tr></table></figure></li><li><strong>检查代理软件</strong>：确保开启了 “Allow LAN”。</li></ol><h3 id="Q-为什么-ping-google-com-不通？"><a href="#Q-为什么-ping-google-com-不通？" class="headerlink" title="Q: 为什么 ping google.com 不通？"></a>Q: 为什么 ping google.com 不通？</h3><p><code>ping</code> 使用的是 <strong>ICMP 协议</strong>，而大多数应用层代理只转发 <strong>TCP/UDP</strong>。请以 <code>curl -I https://www.google.com</code> 的结果为准。</p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WLS2</tag>
      
      <tag>CS50，网络配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WLS2和Python配置</title>
    <link href="/2025/12/31/WSL2%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/12/31/WSL2%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>CS50中check作业和提交作业的check50和submit50需要在Linux环境下运行，因此配置下WLS。</p><h2 id="1-WSL2-架构与磁盘管理"><a href="#1-WSL2-架构与磁盘管理" class="headerlink" title="1. WSL2 架构与磁盘管理"></a>1. WSL2 架构与磁盘管理</h2><h3 id="1-1-核心安装与升级"><a href="#1-1-核心安装与升级" class="headerlink" title="1.1 核心安装与升级"></a>1.1 核心安装与升级</h3><ul><li><strong>一键安装</strong>：<code>wsl --install</code>（默认安装 Ubuntu）。</li><li><strong>查看版本</strong>：<code>wsl -l -v</code>。确保版本号显示为 <code>2</code>。</li></ul><h3 id="1-2-F-盘迁移与权限“避坑”指南"><a href="#1-2-F-盘迁移与权限“避坑”指南" class="headerlink" title="1.2 F 盘迁移与权限“避坑”指南"></a>1.2 F 盘迁移与权限“避坑”指南</h3><p>为了保护 C 盘空间，我们将 Ubuntu 移动到了 <code>F:\WSL\Ubuntu</code>。</p><ul><li><strong>错误复现</strong>：报错 <code>E_ACCESSDENIED</code> (拒绝访问)。</li><li><strong>深度排查</strong>：WSL2 的 <code>.vhdx</code> 虚拟磁盘文件本质上是一个实时挂载的磁盘。</li><li><strong>解决方案</strong>：<br>由于你将系统文件放在了非系统盘，有时权限没有正确继承，导致 WSL 服务（以特定系统账户运行）无法读取。</li></ul><ol><li><p>右键点击 <code>F:\WSL</code>（或 <code>Ubuntu</code> 文件夹），选择 <strong>属性</strong>。</p></li><li><p>切换到 <strong>安全</strong> 选项卡。</p></li><li><p>点击 <strong>编辑</strong> -&gt; <strong>添加</strong>。</p></li><li><p>在对象名称框中输入 <code>Everyone</code>（或者你的电脑用户名），点击确定。</p></li><li><p>在权限列表中，勾选 <strong>完全控制</strong>。</p></li><li><p>点击确定应用。</p></li></ol><hr><h2 id="2-Linux-系统配置与优化"><a href="#2-Linux-系统配置与优化" class="headerlink" title="2. Linux 系统配置与优化"></a>2. Linux 系统配置与优化</h2><h3 id="2-1-软件源刷新-解决“找不到包”报错"><a href="#2-1-软件源刷新-解决“找不到包”报错" class="headerlink" title="2.1 软件源刷新 (解决“找不到包”报错)"></a>2.1 软件源刷新 (解决“找不到包”报错)</h3><ul><li><strong>现象</strong>：执行 <code>sudo apt install python3-venv</code> 提示 <code>no installation candidate</code>。</li><li><strong>原理</strong>：Ubuntu 刚装好时，本地的软件包索引是空的，它不知道去哪里下载。</li><li><strong>操作</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br></code></pre></td></tr></table></figure>  <em>这步操作会从服务器拉取最新的软件清单。</em></li></ul><h3 id="2-2-彻底静音处理"><a href="#2-2-彻底静音处理" class="headerlink" title="2.2 彻底静音处理"></a>2.2 彻底静音处理</h3><ul><li><strong>痛点</strong>：按 Tab 或 Backspace 时，系统发出刺耳的蜂鸣音。<h3 id="3-关闭-Windows-Terminal-的全局提示音"><a href="#3-关闭-Windows-Terminal-的全局提示音" class="headerlink" title="3. 关闭 Windows Terminal 的全局提示音"></a>3. 关闭 Windows Terminal 的全局提示音</h3></li></ul><p>如果你使用的是 <strong>Windows Terminal</strong>（就是你截图里那个带有标签页的黑色窗口），它本身也有一个设置：</p><ol><li><p>点击窗口顶部的 <strong>向下小箭头</strong>，选择 <strong>设置 (Settings)</strong>。</p></li><li><p>在左侧菜单点击 <strong>默认值 (Defaults)</strong>。</p></li><li><p>在右侧找到 <strong>高级 (Advanced)</strong>。</p></li><li><p>找到 <strong>钟声通知样式 (Bell notification style)</strong>，将其设置为 <strong>无 (None)</strong>。</p></li><li><p>点击右下角的 <strong>保存</strong>。</p></li></ol><hr><h2 id="3-Python-虚拟环境-Virtual-Environment-深度实战"><a href="#3-Python-虚拟环境-Virtual-Environment-深度实战" class="headerlink" title="3. Python 虚拟环境 (Virtual Environment) 深度实战"></a>3. Python 虚拟环境 (Virtual Environment) 深度实战</h2><p>对于 CS50 AI 的 <code>degrees</code> 项目，必须使用 <code>venv</code> 来隔离环境。</p><h3 id="3-1-环境安装"><a href="#3-1-环境安装" class="headerlink" title="3.1 环境安装"></a>3.1 环境安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 安装 pip 包管理器和 venv 模块</span><br><span class="hljs-built_in">sudo</span> apt install python3-pip python3-venv -y<br></code></pre></td></tr></table></figure><h3 id="3-2-虚拟环境“三部曲”"><a href="#3-2-虚拟环境“三部曲”" class="headerlink" title="3.2 虚拟环境“三部曲”"></a>3.2 虚拟环境“三部曲”</h3><ol><li><strong>创建环境</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在项目目录下创建一个名为 venv 的“小房间”</span><br>python3 -m venv venv<br></code></pre></td></tr></table></figure></li><li><strong>激活环境</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这一步会修改当前终端的 PATH 变量</span><br><span class="hljs-built_in">source</span> venv/bin/activate<br></code></pre></td></tr></table></figure><em>激活后，命令行首部会出现 <code>(venv)</code> 标识。</em></li><li><p><strong>隔离原理对比</strong>：</p><ul><li><strong>未激活</strong>：系统默认调用 <code>/usr/bin/python3</code>。</li><li><strong>激活后</strong>：终端会拦截指令，优先使用 <code>~/cs50ai/project0/degrees/venv/bin/python3</code>。</li></ul></li></ol><h3 id="3-3-运行-CS50-AI-项目"><a href="#3-3-运行-CS50-AI-项目" class="headerlink" title="3.3 运行 CS50 AI 项目"></a>3.3 运行 CS50 AI 项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入作业目录</span><br><span class="hljs-built_in">cd</span> ~/cs50ai/project0/degrees<br><br><span class="hljs-comment"># 运行程序并带上 large 数据集参数</span><br>python3 degrees.py large<br></code></pre></td></tr></table></figure><hr><h2 id="4-后端开发常用“互通”命令"><a href="#4-后端开发常用“互通”命令" class="headerlink" title="4. 后端开发常用“互通”命令"></a>4. 后端开发常用“互通”命令</h2><p>作为准 Java 后端开发，你会频繁用到这些跨界操作：</p><div class="table-container"><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">命令</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left"><strong>文件管理</strong></td><td style="text-align:left"><code>explorer.exe .</code></td><td style="text-align:left">弹窗 Windows 文件夹显示 Linux 当前路径</td></tr><tr><td style="text-align:left"><strong>代码编辑</strong></td><td style="text-align:left"><code>code .</code></td><td style="text-align:left">启动 VS Code 并利用 WSL 插件进行开发</td></tr><tr><td style="text-align:left"><strong>系统监控</strong></td><td style="text-align:left"><code>htop</code></td><td style="text-align:left">Linux 风格的动态资源监视器</td></tr><tr><td style="text-align:left"><strong>解压作业</strong></td><td style="text-align:left"><code>unzip degrees.zip</code></td><td style="text-align:left">需先安装 <code>sudo apt install unzip</code></td></tr></tbody></table></div><hr>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WLS2</tag>
      
      <tag>CS50</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="/2025/12/29/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2025/12/29/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/IDEA快捷键/2025-12-29-13-14-07.png" alt=""></p><h2 id="一、-精准检索：在代码海洋中定位"><a href="#一、-精准检索：在代码海洋中定位" class="headerlink" title="一、 精准检索：在代码海洋中定位"></a>一、 精准检索：在代码海洋中定位</h2><h3 id="1-内容搜索"><a href="#1-内容搜索" class="headerlink" title="1. 内容搜索"></a>1. 内容搜索</h3><ul><li><strong>当前文件查找 (<code>Ctrl + F</code>)</strong>：在当前打开的文件中搜索关键字。</li><li><strong>全局内容查找 (<code>Ctrl + Shift + F</code>)</strong>：在整个项目中搜索特定字符串，支持路径过滤。</li><li><strong>当前文件替换 (<code>Ctrl + R</code>)</strong>：快速替换当前类中的特定字符。</li><li><strong>全局内容替换 (<code>Ctrl + Shift + R</code>)</strong>：批量修改整个项目的字符串或配置。</li></ul><h3 id="2-对象搜索-最常用"><a href="#2-对象搜索-最常用" class="headerlink" title="2. 对象搜索 (最常用)"></a>2. 对象搜索 (最常用)</h3><ul><li><strong>查找类名 (<code>Ctrl + N</code>)</strong>：输入类名快速打开 Java 文件，支持模糊匹配。</li><li><strong>查找文件名 (<code>Ctrl + Shift + N</code>)</strong>：不仅是 Java 类，还可以快速找 XML、Properties、JSON 等配置文件。</li><li><strong>跳转指定行 (<code>Ctrl + G</code>)</strong>：当报错堆栈提示行号时，这是最快的定位方式。</li></ul><hr><h2 id="二、-优雅导航：在逻辑森林中穿行"><a href="#二、-优雅导航：在逻辑森林中穿行" class="headerlink" title="二、 优雅导航：在逻辑森林中穿行"></a>二、 优雅导航：在逻辑森林中穿行</h2><h3 id="1-结构与跳转"><a href="#1-结构与跳转" class="headerlink" title="1. 结构与跳转"></a>1. 结构与跳转</h3><ul><li><strong>最近打开文件 (<code>Ctrl + E</code>)</strong>：展示最近编辑过的文件列表，是文件切换的“第一核心键”。</li><li><strong>跳转到前/后方法 (<code>Alt + Up/Down</code>)</strong>：在类的方法之间快速跳跃，无需滚动滑轮。</li><li><strong>查看类结构 (<code>Ctrl + F12</code>)</strong>：弹窗展示当前类的所有方法和成员变量，支持直接输入搜索。</li></ul><h3 id="2-深度溯源"><a href="#2-深度溯源" class="headerlink" title="2. 深度溯源"></a>2. 深度溯源</h3><ul><li><strong>跳转到定义 (<code>Ctrl + B</code> 或 <code>Ctrl + Click</code>)</strong>：查看变量、类或方法的源代码。</li><li><strong>跳转到实现类 (<code>Ctrl + Alt + B</code>)</strong>：<strong>超级好用！</strong> 面对接口时，直接跳过接口定义，进到具体的业务实现类中。</li><li><strong>回退/前进浏览记录 (<code>Ctrl + Alt + Left/Right</code>)</strong>：就像浏览器的前进后退，快速回到刚才看代码的地方。</li></ul><hr><h2 id="三、-智能辅助：让-IDEA-为你“代工”"><a href="#三、-智能辅助：让-IDEA-为你“代工”" class="headerlink" title="三、 智能辅助：让 IDEA 为你“代工”"></a>三、 智能辅助：让 IDEA 为你“代工”</h2><h3 id="1-自动生成"><a href="#1-自动生成" class="headerlink" title="1. 自动生成"></a>1. 自动生成</h3><ul><li><strong>万能意图键 (<code>Alt + Enter</code>)</strong>：代码报错了？想导包？想创建实现类？按它就对了。</li><li><strong>代码格式化 (<code>Ctrl + Alt + L</code>)</strong>：保持代码整洁的最高效手段，建议每次写完方法都按一下。</li><li><strong>智能代码补全 (<code>Ctrl + Shift + Space</code>)</strong>：比普通补全更聪明，会根据类型推断你最可能需要的变量或方法。</li><li><strong>语句自动完成 (<code>Ctrl + Shift + Enter</code>)</strong>：自动补齐括号、大括号并在行末加分号。</li></ul><h3 id="2-编码细节"><a href="#2-编码细节" class="headerlink" title="2. 编码细节"></a>2. 编码细节</h3><ul><li><strong>参数信息提示 (<code>Ctrl + P</code>)</strong>：在调用方法时，忘记要传什么参数？按一下即刻显示参数列表。</li><li><strong>快速注释</strong>：<ul><li><code>Ctrl + /</code>：行注释。</li><li><code>Ctrl + Shift + /</code>：块注释。</li></ul></li><li><strong>包裹代码 (<code>Ctrl + Alt + T</code>)</strong>：快速把一段逻辑包进 <code>if</code>、<code>try-catch</code> 或 <code>synchronized</code> 块中。</li></ul><hr><h2 id="四、-代码重构：像外科医生一样精准"><a href="#四、-代码重构：像外科医生一样精准" class="headerlink" title="四、 代码重构：像外科医生一样精准"></a>四、 代码重构：像外科医生一样精准</h2><h3 id="1-元素重命名"><a href="#1-元素重命名" class="headerlink" title="1. 元素重命名"></a>1. 元素重命名</h3><ul><li><strong>重命名 (<code>Shift + F6</code>)</strong>：修改变量、方法或类名，它会自动帮你把项目中所有引用的地方同步更新。</li></ul><h3 id="2-提取神器-大幅提升代码可读性"><a href="#2-提取神器-大幅提升代码可读性" class="headerlink" title="2. 提取神器 (大幅提升代码可读性)"></a>2. 提取神器 (大幅提升代码可读性)</h3><ul><li><strong>提取变量 (<code>Ctrl + Alt + V</code>)</strong>：将冗长的表达式结果自动声明为局部变量。</li><li><strong>提取方法 (<code>Ctrl + Alt + M</code>)</strong>：选中一段复杂的逻辑，将其“抽离”成一个独立的方法。</li><li><strong>提取常量 (<code>Ctrl + Alt + C</code>)</strong>：将魔法值（如硬编码的字符串）提取为类常量。</li><li><strong>提取参数 (<code>Ctrl + Alt + P</code>)</strong>：将局部变量转变为方法参数，方便逻辑复用。</li></ul><hr><h2 id="五、-编辑小技巧"><a href="#五、-编辑小技巧" class="headerlink" title="五、 编辑小技巧"></a>五、 编辑小技巧</h2><ul><li><strong>复制当前行 (<code>Ctrl + D</code>)</strong>：将光标所在行直接复制到下一行。</li><li><strong>删除当前行 (<code>Ctrl + Y</code> 或 <code>Ctrl + X</code>)</strong>：快速清理无用代码。</li><li><strong>代码行交换顺序 (<code>Ctrl + Shift + Up/Down</code>)</strong>：无需剪切粘贴，直接上下平移代码行。</li><li><strong>扩大/回退选择 (<code>Ctrl + W</code> / <code>Ctrl + Shift + W</code>)</strong>：以词/块为单位逐步扩大选中范围，配合重构功能堪称绝配。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>快捷键</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50X note1</title>
    <link href="/2025/12/26/CS50%20AI%20note1/"/>
    <url>/2025/12/26/CS50%20AI%20note1/</url>
    
    <content type="html"><![CDATA[<h2 id="第-0-讲"><a href="#第-0-讲" class="headerlink" title="第 0 讲"></a><a href="https://cs50.harvard.edu/ai/notes/0/#lecture-0">第 0 讲</a></h2><h2 id="人工智能-Artificial-Intelligence"><a href="#人工智能-Artificial-Intelligence" class="headerlink" title="人工智能 (Artificial Intelligence)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#artificial-intelligence">人工智能 (Artificial Intelligence)</a></h2><p>人工智能 (AI) 涵盖了一系列让计算机表现出类似拥有“感知”行为的技术。例如，AI 被用于识别社交媒体照片中的人脸、在国际象棋中击败世界冠军，以及在你与手机上的 Siri 或 Alexa 对话时处理你的语音。</p><p>在本课程中，我们将探讨使 AI 成为可能的一些核心思想：</p><ol><li><p><strong>搜索 (Search)</strong></p><p>寻找问题的解决方案，例如导航应用程序寻找从起点到终点的最佳路线，或者在玩游戏时计算下一步该怎么走。</p></li><li><p><strong>知识 (Knowledge)</strong></p><p>表示信息并从中进行推理。</p></li><li><p><strong>不确定性 (Uncertainty)</strong></p><p>利用概率论处理不确定事件。</p></li><li><p><strong>优化 (Optimization)</strong></p><p>不仅要找到解决问题的正确方法，还要找到更好——甚至最好——的解决方法。</p></li><li><p><strong>学习 (Learning)</strong></p><p>通过访问数据和经验来提高性能。例如，你的电子邮件系统能够根据过去的经验区分垃圾邮件和非垃圾邮件。</p></li><li><p><strong>神经网络 (Neural Networks)</strong></p><p>一种受人脑启发的程序结构，能够有效地执行任务。</p></li><li><p><strong>语言 (Language)</strong></p><p>处理自然语言，即人类产生和理解的语言。</p></li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：这门课程的结构非常经典，不仅仅关注现在流行的“深度学习”，而是涵盖了 AI 的基础逻辑（如符号主义、概率推理等）。“搜索”是 AI 的基石，本质上是在无数种可能中找到达成目标的路径。</p></blockquote><h2 id="搜索-Search"><a href="#搜索-Search" class="headerlink" title="搜索 (Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#search">搜索 (Search)</a></h2><p>搜索问题涉及一个<strong>智能体 (Agent)</strong>，它被赋予一个<strong>初始状态</strong>和一个<strong>目标状态</strong>，它的任务是返回如何从前者到达后者的解决方案。导航应用就是典型的搜索过程，智能体（程序的思考部分）接收你当前的位置和想要去的目的地作为输入，并基于搜索算法返回建议的路径。当然，还有许多其他形式的搜索问题，如拼图或迷宫。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/15puzzle.png" alt="15 puzzle"></p><p>找到 15 数字推盘游戏的解法需要使用搜索算法。</p><ul><li><p><strong>智能体 (Agent)</strong></p><p>一个能够感知环境并对环境采取行动的实体。例如在导航应用中，智能体代表一辆需要决定采取哪些行动才能到达目的地的汽车。</p></li><li><p><strong>状态 (State)</strong></p><p>智能体在其环境中的一种配置。例如，在 <a href="https://en.wikipedia.org/wiki/15_puzzle">15 数字推盘</a>中，一个状态就是板上数字排列的任意一种方式。</p><ul><li><strong>初始状态 (Initial State)</strong><br>搜索算法开始的状态。在导航应用中，就是当前位置。</li></ul></li><li><p><strong>动作 (Actions)</strong></p><p>在一个状态下可以做出的选择。更准确地说，动作可以定义为一个函数。接收状态 <code>s</code> 作为输入，<code>Actions(s)</code> 返回在状态 <code>s</code> 下可执行的动作集合作为输出。例如，在 <em>15 数字推盘</em>中，给定状态的动作就是你滑动方块的方式（如果空位在中间则有 4 种，如果在边上则有 3 种，在角落则有 2 种）。</p></li><li><p><strong>转移模型 (Transition Model)</strong></p><p>描述在任何状态下执行任何适用动作后会产生什么状态。更准确地说，转移模型可以定义为一个函数。接收状态 <code>s</code> 和动作 <code>a</code> 作为输入，<code>Results(s, a)</code> 返回在状态 <code>s</code> 下执行动作 <code>a</code> 后产生的新状态。例如，给定 <em>15 数字推盘</em>的某种配置（状态 <code>s</code>），向任何方向移动一个方块（动作 <code>a</code>）都会带来拼图的新配置（新状态）。</p></li><li><p><strong>状态空间 (State Space)</strong></p><p>从初始状态通过任意动作序列可到达的所有状态的集合。例如，在 15 数字推盘中，状态空间由所有从初始状态可到达的 16!/2 种棋盘配置组成。状态空间可以可视化为一个有向图，状态表示为节点，动作表示为节点之间的箭头。</p></li></ul><p><img src="https://cs50.harvard.edu/ai/notes/0/statespace.png" alt="State Space"></p><ul><li><p><strong>目标测试 (Goal Test)</strong></p><p>确定给定状态是否为目标状态的条件。例如，在导航应用中，目标测试是检查智能体（汽车的代表）的当前位置是否在目的地。如果是——问题解决。如果不是——我们继续搜索。</p></li><li><p><strong>路径代价 (Path Cost)</strong></p><p>与给定路径相关的数值成本。例如，导航应用不仅带你到达目标；它会在最小化路径代价的同时这样做，即为你找到到达目标状态的最快方式。</p></li></ul><blockquote><p><strong>🔍 [译者注释]</strong>：理解这些术语至关重要。</p><ul><li><strong>状态 (State)</strong> 是“我们在哪里”。</li><li><strong>动作 (Action)</strong> 是“我们能做什么”。</li><li><strong>转移模型 (Transition)</strong> 是“做了之后会发生什么”。</li><li><strong>状态空间 (State Space)</strong> 是“所有可能情况的地图”。搜索算法本质上就是在这个巨大的“地图”中寻找一条路线。</li></ul></blockquote><h2 id="解决搜索问题"><a href="#解决搜索问题" class="headerlink" title="解决搜索问题"></a><a href="https://cs50.harvard.edu/ai/notes/0/#solving-search-problems">解决搜索问题</a></h2><ul><li><p><strong>解 (Solution)</strong></p><p>从初始状态导致目标状态的一系列动作。</p><ul><li><strong>最优解 (Optimal Solution)</strong><br>在所有解中具有最低路径代价的解。</li></ul></li></ul><p>在搜索过程中，数据通常存储在 <strong><em>节点 (Node)</em></strong> 中，这是一种包含以下数据的数据结构：</p><ul><li>一个 <em>状态 (state)</em></li><li>它的 <em>父节点 (parent node)</em>，即生成当前节点的那个节点</li><li>从父节点的状态应用到当前节点的 <em>动作 (action)</em></li><li>从初始状态到此节点的 <em>路径代价 (path cost)</em></li></ul><p><em>节点</em> 包含的信息使它们对搜索算法非常有用。它们包含一个 <em>状态</em>，可以使用 <em>目标测试</em> 来检查它是否是最终状态。如果是，该节点的 <em>路径代价</em> 可以与其他节点的 <em>路径代价</em> 进行比较，从而允许选择 <em>最优解</em>。一旦选择了节点，由于存储了 <em>父节点</em> 和导致从 <em>父节点</em> 到当前节点的 <em>动作</em>，就可以从 <em>初始状态</em> 一步步回溯到该节点，这个动作序列就是 <em>解</em>。</p><p>然而，<em>节点</em> 只是数据结构——它们不进行搜索，它们只是持有信息。为了实际进行搜索，我们使用 <strong>前沿 (frontier)</strong>（或称边界），这是一种“管理” <em>节点</em> 的机制。<em>前沿</em> 开始时包含一个初始状态和一个空的已探索项集合，然后重复以下操作直到找到解：</p><p><strong>重复 (Repeat):</strong></p><ol><li>如果前沿 (frontier) 为空，<ul><li><em>停止。</em> 问题无解。</li></ul></li><li>从前沿中移除一个节点。这是将被考虑的节点。</li><li><p>如果该节点包含目标状态，</p><ul><li>返回解。<em>停止</em>。</li></ul><p>否则 (Else)，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">* 扩展该节点（找到从该节点可以到达的所有新节点），并将结果节点添加到前沿中。<br>* 将当前节点添加到已探索集合 (explored set) 中。<br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li><strong>节点 vs 状态</strong>：这是一个常见的混淆点。<strong>状态</strong>是物理世界的配置（例如“我在 A 城市”）。<strong>节点</strong>是算法记录的账本（例如“我在 A 城市，我是从 B 城市过来的，目前花了 100 块钱”）。同一个状态（A 城市）可能对应多个节点（你可以从 B 来，也可以从 C 来）。</li><li><strong>前沿 (Frontier)</strong>：可以把它想象成一个“待办事项列表”。算法不断从这个列表中取出任务（节点）来处理，并把新发现的任务加进去。</li></ul></blockquote><h3 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索 (Depth-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#depth-first-search">深度优先搜索 (Depth-First Search)</a></h3><p>在前面关于 <em>前沿</em> 的描述中，有一件事没有提到。在伪代码的第 2 步，应该移除哪个节点？这个选择对解的质量以及找到解的速度有影响。有多种方法来决定应该首先考虑哪些节点，其中两种可以用 <strong>栈 (stack)</strong>（用于 <em>深度优先</em> 搜索）和 <strong>队列 (queue)</strong>（用于 <em>广度优先</em> 搜索）的数据结构来表示（<a href="https://www.google.com/search?q=dfs+vs+bfs+gif">这是一个可爱的卡通演示</a>）。</p><p>我们从 <em>深度优先</em> 搜索 (<em>DFS</em>) 方法开始。</p><p><em>深度优先</em> 搜索算法在尝试另一个方向之前会耗尽每一个方向。在这种情况下，前沿作为 <em>栈</em> 数据结构进行管理。你需要记住的口号是“<strong>后进先出 (Last-In First-Out)</strong>”。在节点被添加到前沿后，第一个被移除并考虑的节点是最后被添加的那一个。这导致搜索算法会在第一个阻碍它的方向上尽可能深地搜索，而将所有其他方向留待稍后处理。</p><p>（课程外的例子：假设你在找钥匙。在 <em>深度优先</em> 搜索方法中，如果你选择从裤子开始找，你会先检查每一个口袋，清空每个口袋并仔细检查内容物。只有当你完全检查完裤子的每一个口袋后，你才会停止在裤子里搜索并开始在其他地方搜索。）</p><ul><li><strong>优点</strong>:<ul><li>在最好的情况下，这个算法是最快的。如果它“运气好”并且总是（偶然地）选择通往解的正确路径，那么 <em>深度优先</em> 搜索花费的时间最少。</li></ul></li><li><strong>缺点</strong>:<ul><li>找到的解可能不是最优的。</li><li>在最坏的情况下，这个算法会在找到解之前探索每一条可能的路径，因此在到达解之前花费最长的时间。</li></ul></li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义从前沿移除节点并返回它的函数。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 如果前沿为空，则终止搜索，因为这意味着没有解。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;empty frontier&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 保存列表中的最后一项（即最新添加的节点）</span><br>        node = <span class="hljs-variable language_">self</span>.frontier[-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 保存列表中除了最后一个节点之外的所有项（即移除最后一个节点）</span><br>        <span class="hljs-variable language_">self</span>.frontier = <span class="hljs-variable language_">self</span>.frontier[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure><h3 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索 (Breadth-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#breadth-first-search">广度优先搜索 (Breadth-First Search)</a></h3><p><em>深度优先</em> 搜索的对立面是 <em>广度优先</em> 搜索 (<em>BFS</em>)。</p><p><em>广度优先</em> 搜索算法将同时沿着多个方向前进，在每个可能的方向上迈出一步，然后在每个方向上迈出第二步。在这种情况下，前沿作为 <em>队列</em> 数据结构进行管理。你需要记住的口号是“<strong>先进先出 (First-In First-Out)</strong>”。在这种情况下，所有新节点排队等候，根据添加的顺序来考虑节点（先到先得！）。这导致搜索算法在任何一个方向采取第二步之前，先在每个可能的方向上采取一步。</p><p>（课程外的例子：假设你在找钥匙。在这种情况下，如果你从裤子开始，你会看一眼右口袋。之后，你不会接着看左口袋，而是会看一眼抽屉。然后是桌子上。依此类推，在你通过所有想到的位置各看一眼之后。只有当你遍历了所有位置后，你才会回到裤子并搜索下一个口袋。）</p><ul><li><strong>优点</strong>:<ul><li>该算法<strong>保证</strong>找到最优解。</li></ul></li><li><strong>缺点</strong>:<ul><li>该算法几乎肯定比最小运行时间要长。</li><li>在最坏的情况下，该算法需要最长的时间运行。</li></ul></li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义从前沿移除节点并返回它的函数。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 如果前沿为空，则终止搜索，因为这意味着没有解。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;empty frontier&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 保存列表中的最老项（即第一个被添加的项）</span><br>        node = <span class="hljs-variable language_">self</span>.frontier[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 保存列表中除了第一项之外的所有项（即移除第一个节点）</span><br>        <span class="hljs-variable language_">self</span>.frontier = <span class="hljs-variable language_">self</span>.frontier[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li><strong>DFS (深度优先)</strong> 就像走迷宫时“一条路走到黑”，撞墙了再退回来。如果你运气好选对了路，很快就能到；运气不好，可能会绕很远。<strong>它不保证找到最近的路。</strong></li><li><strong>BFS (广度优先)</strong> 就像水波纹扩散，一圈一圈向外找。因为它是按距离（步数）一层层找的，所以它<strong>一定能找到步数最少的解</strong>（最优解），但通常比较耗费内存。</li></ul></blockquote><h3 id="贪婪最佳优先搜索-Greedy-Best-First-Search"><a href="#贪婪最佳优先搜索-Greedy-Best-First-Search" class="headerlink" title="贪婪最佳优先搜索 (Greedy Best-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#greedy-best-first-search">贪婪最佳优先搜索 (Greedy Best-First Search)</a></h3><p>广度优先和深度优先都是 <strong>无信息 (uninformed)</strong> 搜索算法。也就是说，这些算法除了通过自身探索获得的信息外，不利用任何关于问题的知识。然而，通常情况下，关于问题的一些知识实际上是可用的。例如，当人类迷宫解决者进入一个路口时，人类可以看到哪条路通向解的大致方向，哪条路不是。AI 也可以做同样的事情。一种考虑额外知识以试图提高其性能的算法称为 <strong>有信息 (informed)</strong> 搜索算法。</p><p><strong>贪婪最佳优先</strong> 搜索扩展那个由 <strong>启发式函数 (heuristic function)</strong> <em>h(n)</em> 确定为最接近目标的节点。顾名思义，该函数估计下一个节点距离目标有多近，但它可能会出错。<em>贪婪最佳优先</em> 算法的效率取决于启发式函数的好坏。例如，在迷宫中，算法可以使用一个依赖于可能节点与迷宫终点之间的 <strong>曼哈顿距离 (Manhattan distance)</strong> 的启发式函数。<em>曼哈顿距离</em> 忽略墙壁，计算从一个位置到达目标位置需要向上、向下或向两侧走多少步。这是一个基于当前位置和目标位置的 (x, y) 坐标可以得出的简单估算。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/manhattandistance.png" alt="Manhattan Distance"></p><p>曼哈顿距离</p><p>然而，必须强调的是，与任何启发式方法一样，它可能会出错并导致算法走上一条比其他路径更慢的路径。有可能 <em>无信息</em> 搜索算法会更快地提供更好的解，但它这样做的可能性比 <em>有信息</em> 算法要小。</p><blockquote><p><strong>🔍 [译者注释]</strong>：为什么叫“贪婪”？因为它只看眼前哪个节点离目标最近（由 $h(n)$ 决定），而不考虑它是怎么到达那个节点的（忽略了已经走过的成本）。这就像为了去某个地方，总是选择直线距离最近的路口，哪怕那条路其实很堵或者要绕远路。</p></blockquote><h3 id="A-搜索-A-Search"><a href="#A-搜索-A-Search" class="headerlink" title="A* 搜索 (A* Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#a-search">A* 搜索 (A* Search)</a></h3><p>作为 <em>贪婪最佳优先</em> 算法的发展，<em>A* 搜索</em> 不仅考虑 <em>h(n)</em>（从当前位置到目标的估计成本），还考虑 <em>g(n)</em>（直到当前位置所累积的成本）。通过结合这两个值，算法有一种更准确的方法来确定解的成本并动态优化其选择。算法跟踪 (<em>至今路径成本</em> + <em>到目标的估计成本</em>)，一旦它超过某个先前选项的估计成本，算法就会放弃当前路径并回到先前的选项，从而防止自己沿着 <em>h(n)</em> 错误地标记为最佳的一条长且低效的路径走下去。</p><p>同样，由于该算法也依赖于启发式，它的好坏取决于它所采用的启发式。在某些情况下，它可能比 <em>贪婪最佳优先</em> 搜索甚至 <em>无信息</em> 算法效率低。为了使 <em>A* 搜索</em> 成为最优的，启发式函数 <em>h(n)</em> 必须是：</p><ol><li><em>可采纳的 (Admissible)</em>，即通过不高估真实成本（即永远不大于实际成本）。</li><li><em>一致的 (Consistent)</em>，这意味着新节点到目标的估计路径成本加上从前一个节点转移到它的成本，大于或等于前一个节点到目标的估计路径成本。用方程形式表示，如果对于每个节点 <em>n</em> 和步长成本为 <em>c</em> 的后继节点 <em>n’</em>，都有 <em>h(n) ≤ h(n’) + c</em>，则 <em>h(n)</em> 是一致的。</li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：A* 是目前最流行的寻路算法。</p><ul><li>公式：$f(n) = g(n) + h(n)$。<ul><li>$g(n)$：我已经走了多远（实际成本）。</li><li>$h(n)$：我估计还要走多远（启发式）。</li></ul></li><li><strong>可采纳性 (Admissible)</strong>：意味着你的估计必须是“乐观”的。如果你估计还需要走 10 步，但实际需要 5 步，那就不行；但如果你估计 10 步，实际需要 20 步，那是可以的。只要不高估，A* 就能保证找到最优解。</li></ul></blockquote><h3 id="对抗搜索-Adversarial-Search"><a href="#对抗搜索-Adversarial-Search" class="headerlink" title="对抗搜索 (Adversarial Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#adversarial-search">对抗搜索 (Adversarial Search)</a></h3><p>此前，我们讨论的算法需要找到问题的答案，而在 <strong>对抗搜索</strong> 中，算法面临着试图实现相反目标的对手。通常，使用对抗搜索的 AI 会出现在游戏中，例如井字棋 (Tic-Tac-Toe)。</p><h4 id="极小化极大算法-Minimax"><a href="#极小化极大算法-Minimax" class="headerlink" title="极小化极大算法 (Minimax)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#minimax">极小化极大算法 (Minimax)</a></h4><p>作为对抗搜索中的一种算法，<strong>Minimax</strong> 将胜利条件表示为一方 (-1) 和另一方 (+1)。进一步的行动将由这些条件驱动，最小化方试图获得最低分，最大化方试图获得最高分。</p><p><strong>表示井字棋 AI</strong>:</p><ul><li><em>S₀</em>: 初始状态（在我们的例子中，空的 3X3 棋盘）</li><li><em>Players(s)</em>: 给定状态 <em>s</em>，返回轮到哪个玩家（X 或 O）的函数。</li><li><em>Actions(s)</em>: 给定状态 <em>s</em>，返回该状态下所有合法移动（棋盘上哪些位置是空的）的函数。</li><li><em>Result(s, a)</em>: 给定状态 <em>s</em> 和动作 <em>a</em>，返回新状态的函数。这是在状态 <em>s</em> 上执行动作 <em>a</em>（在游戏中走一步）后产生的棋盘。</li><li><em>Terminal(s)</em>: 给定状态 <em>s</em>，检查这是否是游戏的最后一步（即是否有人赢了或平局）的函数。如果游戏结束返回 <em>True</em>，否则返回 <em>False</em>。</li><li><em>Utility(s)</em>: 给定终端状态 <em>s</em>，返回状态的效用值的函数：-1、0 或 1。</li></ul><p><strong>算法如何工作</strong>:</p><p>该算法递归地模拟从当前状态开始直到达到终端状态的所有可能发生的游戏。每个终端状态被赋值为 (-1)、0 或 (+1)。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/minimax_tictactoe.png" alt="Minimax in Tic Tac Toe"></p><p>井字棋中的 Minimax 算法</p><p>根据状态知道轮到谁，算法可以知道当前玩家在进行最佳操作时，会选择导致值更低还是更高的状态的动作。这样，在最小化和最大化之间交替，算法为每个可能动作导致的状态创建值。举个更具体的例子，我们可以想象最大化玩家在每一轮都会问：“如果我采取这个行动，将会产生一个新状态。如果最小化玩家玩得最好，那个玩家会采取什么行动来带来最低的值？”然而，要回答这个问题，最大化玩家必须问：“要知道最小化玩家会做什么，我需要在最小化玩家的脑海中模拟相同的过程：最小化玩家会试图问：‘如果我采取这个行动，最大化玩家可以采取什么行动来带来最高的值？’”这是一个递归过程，可能很难理解；看下面的伪代码会有所帮助。最终，通过这个递归推理过程，最大化玩家为当前状态下所有可能动作可能导致的状态生成值。拥有这些值后，最大化玩家选择最高的一个。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/minimax_theoretical.png" alt="Minimax Algorithm"></p><p>最大化者考虑未来状态的可能值。</p><p>用伪代码表示，Minimax 算法的工作方式如下：</p><ul><li>给定状态 <em>s</em><ul><li>最大化玩家在 <em>Actions(s)</em> 中选择动作 <em>a</em>，该动作产生 <em>Min-Value(Result(s, a))</em> 的最高值。</li><li>最小化玩家在 <em>Actions(s)</em> 中选择动作 <em>a</em>，该动作产生 <em>Max-Value(Result(s, a))</em> 的最低值。</li></ul></li><li>函数 <em>Max-Value(state)</em><ul><li><em>v = -∞</em></li><li>如果 <em>Terminal(state)</em>:<br>返回 <em>Utility(state)</em></li><li>对于 <em>Actions(state)</em> 中的 <em>action</em>:<br><em>v = Max(v, Min-Value(Result(state, action)))</em><br>返回 <em>v</em></li></ul></li><li>函数 <em>Min-Value(state)</em>:<ul><li><em>v = ∞</em></li><li>如果 <em>Terminal(state)</em>:<br>返回 <em>Utility(state)</em></li><li>对于 <em>Actions(state)</em> 中的 <em>action</em>:<br><em>v = Min(v, Max-Value(Result(state, action)))</em><br>返回 <em>v</em></li></ul></li></ul><blockquote><p><strong>🔍 [译者注释]</strong>：Minimax 的核心逻辑是“换位思考”。</p><ul><li><strong>Max (我)</strong>：我想赢（得分 +1）。</li><li><strong>Min (对手)</strong>：想让我输（得分 -1）。</li><li>在做决定时，我会假设对手极其聪明。如果我走 A 步，对手可能会走 X、Y 或 Z。我会看 X、Y、Z 中哪个对我<strong>最不利</strong>（因为对手会选那个）。然后我在所有可能的 A、B、C 步中，选择那个“最坏情况中最好的”结果。</li></ul></blockquote><h4 id="Alpha-Beta-剪枝-Alpha-Beta-Pruning"><a href="#Alpha-Beta-剪枝-Alpha-Beta-Pruning" class="headerlink" title="Alpha-Beta 剪枝 (Alpha-Beta Pruning)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#alpha-beta-pruning">Alpha-Beta 剪枝 (Alpha-Beta Pruning)</a></h4><p>作为优化 <em>Minimax</em> 的一种方法，<strong>Alpha-Beta 剪枝</strong> 跳过一些明显不利的递归计算。在确定了一个动作的值之后，如果有初步证据表明随后的动作可能让对手获得比已经确定的动作更好的分数，那么就没有必要进一步调查这个动作了，因为它肯定比先前确定的那个更不有利。</p><p>这用一个例子最容易展示：一个最大化玩家知道，在下一步，最小化玩家将试图获得最低分。假设最大化玩家有三个可能的动作，第一个动作的值为 4。然后玩家开始生成下一个动作的值。为此，玩家生成如果当前玩家采取此动作后最小化玩家动作的值，知道最小化者会选择最低的那个。然而，在完成最小化玩家所有可能动作的计算之前，玩家看到其中一个选项的值为 3。这意味着没有理由继续探索最小化玩家的其他可能动作了。尚未估值的动作的值是多少并不重要，无论是 10 还是 (-10)。如果值为 10，最小化者会选择最低的选项 3，这已经比预先确定的 4 差了。如果尚未估值的动作结果是 (-10)，最小化者将选择这个选项 (-10)，这对最大化者来说更加不利。因此，此时计算最小化者的其他可能动作对最大化者来说是无关紧要的，因为最大化玩家已经有了一个明确更好的选择，其值为 4。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/alphabeta.png" alt="Alpha Beta Pruning"></p><blockquote><p><strong>🔍 [译者注释]</strong>：想象你在挑苹果，你想挑个最大的。</p><ul><li>第一筐里最小的苹果是 5 两重（所以这筐至少能给你 5 两）。</li><li>你开始看第二筐，拿起来第一个苹果是 3 两。</li><li><strong>剪枝</strong>：你不需要再看第二筐剩下的苹果了。因为你是最大化者（想要最大的），而这一步是对手（最小化者）在选。对手既然能在第二筐找到 3 两的，那他绝对不会让你在这一筐得到超过 3 两的结果。既然 3 两已经比第一筐的 5 两差了，第二筐就被你放弃了。</li></ul></blockquote><h4 id="深度受限-Minimax-Depth-Limited-Minimax"><a href="#深度受限-Minimax-Depth-Limited-Minimax" class="headerlink" title="深度受限 Minimax (Depth-Limited Minimax)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#depth-limited-minimax">深度受限 Minimax (Depth-Limited Minimax)</a></h4><p>井字棋共有 255,168 种可能的游戏过程，而国际象棋有 10²⁹⁰⁰⁰ 种可能的游戏。目前所介绍的 Minimax 算法需要生成从某一点到终端条件的所有假设游戏。虽然现代计算机计算所有井字棋游戏并不构成挑战，但对国际象棋这样做目前是不可能的。</p><p><strong>深度受限 Minimax</strong> 仅考虑预定义数量的步数后就停止，而不必到达终端状态。然而，这不允许为每个动作获得精确的值，因为尚未到达假设游戏的结尾。为了解决这个问题，<em>深度受限 Minimax</em> 依赖于一个 <strong>评估函数 (evaluation function)</strong>，该函数估计从给定状态开始的游戏的预期效用，换句话说，为状态赋值。例如，在国际象棋游戏中，效用函数将接收棋盘的当前配置作为输入，尝试评估其预期效用（基于每个玩家拥有的棋子及其在棋盘上的位置），然后返回一个正值或负值，表示该棋盘对一个玩家相对于另一个玩家的有利程度。这些值可用于决定正确的动作，评估函数越好，依赖它的 Minimax 算法就越好。</p><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li>这就是现实中下棋软件（如早期的“深蓝”）的工作原理。它算不了无限远，只能算往后 10 步或 20 步。</li><li><strong>评估函数</strong> 是关键：当我看不到结局时，我必须凭经验判断现在的局势是好是坏。例如：“我有皇后，对方没有，所以我这局势+9分”。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50X</tag>
      
      <tag>讲义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序算法</title>
    <link href="/2025/12/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2025/12/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="🧩-归并排序（Merge-Sort）：分而治之的艺术"><a href="#🧩-归并排序（Merge-Sort）：分而治之的艺术" class="headerlink" title="🧩 归并排序（Merge Sort）：分而治之的艺术"></a>🧩 归并排序（Merge Sort）：分而治之的艺术</h1><p>归并排序的核心思想是：<strong>先拆分，后合并</strong>。<br>它将一个大数组不断二分，直到每个小数组只有一个元素（此时每个小数组都是有序的），然后将这些有序的小数组两两合并，最终得到完整的有序数组。<br><img src="/img/归并排序/2025-12-29-13-14-29.png" alt=""></p><h2 id="1-核心原理：两个阶段"><a href="#1-核心原理：两个阶段" class="headerlink" title="1. 核心原理：两个阶段"></a>1. 核心原理：两个阶段</h2><ol><li><strong>分（Divide）</strong>：找到数组的中点，把数组一分为二。递归地对左右两半进行同样的操作，直到数组长度为 1。</li><li><strong>治/合（Merge）</strong>：这是最关键的一步。将两个<strong>已经排好序</strong>的子数组合并成一个新的有序数组。</li></ol><h3 id="💡-生动比喻"><a href="#💡-生动比喻" class="headerlink" title="💡 生动比喻"></a>💡 生动比喻</h3><p>想象你要整理一副乱序的扑克牌：</p><ul><li><strong>分</strong>：你把牌堆不断对半切开，直到每个人手里都只拿<strong>一张牌</strong>（一张牌自然是有序的）。</li><li><strong>合</strong>：两个拿牌的人比较谁手里的牌小，谁先放在桌上。接着四个人的两组牌再进行比较合并……最终整副牌就排好了。</li></ul><hr><h2 id="2-核心语法与实现（Java）"><a href="#2-核心语法与实现（Java）" class="headerlink" title="2. 核心语法与实现（Java）"></a>2. 核心语法与实现（Java）</h2><p>归并排序通常使用<strong>递归</strong>来实现。我们需要一个辅助函数来执行“合并”操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前：&quot;</span> + Arrays.toString(arr));<br>        <br>        mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;排序后：&quot;</span> + Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-comment">// 递归拆分函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">// 找到中间索引，防止溢出的写法</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">// 递归拆分左半部分</span><br>            mergeSort(arr, left, mid);<br>            <span class="hljs-comment">// 递归拆分右半部分</span><br>            mergeSort(arr, mid + <span class="hljs-number">1</span>, right);<br><br>            <span class="hljs-comment">// 合并左右两部分</span><br>            merge(arr, left, mid, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 核心合并函数：将两个有序区间 [left, mid] 和 [mid+1, right] 合并</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建临时数组存放合并结果</span><br>        <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left;      <span class="hljs-comment">// 左子数组的起点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 右子数组的起点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;         <span class="hljs-comment">// 临时数组的索引</span><br><br>        <span class="hljs-comment">// 2. 比较两个子数组，谁小就谁进 temp</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) &#123;<br>                temp[k++] = arr[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp[k++] = arr[j++];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 将左边剩余元素放入 temp（如果有）</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            temp[k++] = arr[i++];<br>        &#125;<br><br>        <span class="hljs-comment">// 4. 将右边剩余元素放入 temp（如果有）</span><br>        <span class="hljs-keyword">while</span> (j &lt;= right) &#123;<br>            temp[k++] = arr[j++];<br>        &#125;<br><br>        <span class="hljs-comment">// 5. 把排好序的 temp 复制回原数组 arr</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; p &lt; temp.length; p++) &#123;<br>            arr[left + p] = temp[p];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3. 性能分析"></a>3. 性能分析</h2><ul><li><strong>时间复杂度</strong>：始终是 $O(n \log n)$。不管原数组是乱序还是已经排好序，它的表现都非常稳定。</li><li><strong>空间复杂度</strong>：$O(n)$。因为合并过程中需要一个和原数组一样大的临时数组。</li><li><strong>稳定性</strong>：<strong>稳定</strong>排序。在合并逻辑中，如果 <code>arr[i] == arr[j]</code>，我们先放左边的 <code>arr[i]</code>，保证了相同元素的相对顺序不变。</li></ul><hr><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ol><li><strong>大规模数据排序</strong>：当内存装不下所有数据时，归并排序的思想可以用于<strong>外部排序</strong>（从磁盘读入部分数据排序后再合并）。</li><li><strong>求逆序对</strong>：这是归并排序的一个典型算法变种题。</li><li><strong>链表排序</strong>：在 LeetCode 中，排序链表的最佳选择通常是归并排序，因为链表不需要连续的内存空间。</li></ol><hr><h2 id="⚠️-讲师提醒：新手易错点"><a href="#⚠️-讲师提醒：新手易错点" class="headerlink" title="⚠️ 讲师提醒：新手易错点"></a>⚠️ 讲师提醒：新手易错点</h2><ol><li><strong>递归终止条件</strong>：一定要写 <code>if (left &lt; right)</code>，否则会进入死循环（栈溢出）。</li><li><strong>中点计算</strong>：使用 <code>mid = left + (right - left) / 2</code> 能够有效避免 <code>(left + right)</code> 导致的整数溢出风险。</li><li><strong>区间闭合</strong>：合并时注意 <code>while (i &lt;= mid)</code> 的等于号，漏掉会导致数组元素丢失。</li></ol>]]></content>
    
    
    <categories>
      
      <category>DS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数组常用API</title>
    <link href="/2025/12/24/Java%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8API/"/>
    <url>/2025/12/24/Java%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h1 id="🚀-Java-进阶：数组常用-API-与经典操作实战"><a href="#🚀-Java-进阶：数组常用-API-与经典操作实战" class="headerlink" title="🚀 Java 进阶：数组常用 API 与经典操作实战"></a>🚀 Java 进阶：数组常用 API 与经典操作实战</h1><blockquote><p><strong>导读</strong>：<br>这一节我们将解锁 Java 数组的“瑞士军刀”——<code>java.util.Arrays</code> 类，它可以让你一行代码搞定排序、查找和打印。<br>同时，我们也会深入底层，手写几个经典的数组算法（如反转、扩容），这是理解数据结构逻辑的关键。</p></blockquote><hr><h2 id="第一部分：Java-数组的“瑞士军刀”-常用-API"><a href="#第一部分：Java-数组的“瑞士军刀”-常用-API" class="headerlink" title="第一部分：Java 数组的“瑞士军刀” (常用 API)"></a>第一部分：Java 数组的“瑞士军刀” (常用 API)</h2><p>Java 官方为了不让我们重复造轮子，提供了一个强大的工具类 <code>java.util.Arrays</code>。使用前请记得 <code>import java.util.Arrays;</code>。</p><h3 id="1-🔍-查看与打印：toString-amp-deepToString"><a href="#1-🔍-查看与打印：toString-amp-deepToString" class="headerlink" title="1. 🔍 查看与打印：toString() &amp; deepToString()"></a>1. 🔍 查看与打印：<code>toString()</code> &amp; <code>deepToString()</code></h3><p>直接打印数组变量只能看到内存地址，必须用这个方法才能看到“真面目”。</p><ul><li><strong>场景</strong>：调试代码，查看数组里的内容。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(Arrays.toString(arr)); <br><span class="hljs-comment">// 输出: [1, 2, 3]</span><br><br><span class="hljs-type">int</span>[][] matrix = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;;<br><span class="hljs-comment">// 注意：多维数组要用 deepToString，否则里面的数组还是显示地址</span><br>System.out.println(Arrays.deepToString(matrix)); <br><span class="hljs-comment">// 输出: [[1, 2], [3, 4]]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-🔢-排序：sort"><a href="#2-🔢-排序：sort" class="headerlink" title="2. 🔢 排序：sort()"></a>2. 🔢 排序：<code>sort()</code></h3><p>将数组元素按照从小到大（升序）排列。底层使用了双轴快速排序等高效算法。</p><ul><li><strong>场景</strong>：排行榜、数据整理。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] scores = &#123;<span class="hljs-number">88</span>, <span class="hljs-number">50</span>, <span class="hljs-number">99</span>, <span class="hljs-number">70</span>&#125;;<br>Arrays.sort(scores);<br>System.out.println(Arrays.toString(scores)); <br><span class="hljs-comment">// 输出: [50, 70, 88, 99] (自动变成有序了)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-🔎-查找：binarySearch-二分查找"><a href="#3-🔎-查找：binarySearch-二分查找" class="headerlink" title="3. 🔎 查找：binarySearch() (二分查找)"></a>3. 🔎 查找：<code>binarySearch()</code> (二分查找)</h3><p>在一个<strong>有序</strong>的数组中快速查找某个元素的位置。</p><ul><li><strong>⚠️ 注意</strong>：使用此方法前，<strong>必须先排序</strong>！如果数组是乱序的，结果不可预测。</li><li><p><strong>返回值</strong>：如果找到，返回索引；如果找不到，返回负数。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;; <span class="hljs-comment">// 必须是有序的</span><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums, <span class="hljs-number">30</span>);<br>System.out.println(<span class="hljs-string">&quot;30的下标是：&quot;</span> + index); <span class="hljs-comment">// 输出: 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">errorIndex</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums, <span class="hljs-number">25</span>);<br>System.out.println(<span class="hljs-string">&quot;找不存在的数：&quot;</span> + errorIndex); <span class="hljs-comment">// 输出负数 (例如 -3)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-👯-比较：equals"><a href="#4-👯-比较：equals" class="headerlink" title="4. 👯 比较：equals()"></a>4. 👯 比较：<code>equals()</code></h3><p>判断两个数组的<strong>内容</strong>是否完全一致（长度相同，且对应位置元素相同）。</p><ul><li><p><strong>注意</strong>：直接用 <code>==</code> 比较的是两个数组的内存地址，通常都是 <code>false</code>。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] arr2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>System.out.println(arr1 == arr2);       <span class="hljs-comment">// false (它是两个不同的对象)</span><br>System.out.println(Arrays.equals(arr1, arr2)); <span class="hljs-comment">// true (内容一样)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5-🛠-填充：fill"><a href="#5-🛠-填充：fill" class="headerlink" title="5. 🛠 填充：fill()"></a>5. 🛠 填充：<code>fill()</code></h3><p>快速把数组的所有位置（或指定范围）都填成同一个值。</p><ul><li><strong>场景</strong>：初始化游戏地图、重置数据。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>Arrays.fill(box, <span class="hljs-number">666</span>); <span class="hljs-comment">// 把整个数组都填满 666</span><br><span class="hljs-comment">// 输出: [666, 666, 666, 666, 666]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6-📋-复制与截取：copyOf-amp-copyOfRange"><a href="#6-📋-复制与截取：copyOf-amp-copyOfRange" class="headerlink" title="6. 📋 复制与截取：copyOf() &amp; copyOfRange()"></a>6. 📋 复制与截取：<code>copyOf()</code> &amp; <code>copyOfRange()</code></h3><ul><li><code>copyOf(原数组, 新长度)</code>：从头开始复制，可用于扩容或截断。</li><li><p><code>copyOfRange(原数组, start, end)</code>：复制中间某一段（含头不含尾）。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><br><span class="hljs-comment">// 复制前3个</span><br><span class="hljs-type">int</span>[] newArr = Arrays.copyOf(src, <span class="hljs-number">3</span>); <br><span class="hljs-comment">// 结果: [10, 20, 30]</span><br><br><span class="hljs-comment">// 扩容复制 (后面补默认值)</span><br><span class="hljs-type">int</span>[] bigArr = Arrays.copyOf(src, <span class="hljs-number">7</span>);<br><span class="hljs-comment">// 结果: [10, 20, 30, 40, 50, 0, 0]</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="⚡-补充：一个高效的底层-API"><a href="#⚡-补充：一个高效的底层-API" class="headerlink" title="⚡ 补充：一个高效的底层 API"></a>⚡ 补充：一个高效的底层 API</h2><p>在阅读 Java 源码时，你会经常看到 <code>System.arraycopy</code>。它是最底层的数组复制方法，性能极高（直接操作内存），但参数比较多，容易写错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法：</span><br><span class="hljs-comment">// System.arraycopy(原数组, 原数组起始位置, 目标数组, 目标数组起始位置, 复制多少个);</span><br><br><span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span>[] dest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">// 把 src 的后两个元素 (3,4) 复制到 dest 的开头</span><br>System.arraycopy(src, <span class="hljs-number">2</span>, dest, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br><br>System.out.println(Arrays.toString(dest)); <br><span class="hljs-comment">// 输出: [3, 4, 0, 0]</span><br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>日常开发</strong>：首选 <code>java.util.Arrays</code> 类，代码简洁，可读性高。</li><li><strong>性能敏感/底层开发</strong>：使用 <code>System.arraycopy</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JavaSE</tag>
      
      <tag>语法知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java生成随机数</title>
    <link href="/2025/12/24/Java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <url>/2025/12/24/Java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="🎲-Java-核心：生成随机数的-4-种姿势"><a href="#🎲-Java-核心：生成随机数的-4-种姿势" class="headerlink" title="🎲 Java 核心：生成随机数的 4 种姿势"></a>🎲 Java 核心：生成随机数的 4 种姿势</h1><blockquote><p><strong>导读</strong>：<br>并不是所有的随机数都是“真随机”。<br>在 Java 中，你需要根据你的应用场景（是写个小Demo，还是写银行支付系统）来选择不同的随机数生成器。</p></blockquote><hr><h2 id="1-简易入门：Math-random"><a href="#1-简易入门：Math-random" class="headerlink" title="1. 简易入门：Math.random()"></a>1. 简易入门：Math.random()</h2><h3 id="📖-概念定义"><a href="#📖-概念定义" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是 Java 最基础的工具类 <code>Math</code> 提供的一个静态方法。它不需要 <code>new</code> 对象，直接调用即可。</p><h3 id="⚙️-核心规则"><a href="#⚙️-核心规则" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>返回值</strong>：它固定返回一个 <code>0.0</code> (包含) 到 <code>1.0</code> (不包含) 之间的 <code>double</code> 小数。</li><li><strong>底层</strong>：其实它底层也是调用了 <code>java.util.Random</code>，只是做了一层简单的封装。</li></ul><h3 id="💻-代码示例"><a href="#💻-代码示例" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathRandomDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 基础用法：生成 0.0 ~ 1.0 之间的小数</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Math.random();<br>        System.out.println(<span class="hljs-string">&quot;随机小数: &quot;</span> + d);<br><br>        <span class="hljs-comment">// 2. 进阶用法：生成 [0, 100) 之间的整数</span><br>        <span class="hljs-comment">// 逻辑：先把 0.x 放大100倍，再强制转成 int 去掉小数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>);<br>        System.out.println(<span class="hljs-string">&quot;0到99的整数: &quot;</span> + num);<br><br>        <span class="hljs-comment">// 3. 必背公式：生成 [min, max] 之间的整数 (包含两端)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">// 公式：(int)(Math.random() * (最大值 - 最小值 + 1)) + 最小值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rangeNum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * (max - min + <span class="hljs-number">1</span>)) + min;<br>        System.out.println(<span class="hljs-string">&quot;50到100的整数: &quot;</span> + rangeNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景"><a href="#🚀-应用场景" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li>快速测试、简单的脚本。</li><li><strong>缺点</strong>：写区间公式太麻烦，容易算错。</li></ul><hr><h2 id="2-标准通用：java-util-Random"><a href="#2-标准通用：java-util-Random" class="headerlink" title="2. 标准通用：java.util.Random"></a>2. 标准通用：java.util.Random</h2><h3 id="📖-概念定义-1"><a href="#📖-概念定义-1" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是 Java 面向对象标准的随机数生成器。你需要先创建一个“骰子”对象，然后摇它。</p><h3 id="⚙️-核心规则-1"><a href="#⚙️-核心规则-1" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>灵活性</strong>：可以直接生成 <code>int</code>, <code>boolean</code>, <code>float</code> 等多种类型，不需要像 <code>Math.random</code> 那样手动转换。</li><li><strong>种子 (Seed)</strong>：如果你在 new 的时候传入一个固定的数字（种子），那么每次运行生成的随机数序列是<strong>一模一样</strong>的（常用于复现 Bug）。</li></ul><h3 id="💻-代码示例-1"><a href="#💻-代码示例-1" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UtilRandomDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建随机数对象 (不带种子，默认以当前时间为种子)</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>        <span class="hljs-comment">// 2. 生成各种类型的随机数</span><br>        System.out.println(<span class="hljs-string">&quot;随机布尔值: &quot;</span> + r.nextBoolean()); <span class="hljs-comment">// true 或 false</span><br>        System.out.println(<span class="hljs-string">&quot;随机Double: &quot;</span> + r.nextDouble()); <span class="hljs-comment">// 0.0 ~ 1.0</span><br><br>        <span class="hljs-comment">// 3. 最好用的方法：nextInt(bound)</span><br>        <span class="hljs-comment">// 生成 [0, 10) 之间的整数 (不包含10)</span><br>        <span class="hljs-comment">// 也就是 0 ~ 9</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>); <br>        System.out.println(<span class="hljs-string">&quot;0到9的整数: &quot;</span> + i);<br>        <br>        <span class="hljs-comment">// ------------------------------------</span><br>        <span class="hljs-comment">// 特殊情况：带种子的随机 (伪随机的真相)</span><br>        <span class="hljs-comment">// 只要种子一样，生成的随机数顺序永远一样</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">rFixed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">100</span>); <br>        System.out.println(<span class="hljs-string">&quot;固定随机数1: &quot;</span> + rFixed.nextInt(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 每次运行都是同一个数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-1"><a href="#🚀-应用场景-1" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li>大多数业务开发、游戏逻辑、模拟数据。</li></ul><hr><h2 id="3-高性能并发：ThreadLocalRandom-Java-7"><a href="#3-高性能并发：ThreadLocalRandom-Java-7" class="headerlink" title="3. 高性能并发：ThreadLocalRandom (Java 7+)"></a>3. 高性能并发：ThreadLocalRandom (Java 7+)</h2><h3 id="📖-概念定义-2"><a href="#📖-概念定义-2" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是为了解决多线程问题而生的工具。</p><h3 id="💡-通俗理解"><a href="#💡-通俗理解" class="headerlink" title="💡 通俗理解"></a>💡 通俗理解</h3><p><code>java.util.Random</code> 是线程安全的，但在多线程高并发时（比如 1000 个人同时去抢一个骰子），会产生<strong>竞争</strong>，导致性能下降。<br><code>ThreadLocalRandom</code> 相当于<strong>给每个线程发了一个专用的骰子</strong>，互不干扰，速度极快。</p><h3 id="💻-代码示例-2"><a href="#💻-代码示例-2" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TLRDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 注意：不能 new，要用 current() 获取当前线程的实例</span><br>        <span class="hljs-type">ThreadLocalRandom</span> <span class="hljs-variable">tlr</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current();<br><br>        <span class="hljs-comment">// 用法和 Random 几乎一样，但性能更高</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> tlr.nextInt(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 直接支持生成 [10, 20) 的范围，超方便！</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;10到19的整数: &quot;</span> + val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-2"><a href="#🚀-应用场景-2" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li><strong>高并发系统</strong>、多线程环境。</li><li>在 JDK 7 之后，<strong>强烈推荐</strong>在多线程能替代 <code>Random</code> 的地方都用这个。</li></ul><hr><h2 id="4-银行级安全：java-security-SecureRandom"><a href="#4-银行级安全：java-security-SecureRandom" class="headerlink" title="4. 银行级安全：java.security.SecureRandom"></a>4. 银行级安全：java.security.SecureRandom</h2><h3 id="📖-概念定义-3"><a href="#📖-概念定义-3" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>真·随机数生成器。前面的 <code>Random</code> 实际上是根据算法算出来的（伪随机），如果黑客知道了算法和种子，就能预测下一个数。<br><code>SecureRandom</code> 利用操作系统的随机源（如鼠标移动、键盘敲击、CPU热噪声等）来生成随机数。</p><h3 id="⚙️-核心规则-2"><a href="#⚙️-核心规则-2" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>不可预测性</strong>：极其难以被破解。</li><li><strong>性能</strong>：比普通的 Random 慢很多（因为生成过程很复杂）。</li></ul><h3 id="💻-代码示例-3"><a href="#💻-代码示例-3" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">sr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>        <br>        <span class="hljs-comment">// 用法和 Random 一样</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">passwordPart</span> <span class="hljs-operator">=</span> sr.nextInt(<span class="hljs-number">10000</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;安全随机数: &quot;</span> + passwordPart);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-3"><a href="#🚀-应用场景-3" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li><strong>生成密码、Token、Session ID、加密密钥</strong>。</li><li>凡是涉及到<strong>钱</strong>和<strong>安全</strong>的地方，严禁使用 <code>Math.random</code> 或 <code>Random</code>，必须用 <code>SecureRandom</code>。</li></ul><hr><h2 id="📝-总结：我该用哪个？"><a href="#📝-总结：我该用哪个？" class="headerlink" title="📝 总结：我该用哪个？"></a>📝 总结：我该用哪个？</h2><div class="table-container"><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">推荐方式</th><th style="text-align:left">理由</th></tr></thead><tbody><tr><td style="text-align:left"><strong>写个小Demo / 教学</strong></td><td style="text-align:left"><code>Math.random()</code></td><td style="text-align:left">代码最短，不用导包。</td></tr><tr><td style="text-align:left"><strong>一般业务 / 单线程</strong></td><td style="text-align:left"><code>java.util.Random</code></td><td style="text-align:left">API 丰富，符合直觉。</td></tr><tr><td style="text-align:left"><strong>高并发 / 多线程</strong></td><td style="text-align:left"><code>ThreadLocalRandom</code></td><td style="text-align:left"><strong>性能王者</strong>，不堵车。</td></tr><tr><td style="text-align:left"><strong>生成密码 / 涉及钱</strong></td><td style="text-align:left"><code>SecureRandom</code></td><td style="text-align:left"><strong>安全王者</strong>，黑客猜不到。</td></tr></tbody></table></div><h3 id="💡-讲师提示"><a href="#💡-讲师提示" class="headerlink" title="💡 讲师提示"></a>💡 讲师提示</h3><p>作为新手，你现阶段主要掌握 <strong><code>java.util.Random</code></strong> 就足够应对 90% 的学习场景了。但记住，等到以后做Web项目生成验证码时，一定要想起来用 <code>SecureRandom</code> 哦！</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JavaSE</tag>
      
      <tag>语法知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java为什么不用const</title>
    <link href="/2025/12/23/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8const/"/>
    <url>/2025/12/23/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8const/</url>
    
    <content type="html"><![CDATA[<p>在学习 Java 时，很多从 C++ 或 C# 转过来的小伙伴都会下意识地去找 <code>const</code>。但在 Java 中，情况有点特殊。</p><hr><h2 id="1-const：有名无实的“保留字”"><a href="#1-const：有名无实的“保留字”" class="headerlink" title="1. const：有名无实的“保留字”"></a>1. <code>const</code>：有名无实的“保留字”</h2><p><strong>概念定义</strong>：在 Java 中，<code>const</code> 被称为<strong>保留字（Reserved Word）</strong>，而不是<strong>关键字（Keyword）</strong>。</p><ul><li><strong>现状</strong>：它在 Java 源码中存在，但没有任何语法功能。</li><li><strong>规则</strong>：你不能用 <code>const</code> 来定义常量，同时你也<strong>不能</strong>用 <code>const</code> 作为你的变量名。</li><li><strong>为什么保留它？</strong>：主要是为了防止程序员在写 Java 时误用了 C++ 的习惯，或者为了将来可能的版本升级预留位置。</li></ul><hr><h2 id="2-真正的常量主角：final"><a href="#2-真正的常量主角：final" class="headerlink" title="2. 真正的常量主角：final"></a>2. 真正的常量主角：<code>final</code></h2><p><strong>概念定义</strong>：在 Java 中，如果你想定义一个“一旦赋值就不能改变”的量，必须使用关键字 <strong><code>final</code></strong>。</p><h3 id="核心规则："><a href="#核心规则：" class="headerlink" title="核心规则："></a>核心规则：</h3><ol><li><strong>不可变性</strong>：被 <code>final</code> 修饰的变量，只能被赋值一次，之后再尝试修改会直接报错。</li><li><strong>命名规范</strong>：Java 中的常量通常要求<strong>全部大写</strong>，多个单词之间用下划线 <code>_</code> 分隔（例如：<code>MAX_SPEED</code>）。</li><li><strong>修饰位置</strong>：<code>final</code> 既可以修饰局部变量，也可以修饰类成员变量。</li></ol><hr><h2 id="3-代码示例：如何正确定义常量"><a href="#3-代码示例：如何正确定义常量" class="headerlink" title="3. 代码示例：如何正确定义常量"></a>3. 代码示例：如何正确定义常量</h2><p>在实际开发中，我们通常结合 <code>static</code> 和 <code>final</code> 来定义一个全局常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstantDemo</span> &#123;<br>    <span class="hljs-comment">// 1. 类级别的全局常量（最常见用法）</span><br>    <span class="hljs-comment">// static 让它属于类，final 保证它不可变</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926535</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_LOGIN_ATTEMPTS</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 2. 局部常量</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <br>        <span class="hljs-comment">// age = 21; // ❌ 编译报错：无法为最终变量 age 分配值</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;圆周率是：&quot;</span> + PI);<br>        System.out.println(<span class="hljs-string">&quot;我的年龄是：&quot;</span> + age);<br>        <br>        <span class="hljs-comment">// 3. 错误示范（如果你非要用 const）</span><br>        <span class="hljs-comment">// int const = 10; // ❌ 编译报错：const 是保留字，不能用作标识符</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-final-与-const-的对比-Java-vs-其他语言"><a href="#4-final-与-const-的对比-Java-vs-其他语言" class="headerlink" title="4. final 与 const 的对比 (Java vs 其他语言)"></a>4. <code>final</code> 与 <code>const</code> 的对比 (Java vs 其他语言)</h2><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Java 的 <code>final</code></th><th style="text-align:left">C++/C# 的 <code>const</code></th></tr></thead><tbody><tr><td style="text-align:left"><strong>定义常量</strong></td><td style="text-align:left">✅ 完美支持</td><td style="text-align:left">✅ 完美支持</td></tr><tr><td style="text-align:left"><strong>运行期赋值</strong></td><td style="text-align:left">✅ 支持（可以在运行时计算值再锁定）</td><td style="text-align:left">❌ 通常要求编译期确定值</td></tr><tr><td style="text-align:left"><strong>修饰类/方法</strong></td><td style="text-align:left">✅ 可以（防止类被继承或方法被重写）</td><td style="text-align:left">❌ 通常只修饰变量</td></tr></tbody></table></div><h1 id="进阶笔记：Java-final-vs-C-C-const-的三大本质区别"><a href="#进阶笔记：Java-final-vs-C-C-const-的三大本质区别" class="headerlink" title="进阶笔记：Java final vs C++/C# const 的三大本质区别"></a>进阶笔记：Java <code>final</code> vs C++/C# <code>const</code> 的三大本质区别</h1><p>很多编程语言都有 <code>const</code>，但在 Java 中，<code>final</code> 承担了更多的职责。你提到的“运行期赋值”和“修饰类/方法”正是它的灵魂所在。</p><hr><h3 id="4-1-运行期赋值：不仅仅是“死板”的常量"><a href="#4-1-运行期赋值：不仅仅是“死板”的常量" class="headerlink" title="4.1. 运行期赋值：不仅仅是“死板”的常量"></a>4.1. 运行期赋值：不仅仅是“死板”的常量</h3><p>在 C# 等语言中，<code>const</code> 要求在<strong>编译时</strong>就确定值（比如 <code>3.14</code>）。但 Java 的 <code>final</code> 允许你在<strong>运行时</strong>再决定它的值，一旦定下来，就不再更改。</p><p><strong>比喻</strong>：<code>const</code> 是“出厂即刻字”，而 <code>final</code> 是“发货前才填写的终身快递单”。</p><p><strong>代码示例</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalRuntimeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 运行期赋值：每次运行，value 的值可能都不一样</span><br>        <span class="hljs-comment">// 但在同一个生命周期内，value 一旦被赋值就不能再改</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;本次运行确定的常量值：&quot;</span> + value);<br>        <br>        <span class="hljs-comment">// value = 200; // ❌ 依然会报错，因为它已经是 final 了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><strong>应用场景</strong>：比如根据用户的输入、数据库的查询结果、或者是当前系统的年份来初始化一个“只读变量”。</p><hr><h3 id="2-架构防线：修饰类与方法"><a href="#2-架构防线：修饰类与方法" class="headerlink" title="2. 架构防线：修饰类与方法"></a>2. 架构防线：修饰类与方法</h3><p>这是 <code>const</code> 完全无法触及的领域。在 Java 中，<code>final</code> 被用来保护代码的<strong>继承结构</strong>。</p><h4 id="A-修饰方法-Prevent-Overriding"><a href="#A-修饰方法-Prevent-Overriding" class="headerlink" title="A. 修饰方法 (Prevent Overriding)"></a>A. 修饰方法 (Prevent Overriding)</h4><p><strong>规则</strong>：父类的方法被 <code>final</code> 修饰后，子类<strong>不能重写</strong>它。<br><strong>意义</strong>：锁定核心逻辑，防止子类“乱改”导致逻辑崩溃。</p><h4 id="B-修饰类-Prevent-Inheritance"><a href="#B-修饰类-Prevent-Inheritance" class="headerlink" title="B. 修饰类 (Prevent Inheritance)"></a>B. 修饰类 (Prevent Inheritance)</h4><p><strong>规则</strong>：类被 <code>final</code> 修饰后，<strong>不能被继承</strong>。<br><strong>意义</strong>：比如 <code>String</code> 类就是 <code>final</code> 的。如果人人都能继承并修改 <code>String</code> 的行为，整个 Java 世界就乱套了。</p><p><strong>代码示例</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是一个 final 类，不能有“儿子”</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecuritySystem</span> &#123;<br>    <br>    <span class="hljs-comment">// 这是一个 final 方法，子类即便能继承（如果类不是 final），也不能修改</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verifyIdentity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行极其严格的身份核验逻辑，禁止修改！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class HackSystem extends SecuritySystem &#123; &#125; // ❌ 报错：无法从最终类继承</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="3-深度对比表：为什么-final-比-const-更强大？"><a href="#3-深度对比表：为什么-final-比-const-更强大？" class="headerlink" title="3. 深度对比表：为什么 final 比 const 更强大？"></a>3. 深度对比表：为什么 <code>final</code> 比 <code>const</code> 更强大？</h3><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Java <code>final</code></th><th style="text-align:left">典型 <code>const</code> (如 C#)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>赋值时机</strong></td><td style="text-align:left"><strong>编译期 或 运行期</strong></td><td style="text-align:left">通常只能是 <strong>编译期</strong></td></tr><tr><td style="text-align:left"><strong>修饰变量</strong></td><td style="text-align:left">✅ 锁定引用/值</td><td style="text-align:left">✅ 锁定值</td></tr><tr><td style="text-align:left"><strong>修饰类</strong></td><td style="text-align:left">✅ 禁止继承</td><td style="text-align:left">❌ 不支持 (C# 用 <code>sealed</code>)</td></tr><tr><td style="text-align:left"><strong>修饰方法</strong></td><td style="text-align:left">✅ 禁止重写</td><td style="text-align:left">❌ 不支持</td></tr><tr><td style="text-align:left"><strong>对象控制</strong></td><td style="text-align:left">只能锁定“盒子”不换，不能锁“内容”</td><td style="text-align:left">深度锁定（C++ 的 const 语义更强）</td></tr></tbody></table></div><hr><h3 id="4-重点避坑：引用不变-vs-内容不变"><a href="#4-重点避坑：引用不变-vs-内容不变" class="headerlink" title="4. 重点避坑：引用不变 vs 内容不变"></a>4. 重点避坑：引用不变 vs 内容不变</h3><p>这是新手最容易掉坑的地方：<strong><code>final</code> 修饰对象时，只是锁定了“地址”，没锁定“属性”。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>user.setName(<span class="hljs-string">&quot;Jerry&quot;</span>); <span class="hljs-comment">// ✅ 允许！内容可以变</span><br><span class="hljs-comment">// user = new User(&quot;Jack&quot;); // ❌ 报错！不能把 user 指向新对象</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>javatomd 总结</strong>：</p><h2 id="C-等语言追求的是“数据的绝对不可变”（Const-correctness），而-Java-的-final-追求的是-“引用的稳定性”-和-“架构的安全性”。"><a href="#C-等语言追求的是“数据的绝对不可变”（Const-correctness），而-Java-的-final-追求的是-“引用的稳定性”-和-“架构的安全性”。" class="headerlink" title="C++ 等语言追求的是“数据的绝对不可变”（Const-correctness），而 Java 的 final 追求的是 “引用的稳定性” 和 “架构的安全性”。"></a>C++ 等语言追求的是“数据的绝对不可变”（Const-correctness），而 Java 的 <code>final</code> 追求的是 <strong>“引用的稳定性”</strong> 和 <strong>“架构的安全性”</strong>。</h2></blockquote><h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><ul><li><strong>固定配置</strong>：如数据库连接地址、API 的基础 URL。</li><li><strong>数学常数</strong>：如 $\pi$、自然对数 $e$ 等。</li><li><strong>业务逻辑限制</strong>：如订单的最大重试次数、用户的最小注册年龄。</li></ul><blockquote><p><strong>javatomd 总结</strong>：<br>记住一句话：<strong>在 Java 里想定义常量，请把 <code>final</code> 请出来，让 <code>const</code> 继续在角落里吃灰吧！</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo每次一定要“三件套”吗？</title>
    <link href="/2025/12/22/%E6%AF%8F%E6%AC%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E2%80%9C%E4%B8%89%E4%BB%B6%E5%A5%97%E2%80%9D%E5%90%97%EF%BC%9F/"/>
    <url>/2025/12/22/%E6%AF%8F%E6%AC%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E2%80%9C%E4%B8%89%E4%BB%B6%E5%A5%97%E2%80%9D%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>很多新手在开始使用 Hexo 时，习惯性地每次修改都执行 <code>hexo clean</code>, <code>hexo g</code>, <code>hexo s</code>。但在实际开发和写作中，这样做非常浪费时间。以下是根据不同场景推荐的最佳工作流，帮你把时间花在写作上，而不是等待编译。</p><h2 id="1-场景一：日常写文章-修改内容（最常见）"><a href="#1-场景一：日常写文章-修改内容（最常见）" class="headerlink" title="1. 场景一：日常写文章 / 修改内容（最常见）"></a>1. 场景一：日常写文章 / 修改内容（最常见）</h2><p><strong>场景描述</strong>：你在 <code>source/_posts</code> 下新建了一个 <code>.md</code>，或者修改了已有的文章内容、错别字。</p><ul><li><strong>是否需要三连？</strong>：<strong>完全不需要。</strong></li><li><strong>最佳操作</strong>：<ol><li>保持终端里的 <code>hexo s</code> 运行着不要关闭。</li><li>在编辑器里直接修改并保存 <code>.md</code> 文件。</li><li><strong>直接刷新浏览器页面</strong>。</li></ol></li><li><strong>原理</strong>：<code>hexo s</code> 带有“局部监听”功能，它会自动检测 <code>source</code> 文件夹的变化并实时渲染，速度极快。</li></ul><h2 id="2-场景二：修改了配置文件"><a href="#2-场景二：修改了配置文件" class="headerlink" title="2. 场景二：修改了配置文件"></a>2. 场景二：修改了配置文件</h2><p><strong>场景描述</strong>：你修改了根目录的 <code>_config.yml</code> 或主题的 <code>_config.fluid.yml</code>（例如改了网站标题、换了封面图路径）。</p><ul><li><strong>是否需要三连？</strong>：<strong>建议重启并 Clean。</strong></li><li><strong>最佳操作</strong>：<ol><li>在终端按下 <code>Ctrl + C</code> 关闭当前预览服务。</li><li>执行 <code>hexo clean</code>（确保清除旧的配置缓存）。</li><li>执行 <code>hexo s</code> 重新启动。</li></ol></li><li><strong>原理</strong>：配置文件只在服务器启动的一瞬间被读取，热重载通常无法捕捉到这些全局参数的变化。</li></ul><h2 id="3-场景三：删除了文件或移动了文件夹"><a href="#3-场景三：删除了文件或移动了文件夹" class="headerlink" title="3. 场景三：删除了文件或移动了文件夹"></a>3. 场景三：删除了文件或移动了文件夹</h2><p><strong>场景描述</strong>：你删除了某篇旧文章，或者把 <code>source/img</code> 里的图片重命名了。</p><ul><li><strong>是否需要三连？</strong>：<strong>必须执行。</strong></li><li><strong>原因</strong>：如果不执行 <code>clean</code>，<code>public</code>（生成的静态文件夹）里还会残留以前生成的旧文件。这会导致预览时出现已经删掉的文章依然存在，或者图片出现 404 的情况。</li></ul><h2 id="4-场景四：发布到正式环境（如-GitHub-Pages）"><a href="#4-场景四：发布到正式环境（如-GitHub-Pages）" class="headerlink" title="4. 场景四：发布到正式环境（如 GitHub Pages）"></a>4. 场景四：发布到正式环境（如 GitHub Pages）</h2><p><strong>场景描述</strong>：你在本地预览一切完美，准备部署上线。</p><ul><li><strong>最佳操作</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo d  <span class="hljs-comment"># 部署命令</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="⚡-提高效率的小技巧"><a href="#⚡-提高效率的小技巧" class="headerlink" title="⚡ 提高效率的小技巧"></a>⚡ 提高效率的小技巧</h2><h3 id="1-复合命令"><a href="#1-复合命令" class="headerlink" title="1. 复合命令"></a>1. 复合命令</h3><p>你可以用 <code>&amp;&amp;</code> 符号把命令连起来，输入一次回车，电脑会自动按顺序执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改了配置想重启预览</span><br>hexo clean &amp;&amp; hexo s<br><br><span class="hljs-comment"># 准备一键部署</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure></p><h3 id="2-什么时候才必须用-clean？"><a href="#2-什么时候才必须用-clean？" class="headerlink" title="2. 什么时候才必须用 clean？"></a>2. 什么时候才必须用 <code>clean</code>？</h3><ul><li><p>修改了主题的源码（如 CSS 或 JS 文件）。</p></li><li><p>发现网页显示莫名其妙。</p></li><li><p>在准备提交发布（<code>hexo d</code>）之前。</p></li></ul><hr><p><strong>总结</strong>：<strong>写文只需 <code>Ctrl + S</code> + 刷新；改配置才需要 <code>Clean</code> 重启。</strong> </p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>教程</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 主题更换Fluid</title>
    <link href="/2025/12/22/%E6%9B%B4%E6%8D%A2Fluid%E4%B8%BB%E9%A2%98/"/>
    <url>/2025/12/22/%E6%9B%B4%E6%8D%A2Fluid%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天对 Hexo 博客进行了“大整容”，将默认主题更换为了 <strong>Fluid</strong>。过程中由于安装方式和文件路径问题踩了不少坑，现将完整的更换流程与解决方案总结如下。</p><h2 id="1-主题更换流程"><a href="#1-主题更换流程" class="headerlink" title="1 主题更换流程"></a>1 主题更换流程</h2><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">主题官网</a></p><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 安装主题</h3><p>按照官网教程，Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><br>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><h3 id="1-2-配置文件初始化"><a href="#1-2-配置文件初始化" class="headerlink" title="1.2. 配置文件初始化"></a>1.2. 配置文件初始化</h3><p>由于 <code>themes</code> 文件夹为空，需要在博客根目录下手动创建 <strong><code>_config.fluid.yml</code></strong>。<br><strong>关键点</strong>：可以前往 Fluid 官方 GitHub 仓库复制完整的<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">配置模板内容</a>并粘贴进 <strong><code>_config.fluid.yml</code></strong>。</p><h2 id="2-标题修改"><a href="#2-标题修改" class="headerlink" title="2. 标题修改"></a>2. 标题修改</h2><p>标题分为三个层级：浏览器标签页标题、导航栏文字、封面大标题。</p><h3 id="2-1-浏览器标签页标题-Browser-Tab-Title"><a href="#2-1-浏览器标签页标题-Browser-Tab-Title" class="headerlink" title="2.1 浏览器标签页标题 (Browser Tab Title)"></a>2.1 浏览器标签页标题 (Browser Tab Title)</h3><p>这是显示在浏览器最顶端标签上的文字。</p><ul><li><strong>修改文件</strong>：根目录下的 <code>_config.yml</code> (全局配置)。</li><li><strong>操作</strong>：修改 <code>title</code> 字段。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># _config.yml</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">大雪深埋</span>  <span class="hljs-comment"># 这里的修改会直接改变浏览器标签页显示的内容</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="3-首页封面-Banner-修改"><a href="#3-首页封面-Banner-修改" class="headerlink" title="3. 首页封面 (Banner) 修改"></a>3. 首页封面 (Banner) 修改</h2><h3 id="3-1-封面背景图修改-banner-img"><a href="#3-1-封面背景图修改-banner-img" class="headerlink" title="3.1 封面背景图修改 (banner_img)"></a>3.1 封面背景图修改 (banner_img)</h3><p>这是最容易踩坑的地方，涉及路径和存放位置。</p><ul><li><strong>正确存放</strong>：将图片放入 <code>source/img/</code>（例如 <code>guts.png</code>）。</li><li><strong>路径配置</strong>：在 <code>_config.fluid.yml</code> 中搜索 <code>banner_img</code>。</li><li><strong>注意事项</strong>：必须使用<strong>正斜杠 <code>/</code></strong>。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># _config.fluid.yml</span><br><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/guts.png</span>  <span class="hljs-comment"># 路径必须从 /img 开始</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-问题——封面图消失"><a href="#4-问题——封面图消失" class="headerlink" title="4.问题——封面图消失"></a>4.问题——封面图消失</h2><p>在配置 <code>banner_img</code> 封面图时遇到了图片在预览时消失的问题，总结原因如下：</p><ul><li><strong>存放路径错误</strong>：图片不能直接放在 <code>public</code> 文件夹中，因为每次执行 <code>hexo clean</code> 时，该文件夹都会被清空。</li><li><strong>正确位置</strong>：必须将图片存放在 <strong><code>source/img/</code></strong> 文件夹下，由 Hexo 编译后自动同步到 public 目录。</li><li><strong>路径语法限制</strong>：在配置文件中，路径必须使用<strong>正斜杠 <code>/</code></strong>（例如 <code>/img/guts.png</code>），不能使用 Windows 风格的反斜杠 <code>\</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo和GitHub搭建博客全记录</title>
    <link href="/2025/12/21/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/12/21/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>确保你的电脑环境已经安装了以下软件：</p><ul><li><strong>Node.js</strong>: 建议安装 LTS 版本。</li><li><strong>Git</strong>: 用于将代码推送到 GitHub。</li></ul><h2 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h2><p>在终端依次输入以下命令进行初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全局安装脚手架</span><br>npm install -g hexo-cli<br><br><span class="hljs-comment"># 初始化项目文件夹</span><br>hexo init myblog<br><span class="hljs-built_in">cd</span> myblog<br><br><span class="hljs-comment"># 安装依赖</span><br>npm install<br></code></pre></td></tr></table></figure><h2 id="3-联动-GitHub-关键步骤"><a href="#3-联动-GitHub-关键步骤" class="headerlink" title="3. 联动 GitHub (关键步骤)"></a>3. 联动 GitHub (关键步骤)</h2><p>在本地搭建好 Hexo 后，需要通过以下配置将其发布到 GitHub。</p><h3 id="3-1-创建-GitHub-仓库"><a href="#3-1-创建-GitHub-仓库" class="headerlink" title="3.1 创建 GitHub 仓库"></a>3.1 创建 GitHub 仓库</h3><ol><li><p>登录 GitHub，新建一个仓库（New repository）。</p></li><li><p><strong>仓库名（Repository Name）</strong> 必须填：<code>你的用户名.github.io</code>。</p></li><li><p>确保仓库设为 <strong>Public</strong>。</p></li></ol><h3 id="3-2-安装-Git-部署插件"><a href="#3-2-安装-Git-部署插件" class="headerlink" title="3.2 安装 Git 部署插件"></a>3.2 安装 Git 部署插件</h3><p>在你的博客根目录（<code>myblog</code>）下运行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="3-3-修改站点配置文件"><a href="#3-3-修改站点配置文件" class="headerlink" title="3.3 修改站点配置文件"></a>3.3 修改站点配置文件</h3><p>打开目录下的 <code>_config.yml</code> 文件，拉到最底部，修改 <code>deploy</code> 部分：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:你的用户名/你的用户名.github.io.git<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：YAML 格式要求冒号 <code>:</code> 后必须留一个空格。建议使用 SSH 链接以避免频繁输入密码。</p></blockquote><h2 id="4-遇到的坑与解决方法"><a href="#4-遇到的坑与解决方法" class="headerlink" title="4. 遇到的坑与解决方法"></a>4. 遇到的坑与解决方法</h2><h3 id="问题一：无法连接-GitHub"><a href="#问题一：无法连接-GitHub" class="headerlink" title="问题一：无法连接 GitHub"></a>问题一：无法连接 GitHub</h3><p>报错信息：fatal: unable to access … Failed to connect to port 443</p><p>解决方法：</p><p>这是因为网络问题导致无法直接访问 GitHub。如果你有代理服务器（例如端口是 10808），可以设置 Git 全局代理：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-selector-attr">[http://127.0.0.1:10808]</span>(http:<span class="hljs-comment">//127.0.0.1:10808)</span><br>git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-selector-attr">[https://127.0.0.1:10808]</span>(https:<span class="hljs-comment">//127.0.0.1:10808)</span><br></code></pre></td></tr></table></figure><h3 id="问题二：部署后-404-或样式乱码"><a href="#问题二：部署后-404-或样式乱码" class="headerlink" title="问题二：部署后 404 或样式乱码"></a>问题二：部署后 404 或样式乱码</h3><p><strong>原因</strong>：</p><ol><li><p>仓库设为了 Private（私有）。</p></li><li><p>_config.yml 中的 url 配置不正确。</p><p> 解决方法：</p></li><li><p>进入 GitHub 仓库 Settings -&gt; Danger Zone -&gt; Change visibility，改为 <strong>Public</strong>。</p></li><li><p>检查 <code>_config.yml</code> 中的 <code>url</code> 是否填写的为 <code>https://你的用户名.github.io</code>。</p></li></ol><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5. 常用命令"></a>5. 常用命令</h2><p>每次更新博客只需要这三步：</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>命令</strong></td><td><strong>作用</strong></td><td><strong>简写</strong></td></tr><tr><td><code>hexo clean</code></td><td>清除缓存（推荐部署前执行）</td><td>无</td></tr><tr><td><code>hexo generate</code></td><td>生成静态网页文件</td><td><code>hexo g</code></td></tr><tr><td><code>hexo server</code></td><td>启动本地预览（localhost:4000）</td><td><code>hexo s</code></td></tr><tr><td><code>hexo deploy</code></td><td>推送到 GitHub 线上</td><td><code>hexo d</code></td></tr></tbody></table></div><p><strong>标准发布流程：</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
