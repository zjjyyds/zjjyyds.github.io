<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OCF Linux System Administration DeCal lab5</title>
    <link href="/2026/02/10/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20lab5/"/>
    <url>/2026/02/10/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20lab5/</url>
    
    <content type="html"><![CDATA[<h1 id="实验-5：网络基础介绍（Introduction-to-Networking）"><a href="#实验-5：网络基础介绍（Introduction-to-Networking）" class="headerlink" title="实验 5：网络基础介绍（Introduction to Networking）"></a>实验 5：网络基础介绍（Introduction to Networking）</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#%E6%A6%82%E8%A7%88-overview">概览（Overview）</a></p></li><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#mac">MAC</a></p><ul><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#ip">IP</a></p></li><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#arp">ARP</a></p></li><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#dns">DNS</a></p></li><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#dns-%E8%AE%B0%E5%BD%95">DNS 记录</a></p></li><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#tcp-%E4%B8%8E-udp">TCP 与 UDP</a></p></li><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#%E7%AB%AF%E5%8F%A3%E5%8F%AF%E9%80%89">端口（可选）</a></p></li></ul></li><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%98%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-sysadmin-commands">系统管理员常用命令（Sysadmin Commands）</a></p></li><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#%E7%BB%83%E4%B9%A0-exercises">练习（Exercises）</a></p><ul><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#%E7%AE%80%E7%AD%94%E9%A2%98-short-answer-questions">简答题（Short Answer Questions）</a></p></li><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0-programming-exercise">编程练习（Programming Exercise）</a></p></li><li><p><a href="https://chatgpt.com/c/698af942-2640-83a6-8b24-bcad3252de76#%E6%8F%90%E4%BA%A4-submission">提交（Submission）</a></p></li></ul></li></ul><hr><h2 id="概览（Overview）"><a href="#概览（Overview）" class="headerlink" title="概览（Overview）"></a>概览（Overview）</h2><p>不可否认，互联网是一个重新定义了我们世界的重要系统。<strong>构建网络并让设备之间能够通信</strong>，是现代计算机系统中的关键能力。</p><p>本实验将从<strong>计算机网络的基础概念</strong>入手，并从<strong>系统管理员（sysadmin）</strong>的视角来理解网络。</p><p>我们将以<strong>浏览网页</strong>作为类比，来理解网络的基本工作方式。<br>当我去网上浏览猫咪图片时，<strong>背后到底发生了什么？</strong></p><p>在此之前，我们先对网络的细节做一个简要的介绍。</p><hr><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p><strong>媒体访问控制地址（Media Access Control，MAC）</strong> 是唯一分配给网络接口的标识符。</p><p>MAC 地址由于具有唯一性，通常被称为<strong>物理地址</strong>。<br>它由若干个 <strong>8 位字节（octet）</strong> 组成，通常使用<strong>十六进制</strong>表示，并用冒号分隔。</p><p>示例 MAC 地址：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span>:<span class="hljs-number">14</span>:<span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">23</span>:<span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p>其中<strong>前 3 个字节</strong>称为 <strong>OUI（Organizationally Unique Identifier，组织唯一标识符）</strong>，可用于识别设备制造商。<br>一个有趣的事实是：上面例子中的 <code>00:14:22</code> 是 <strong>Dell</strong> 的 OUI。</p><hr><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p><strong>IP 地址</strong>用于在互联网协议（Internet Protocol）下标识网络中的设备。</p><p>目前主要存在两种 IP 协议版本：</p><ul><li><p><strong>IPv4</strong></p></li><li><p><strong>IPv6</strong></p></li></ul><p>它们的主要区别在于<strong>地址长度不同</strong>。</p><p>示例 IPv6 地址：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2001</span>:<span class="hljs-number">0</span>db8:<span class="hljs-number">85</span>a3:<span class="hljs-number">0000</span>:<span class="hljs-number">0000</span>:<span class="hljs-number">8</span>a2e:<span class="hljs-number">0370</span>:<span class="hljs-number">7334</span><br></code></pre></td></tr></table></figure><p>它明显比 IPv4 地址（如 <code>127.0.0.1</code>）要长得多。</p><p>由于时间有限，本实验只介绍 <strong>IPv4</strong>，但 IPv6 正在逐渐普及，非常值得你自行了解。</p><hr><h3 id="IPv4-基础"><a href="#IPv4-基础" class="headerlink" title="IPv4 基础"></a>IPv4 基础</h3><ul><li><p>IPv4 地址长度为 <strong>32 位（4 字节）</strong></p></li><li><p>每个字节用 <code>.</code> 分隔</p></li></ul><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span><br></code></pre></td></tr></table></figure><p>这个地址被称为 <strong>回环地址（loopback address）</strong>，它映射到本机的回环接口，使得<strong>同一台机器上的网络应用可以彼此通信</strong>。</p><p>但为什么是 <code>127.0.0.1</code>，而不是 <code>127.0.0.0</code> 或 <code>127.0.0.2</code>？</p><p>答案是：<br><code>127.0.0.1</code> 只是<strong>约定俗成的写法</strong>。<br>事实上，整个 <code>127.0.0.0/8</code> 网段中的任意地址，都是合法的回环地址。</p><hr><h3 id="子网与-CIDR"><a href="#子网与-CIDR" class="headerlink" title="子网与 CIDR"></a>子网与 CIDR</h3><p>在 IPv4 中，我们可以将一段地址划分为一个<strong>子网（subnet）</strong>，使用 <strong>CIDR 表示法</strong>。</p><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.0</span>/<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><ul><li><p><code>/8</code> 表示 <strong>子网掩码长度</strong></p></li><li><p>前 8 位是<strong>网络位</strong></p></li><li><p>剩余位是<strong>主机位</strong></p></li></ul><p>在这个例子中：</p><ul><li><p>网络地址：<code>127.0.0.0</code></p></li><li><p>子网掩码：<code>255.0.0.0</code></p></li><li><p><code>127.0.0.1</code> 是该网络中的第一个主机地址</p></li></ul><hr><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p><strong>地址解析协议（Address Resolution Protocol，ARP）</strong> 用于将 <strong>IP 地址解析为 MAC 地址</strong>。</p><p>在理解 ARP 前，先区分两种二层通信方式：</p><ul><li><p><strong>单播（Unicast）</strong>：发送给某一个 MAC 地址</p></li><li><p><strong>广播（Broadcast）</strong>：发送给广播地址，局域网内所有设备都会收到</p></li></ul><hr><h3 id="ARP-工作示例"><a href="#ARP-工作示例" class="headerlink" title="ARP 工作示例"></a>ARP 工作示例</h3><p>假设设备 A：</p><ul><li>MAC：<code>00:DE:AD:BE:EF:00</code></li></ul><p>A 在网络中广播：</p><blockquote><p>“谁拥有 IP 地址 <code>42.42.42.42</code>？请告诉 MAC 为 <code>00:DE:AD:BE:EF:00</code> 的我。”</p></blockquote><p>如果设备 B：</p><ul><li><p>IP：<code>42.42.42.42</code></p></li><li><p>MAC：<code>12:34:56:78:9a:bc</code></p></li></ul><p>那么 B 会向 A <strong>单播回复</strong>：</p><blockquote><p>“IP <code>42.42.42.42</code> 对应的 MAC 是 <code>12:34:56:78:9a:bc</code>。”</p></blockquote><p>A 会将该信息存入 <strong>ARP 表</strong>，以后再向 <code>42.42.42.42</code> 发送数据时，就直接使用对应的 MAC 地址。</p><hr><h3 id="路由表（Routing-Table）"><a href="#路由表（Routing-Table）" class="headerlink" title="路由表（Routing Table）"></a>路由表（Routing Table）</h3><p>为了转发 IP 数据包，设备维护一张 <strong>路由表</strong>，其中的每一条记录描述：</p><ul><li><p>一个子网</p></li><li><p>对应的出口接口</p></li></ul><p>设备会选择<strong>最精确匹配</strong>目标 IP 的路由规则。</p><p>路由表通常还包含一个 <strong>默认网关（default gateway）</strong>，用于兜底匹配。</p><p>示例路由表：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">default via 10.0.2.2 dev eth0<br>10.0.2.0/24 dev eth0<br>10.0.2.128/25 dev eth0<br>192.168.162.0/24 dev eth1<br></code></pre></td></tr></table></figure><ul><li><p><code>8.8.8.8</code> → 默认路由 → <code>eth0</code></p></li><li><p><code>10.0.2.1</code> → 第二条规则 → <code>eth0</code></p></li><li><p><code>10.0.2.254</code> → 第三条规则 → <code>eth0</code></p></li><li><p><code>192.168.162.254</code> → 第四条规则 → <code>eth1</code></p></li></ul><hr><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>IP 地址对机器友好，但对人类并不友好。</p><p>相比记住一串数字，我们更容易记住：</p><ul><li><p><code>www.google.com</code></p></li><li><p><code>www.facebook.com</code></p></li><li><p><code>coolmath-games.com</code></p></li></ul><p>因此诞生了 <strong>域名系统（Domain Name System，DNS）</strong>，用于在<strong>域名与 IP 地址之间建立映射关系</strong>。</p><p>当你查询 <code>google.com</code> 时：</p><ol><li><p>计算机会向 DNS 服务器发送查询</p></li><li><p>DNS 返回权威结果</p></li><li><p>告诉你：<code>google.com → x.x.x.x</code></p></li></ol><hr><h2 id="DNS-记录"><a href="#DNS-记录" class="headerlink" title="DNS 记录"></a>DNS 记录</h2><p>DNS 服务器以 <strong>资源记录（Resource Record, RR）</strong> 的形式存储数据：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-built_in">name</span></span><span class="hljs-punctuation">,</span> value<span class="hljs-punctuation">,</span> type<span class="hljs-punctuation">,</span> TTL)<br></code></pre></td></tr></table></figure><ul><li><strong>TTL（Time To Live）</strong>：记录可被缓存的时间（秒）</li></ul><p>常见 DNS 记录类型：</p><ol><li><p><strong>A 记录</strong></p><ul><li>主机名 → IP 地址</li></ul></li><li><p><strong>NS 记录</strong></p><ul><li>指向负责该域名的 DNS 服务器</li></ul></li><li><p><strong>CNAME 记录</strong></p><ul><li><p>别名 → 规范名称</p></li><li><p>如 <code>docs.google.com → documents.google.com</code></p></li></ul></li><li><p><strong>MX 记录</strong></p><ul><li>邮件服务器记录</li></ul></li></ol><hr><h2 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li><p><strong>面向连接</strong></p></li><li><p><strong>可靠传输</strong></p></li><li><p><strong>按序到达</strong></p></li></ul><p>TCP 通过 <strong>三次握手</strong> 建立连接：</p><ol><li><p>客户端发送 <code>SYN</code></p></li><li><p>服务器回复 <code>SYN + ACK</code></p></li><li><p>客户端回复 <code>ACK</code></p></li></ol><p>之后才开始数据传输。<br>如果数据丢失、乱序或损坏，TCP 会请求重传。</p><p><strong>连接关闭（优雅终止）</strong> 使用 <code>FIN / ACK</code> 机制完成。</p><hr><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li><p><strong>无连接</strong></p></li><li><p><strong>无状态</strong></p></li><li><p><strong>不保证可靠性</strong></p></li></ul><p>UDP 不需要建立或关闭连接，<strong>开销小、速度快</strong>，但：</p><ul><li><p>可能丢包</p></li><li><p>可能乱序</p></li><li><p>可能损坏</p></li></ul><p>因此适合：</p><ul><li><p>音视频</p></li><li><p>游戏</p></li><li><p>实时通信</p></li></ul><hr><h2 id="端口（可选）"><a href="#端口（可选）" class="headerlink" title="端口（可选）"></a>端口（可选）</h2><ul><li><p>端口用于标识 <strong>主机上的进程</strong></p></li><li><p>IP 定位主机，端口定位服务</p></li><li><p>端口范围：<code>0 – 65535</code></p></li></ul><p>端口分类：</p><ul><li><p><code>0–1023</code>：知名端口</p></li><li><p><code>1024–49151</code>：注册端口</p></li><li><p><code>49152–65535</code>：临时端口</p></li></ul><p>常见端口：</p><div class="table-container"><table><thead><tr><th>服务</th><th>端口</th></tr></thead><tbody><tr><td>SSH</td><td>22</td></tr><tr><td>DNS</td><td>53</td></tr><tr><td>HTTP</td><td>80</td></tr><tr><td>HTTPS</td><td>443</td></tr></tbody></table></div><hr><h2 id="系统管理员常用命令（Sysadmin-Commands）"><a href="#系统管理员常用命令（Sysadmin-Commands）" class="headerlink" title="系统管理员常用命令（Sysadmin Commands）"></a>系统管理员常用命令（Sysadmin Commands）</h2><p>用于<strong>排查与诊断网络问题</strong>，不要求死记硬背，但要知道<strong>什么时候该用什么工具</strong>。</p><p>常见工具包括：</p><ul><li><p><code>hostname</code></p></li><li><p><code>ping</code></p></li><li><p><code>traceroute</code></p></li><li><p><code>arp</code></p></li><li><p><code>dig</code></p></li><li><p><code>ip</code></p></li><li><p><code>curl</code></p></li><li><p><code>wget</code></p></li><li><p><code>netstat</code>（可选）</p></li><li><p><code>tcpdump</code>（可选）</p></li><li><p><code>nc</code>（可选）</p></li></ul><hr><h2 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a><code>hostname</code></h2><p><strong>用途：</strong> 查看（或设置）当前主机的名字</p><p><strong>常用：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hostname<br></code></pre></td></tr></table></figure><p>输出当前主机名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hostname -I<br></code></pre></td></tr></table></figure><p>显示本机的 IP 地址（常用来快速看有没有拿到 IP）</p><hr><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a><code>ping</code></h2><p><strong>用途：</strong> 测试网络连通性（ICMP）</p><p><strong>常用：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping google.com<br></code></pre></td></tr></table></figure><p>持续 ping（Ctrl+C 结束）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping -c 1 google.com<br></code></pre></td></tr></table></figure><p>只 ping 一次（脚本里常用）</p><p><strong>看什么：</strong></p><ul><li>是否有回复（能不能通）</li><li>延迟（RTT）</li><li>丢包率</li></ul><hr><h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a><code>traceroute</code></h2><p><strong>用途：</strong> 查看数据包经过了哪些路由器</p><p><strong>常用：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">traceroute google.com<br></code></pre></td></tr></table></figure><p><strong>你能看到：</strong></p><ul><li>每一跳的路由器</li><li>哪一跳开始超时（<code>* * *</code>）</li></ul><p>👉 用来定位<strong>网络在哪一段断了</strong></p><hr><h2 id="arp"><a href="#arp" class="headerlink" title="arp"></a><code>arp</code></h2><p><strong>用途：</strong> 查看 / 管理 IP ↔ MAC 映射表（ARP 表）</p><p><strong>常用：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">arp -a<br></code></pre></td></tr></table></figure><p>查看当前 ARP 缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">arp -n<br></code></pre></td></tr></table></figure><p>不做 DNS 解析，更清晰</p><p>👉 用于排查 <strong>局域网通信问题</strong></p><p>现在不用arp<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ip neigh</span><br></code></pre></td></tr></table></figure></p><hr><h2 id="dig"><a href="#dig" class="headerlink" title="dig"></a><code>dig</code></h2><p><strong>用途：</strong> DNS 查询神器（比 <code>nslookup</code> 强）</p><p><strong>常用：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dig google.com<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">dig google.com A<br>dig google.com NS<br></code></pre></td></tr></table></figure><p><strong>看什么：</strong></p><ul><li>A 记录（IP）</li><li>NS（权威 DNS）</li><li>TTL</li><li>查询是否成功</li></ul><p>👉 DNS 出问题第一时间用它</p><hr><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a><code>ip</code></h2><p><strong>用途：</strong> 网络全家桶（接口 / IP / 路由）</p><p><strong>最常用的 3 个：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip addr<br></code></pre></td></tr></table></figure><p>查看 IP 地址和网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><p>查看网络接口状态（UP / DOWN）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip route<br></code></pre></td></tr></table></figure><p>查看路由表（默认网关在哪）</p><p>👉 <code>ifconfig</code>、<code>route</code> 的现代替代品</p><hr><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a><code>curl</code></h2><p><strong>用途：</strong> 向服务器发送请求、查看返回内容</p><p><strong>常用：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl https://example.com<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -I https://example.com<br></code></pre></td></tr></table></figure><p>只看 HTTP 响应头（状态码）</p><p>👉 用来判断：</p><ul><li>Web 服务在不在</li><li>返回码是不是 200 / 404 / 500</li></ul><hr><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a><code>wget</code></h2><p><strong>用途：</strong> 下载文件（偏“下载工具”）</p><p><strong>常用：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://example.com/file.zip<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -r https://example.com<br></code></pre></td></tr></table></figure><p>递归下载（curl 做不到）</p><p>👉 批量下载 / 镜像网站常用</p><hr><h2 id="netstat（可选）"><a href="#netstat（可选）" class="headerlink" title="netstat（可选）"></a><code>netstat</code>（可选）</h2><p><strong>用途：</strong> 查看端口、连接、监听状态</p><p><strong>常用：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -tuln<br></code></pre></td></tr></table></figure><ul><li><code>t</code> TCP</li><li><code>u</code> UDP</li><li><code>l</code> 监听</li><li><code>n</code> 数字形式（不解析 DNS）</li></ul><p>👉 用来检查：</p><ul><li>服务有没有在监听端口</li><li>端口是不是被占用</li></ul><p>（现代系统常用 <code>ss</code> 替代）</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ss -tuln</span><br></code></pre></td></tr></table></figure></h2><h2 id="tcpdump（可选）"><a href="#tcpdump（可选）" class="headerlink" title="tcpdump（可选）"></a><code>tcpdump</code>（可选）</h2><p><strong>用途：</strong> 抓包（非常强，但偏进阶）</p><p><strong>常用：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcpdump -i eth0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcpdump -i eth0 port 80<br></code></pre></td></tr></table></figure><p>👉 用来：</p><ul><li>看“数据包到底有没有来”</li><li>排查诡异网络问题</li></ul><p>⚠️ 一般需要 root</p><hr><h2 id="nc（netcat，可选）"><a href="#nc（netcat，可选）" class="headerlink" title="nc（netcat，可选）"></a><code>nc</code>（netcat，可选）</h2><p><strong>用途：</strong> 网络瑞士军刀（测试 TCP / UDP）</p><p><strong>常用：</strong></p><p>监听端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -l 1234<br></code></pre></td></tr></table></figure><p>连接端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc localhost 1234<br></code></pre></td></tr></table></figure><p>👉 用来：</p><ul><li>测试端口是否能连</li><li>临时搭建简单通信</li></ul><hr><h2 id="一张「该用哪个？」速查表"><a href="#一张「该用哪个？」速查表" class="headerlink" title="一张「该用哪个？」速查表"></a>一张「该用哪个？」速查表</h2><div class="table-container"><table><thead><tr><th>场景</th><th>用哪个</th></tr></thead><tbody><tr><td>看 IP / 网卡</td><td><code>ip addr</code></td></tr><tr><td>能不能通</td><td><code>ping</code></td></tr><tr><td>哪一跳断了</td><td><code>traceroute</code></td></tr><tr><td>DNS 有没有问题</td><td><code>dig</code></td></tr><tr><td>网页服务在不在</td><td><code>curl</code></td></tr><tr><td>端口监听情况</td><td><code>netstat</code> / <code>ss</code></td></tr><tr><td>局域网 MAC</td><td><code>arp</code></td></tr><tr><td>抓包</td><td><code>tcpdump</code></td></tr><tr><td>测试端口</td><td><code>nc</code></td></tr></tbody></table></div><hr><hr><h2 id="练习（Exercises）"><a href="#练习（Exercises）" class="headerlink" title="练习（Exercises）"></a>练习（Exercises）</h2><h3 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h3><ol><li><p>HTTP 使用 TCP 还是 UDP？为什么？Discord 和 Skype 呢？</p></li><li><p>MAC 地址 <code>dc:fb:48:21:7b:23</code> 的网卡厂商是谁？</p></li><li><p><code>127.0.0.0/8</code> 可以容纳多少主机？</p></li><li><p>使用 <code>dig google.com</code> 可以得到哪三种 DNS 记录？</p></li><li><p>仅凭 <code>ping</code> 能否判断服务器是否可达？为什么？</p></li></ol><hr><h3 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h3><ol><li><p>编写脚本 <code>is_on.sh</code></p><ul><li><p>成功 ping：输出 <code>OK</code></p></li><li><p>失败：输出 <code>Host is not reachable</code></p></li></ul></li><li><p>编写脚本 <code>mac.sh</code></p><ul><li><p>使用 <code>ip</code>、<code>head</code>、<code>tail</code>、<code>cut</code></p></li><li><p>提取 <code>ens3</code> 接口的 MAC 地址</p></li></ul></li></ol><hr><h2 id="提交（Submission）"><a href="#提交（Submission）" class="headerlink" title="提交（Submission）"></a>提交（Submission）</h2><p>前往 <strong>Gradescope</strong> 提交作业。</p><hr><h2 id="简答题-1"><a href="#简答题-1" class="headerlink" title="简答题"></a>简答题</h2><p><strong>1. HTTP 使用 TCP 还是 UDP？为什么？Discord 和 Skype 呢？</strong></p><ul><li><p><strong>HTTP 使用 TCP</strong></p><ul><li>因为网页和文件传输要求<strong>可靠性和顺序性</strong></li><li>TCP 能保证数据不丢失、按顺序到达</li></ul></li><li><p><strong>Discord、Skype 主要使用 UDP</strong></p><ul><li>实时语音/视频更关注<strong>低延迟</strong></li><li>少量丢包可以接受，但延迟不可接受</li><li>通常在 UDP 之上实现自己的纠错和控制机制</li></ul></li></ul><hr><p><strong>2. MAC 地址 <code>dc:fb:48:21:7b:23</code> 的网卡厂商是谁？</strong></p><ul><li>MAC 前 3 个字节（OUI）是 <code>dc:fb:48</code></li><li>对应厂商是 <strong>Intel Corporation</strong></li></ul><hr><p><strong>3. <code>127.0.0.0/8</code> 可以容纳多少主机？</strong></p><ul><li><p><code>/8</code> 表示网络位 8 位，主机位 24 位</p></li><li><p>主机数量为：</p><p>2²⁴ = <strong>16,777,216</strong></p></li><li><p>该网段全部用于 <strong>loopback（回环地址）</strong></p></li></ul><hr><p><strong>4. 使用 <code>dig google.com</code> 可以得到哪三种 DNS 记录？</strong></p><p>常见的三种是：</p><ul><li><strong>A 记录</strong>：域名 → IPv4 地址</li><li><strong>NS 记录</strong>：域名的权威 DNS 服务器</li><li><strong>CNAME 记录</strong>：域名别名映射</li></ul><p>（实际还可能看到 MX、AAAA 等）</p><hr><p><strong>5. 仅凭 <code>ping</code> 能否判断服务器是否可达？为什么？</strong></p><ul><li><strong>不能</strong></li><li><p>因为：</p><ul><li>服务器可能禁用了 ICMP（ping 失败但服务正常）</li><li>ping 只能测试<strong>网络层连通性</strong></li><li>无法判断应用层服务是否可用（如 HTTP、SSH）</li></ul></li></ul><hr><h2 id="编程练习-1"><a href="#编程练习-1" class="headerlink" title="编程练习"></a>编程练习</h2><p><strong>1. <code>is_on.sh</code> 脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping -c 1 <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> &gt; /dev/null 2&gt;&amp;1<br><br><span class="hljs-keyword">if</span> [ $? -eq 0 ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;OK&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Host is not reachable&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><hr><p><strong>2. <code>mac.sh</code> 脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip <span class="hljs-built_in">link</span> show ens3 | <span class="hljs-built_in">head</span> -n 2 | <span class="hljs-built_in">tail</span> -n 1 | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27; &#x27;</span> -f 6<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LSAD</tag>
      
      <tag>lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OCF Linux System Administration DeCal note5</title>
    <link href="/2026/02/10/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20note5/"/>
    <url>/2026/02/10/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20note5/</url>
    
    <content type="html"><![CDATA[<h2 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h2><h3 id="1-为什么需要网络"><a href="#1-为什么需要网络" class="headerlink" title="1. 为什么需要网络"></a>1. 为什么需要网络</h3><ul><li><p>网络让<strong>多台计算机通信与共享资源</strong>成为可能</p></li><li><p>支持文件共享、远程访问、分布式服务和互联网应用</p></li><li><p>本质目标：<strong>在不同设备之间可靠地传递数据</strong></p></li></ul><hr><h3 id="2-网络地址基础"><a href="#2-网络地址基础" class="headerlink" title="2. 网络地址基础"></a>2. 网络地址基础</h3><ul><li><p><strong>MAC 地址</strong></p><ul><li><p>物理层面的设备唯一标识（如 <code>00:14:22:01:2a:c5</code>）</p></li><li><p>只在<strong>局域网（LAN）</strong>内使用，和硬件绑定</p></li><li><p>类比：人的身份证号</p></li></ul></li><li><p><strong>IP 地址（IPv4）</strong></p><ul><li><p>逻辑地址（如 <code>169.229.226.164</code>），可配置、可变化</p></li><li><p>用于跨网络通信</p></li><li><p>类比：家庭住址</p></li></ul></li><li><p><strong>DNS</strong></p><ul><li><p>将<strong>人类可读域名 → IP 地址</strong></p></li><li><p>访问网站的第一步（如 <code>example.com → IP</code>）</p></li></ul></li></ul><hr><h3 id="3-子网与-IPv6（概念了解）"><a href="#3-子网与-IPv6（概念了解）" class="headerlink" title="3. 子网与 IPv6（概念了解）"></a>3. 子网与 IPv6（概念了解）</h3><ul><li><p><strong>子网（Subnet）</strong></p><ul><li><p>使用 CIDR 表示法，如 <code>192.168.1.0/24</code></p></li><li><p><code>/24</code> 表示网络前缀长度，其余为主机位</p></li></ul></li><li><p><strong>IPv6</strong></p><ul><li><p>128 位地址，解决 IPv4 地址耗尽问题</p></li><li><p>数量极其庞大，长期替代方案</p></li></ul></li></ul><hr><h3 id="4-TCP-IP-四层模型（重点）"><a href="#4-TCP-IP-四层模型（重点）" class="headerlink" title="4. TCP/IP 四层模型（重点）"></a>4. TCP/IP 四层模型（重点）</h3><blockquote><p>网络通信的核心抽象模型</p></blockquote><ol><li><p><strong>Link（链路层）</strong></p><ul><li><p>使用 MAC 地址通信</p></li><li><p>局域网内通过交换机转发</p></li><li><p>ARP：IP → MAC</p></li></ul></li><li><p><strong>Internet（网络层）</strong></p><ul><li><p>使用 IP 地址进行<strong>跨网络路由</strong></p></li><li><p>数据经过路由器转发</p></li></ul></li><li><p><strong>Transport（传输层）</strong></p><ul><li><p>提供端到端通信机制</p></li><li><p>处理丢包、顺序、可靠性</p></li></ul></li><li><p><strong>Application（应用层）</strong></p><ul><li><p>面向用户的协议与服务</p></li><li><p>如文件传输、网页、邮件、消息系统</p></li></ul></li></ol><hr><h3 id="5-传输层协议对比"><a href="#5-传输层协议对比" class="headerlink" title="5. 传输层协议对比"></a>5. 传输层协议对比</h3><ul><li><p><strong>TCP</strong></p><ul><li><p>面向连接、可靠、保证顺序</p></li><li><p>通过 ACK 确认机制确保数据完整</p></li><li><p>适合网页、文件传输</p></li></ul></li><li><p><strong>UDP</strong></p><ul><li><p>无连接、不保证可靠性</p></li><li><p>速度快，允许丢包</p></li><li><p>适合音视频、游戏</p></li></ul></li><li><p><strong>ICMP</strong></p><ul><li><p>不传输业务数据</p></li><li><p>用于错误报告和诊断（如 <code>ping</code>）</p></li></ul></li></ul><hr><h3 id="6-常见命令（理解用途即可）"><a href="#6-常见命令（理解用途即可）" class="headerlink" title="6. 常见命令（理解用途即可）"></a>6. 常见命令（理解用途即可）</h3><ul><li><p><code>ip a</code>：查看本机网络接口、IP、MAC</p></li><li><p><code>ping</code>：检测连通性（ICMP）</p></li><li><p><code>traceroute</code>：查看数据包经过的路由路径</p></li><li><p><code>arp</code> / <code>nmap</code>：局域网设备发现与映射</p></li></ul><hr><h3 id="7-总体理解"><a href="#7-总体理解" class="headerlink" title="7. 总体理解"></a>7. 总体理解</h3><ul><li><p>网络是一个<strong>分层协作系统</strong></p></li><li><p>每一层只关心自己的职责</p></li><li><p>上层依赖下层，但不关心实现细节</p></li><li><p>这是互联网可扩展、可维护的关键原因</p></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LSAD</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OCF Linux System Administration DeCal note4</title>
    <link href="/2026/02/08/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20note4/"/>
    <url>/2026/02/08/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20note4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-中的服务与进程简介"><a href="#Linux-中的服务与进程简介" class="headerlink" title="Linux 中的服务与进程简介"></a>Linux 中的服务与进程简介</h1><p><em>An Introduction to Services and Processes in Linux</em><br>作者：Sawan Srivastava</p><p>本文内容基于 <strong>OCF Linux 系统管理 DeCal（SysAdmin DeCal）第 4 讲</strong>，介绍 Linux 中<strong>服务（services）</strong>与<strong>进程（processes）</strong>的基础知识。<br>本文的主要目标是帮助你成为一个<strong>更高效的 Linux 使用者</strong>，而不是内核黑客。</p><hr><h2 id="理解进程（Understanding-Processes）"><a href="#理解进程（Understanding-Processes）" class="headerlink" title="理解进程（Understanding Processes）"></a>理解进程（Understanding Processes）</h2><p><strong>进程（process）</strong> 是一个正在运行的程序实例。<br>进程之间彼此隔离，每个进程都有<strong>独立的内存空间</strong>和<strong>线程</strong>。</p><hr><h2 id="进程-vs-线程（Processes-vs-Threads）"><a href="#进程-vs-线程（Processes-vs-Threads）" class="headerlink" title="进程 vs 线程（Processes vs. Threads）"></a>进程 vs 线程（Processes vs. Threads）</h2><p>一个进程可以包含 <strong>一个或多个线程</strong>。</p><ul><li>进程拥有各自独立的数据和代码  </li><li>不同进程之间必须通过 <strong>管道、文件等机制</strong>进行通信  </li><li>线程属于同一个进程  </li><li>同一进程中的线程 <strong>共享内存空间</strong>，但具有不同的系统状态  </li><li>这种情况称为 <strong>多线程进程（multithreaded process）</strong></li></ul><p><img src="https://sawansri.com/blog/processes-and-services/images/thread.png" alt="线程示意图"></p><hr><h2 id="什么定义了一个进程？（What-Defines-a-Process-）"><a href="#什么定义了一个进程？（What-Defines-a-Process-）" class="headerlink" title="什么定义了一个进程？（What Defines a Process?）"></a>什么定义了一个进程？（What Defines a Process?）</h2><p>每个进程都包含以下关键标识与组成部分：</p><ul><li><strong>PID</strong>：进程 ID（唯一）</li><li><strong>PPID</strong>：父进程 ID</li><li><strong>UID</strong>：运行该进程的用户 ID</li><li><strong>Executable</strong>：该进程正在执行的程序</li><li><strong>Args</strong>：进程启动时的参数（命令行参数等）</li></ul><p>所有进程都有父进程，<strong>唯一的例外是第一个进程：<code>init</code> 进程</strong>。</p><ul><li><code>init</code> 在系统启动时创建</li><li>它的 PID 永远是 <strong>1</strong></li><li>系统中所有其他进程，最终都源自它</li></ul><p><img src="https://sawansri.com/blog/processes-and-services/images/htop_tree.png" alt="进程树（htop）"></p><hr><h2 id="进程创建：fork-与-exec-系统调用"><a href="#进程创建：fork-与-exec-系统调用" class="headerlink" title="进程创建：fork() 与 exec() 系统调用"></a>进程创建：<code>fork()</code> 与 <code>exec()</code> 系统调用</h2><p>(Process Creation: The <code>fork()</code> and <code>exec()</code> System Calls)</p><p>一个新的进程通过调用 <strong><code>fork()</code></strong> 创建。</p><ul><li>调用 <code>fork()</code> 后，会产生两个进程：<ul><li>父进程</li><li>子进程</li></ul></li><li>两者几乎完全相同</li><li>父进程保持原有 PID</li><li>子进程获得一个新的 PID</li><li>子进程可以选择调用 <strong><code>exec()</code></strong><ul><li>用新的程序<strong>替换自身正在运行的程序</strong></li></ul></li></ul><p><img src="https://sawansri.com/blog/processes-and-services/images/fork.png" alt="fork 过程示意图"></p><hr><h2 id="会打印多少次-henlo？"><a href="#会打印多少次-henlo？" class="headerlink" title="会打印多少次 henlo？"></a>会打印多少次 henlo？</h2><p><img src="https://sawansri.com/blog/processes-and-services/images/henlo_fork.png" alt="fork 示例"></p><hr><h2 id="进程生命周期：僵尸进程与孤儿进程"><a href="#进程生命周期：僵尸进程与孤儿进程" class="headerlink" title="进程生命周期：僵尸进程与孤儿进程"></a>进程生命周期：僵尸进程与孤儿进程</h2><p>(The Process Lifecycle: Zombies and Orphans)</p><h3 id="僵尸进程（Zombie-Process）"><a href="#僵尸进程（Zombie-Process）" class="headerlink" title="僵尸进程（Zombie Process）"></a>僵尸进程（Zombie Process）</h3><p>当一个<strong>子进程结束运行</strong>后，它会变成一个 <strong>僵尸进程</strong>：</p><ul><li>进程本身已结束</li><li>但它的元数据仍保留在进程表中</li><li>以便父进程读取其退出状态</li></ul><p>父进程需要调用 <strong><code>wait()</code></strong> 系统调用来“回收”这个僵尸进程。</p><p>如果一个长期运行的父进程<strong>没有正确回收子进程</strong>，僵尸进程会不断累积，造成资源泄露。</p><p><img src="https://sawansri.com/blog/processes-and-services/images/zombie.png" alt="僵尸进程示意图"></p><hr><h3 id="孤儿进程（Orphan-Process）"><a href="#孤儿进程（Orphan-Process）" class="headerlink" title="孤儿进程（Orphan Process）"></a>孤儿进程（Orphan Process）</h3><p>如果<strong>父进程先于子进程退出</strong>，那么子进程会变成 <strong>孤儿进程</strong>。</p><ul><li>所有孤儿进程会立刻被 <strong>init 进程（PID 1）收养</strong></li><li>init 进程会在它们退出时自动回收</li><li>从而防止它们变成永久僵尸进程</li></ul><p><img src="https://sawansri.com/blog/processes-and-services/images/re-init.png" alt="孤儿进程被 init 收养"></p><hr><h2 id="进程通信（Communication）"><a href="#进程通信（Communication）" class="headerlink" title="进程通信（Communication）"></a>进程通信（Communication）</h2><h3 id="进程间通信（Inter-Process-Communication）"><a href="#进程间通信（Inter-Process-Communication）" class="headerlink" title="进程间通信（Inter-Process Communication）"></a>进程间通信（Inter-Process Communication）</h3><p>常见的进程间通信方式包括：</p><ul><li>退出码（Exit codes）</li><li>信号（Signals，例如 SIGTERM、SIGKILL、SIGINT）</li><li>管道（STDIN、STDOUT、STDERR）</li><li>套接字（UNIX Socket、IP Socket）</li><li>消息总线（例如 Linux 上的 dbus）</li><li>以及更多方式……</li></ul><hr><h3 id="进程信号（Process-Signals）"><a href="#进程信号（Process-Signals）" class="headerlink" title="进程信号（Process Signals）"></a>进程信号（Process Signals）</h3><p>常见信号说明：</p><ul><li><strong>SIGTERM</strong>：请求进程正常退出</li><li><strong>SIGKILL</strong>：立即强制终止进程</li><li><strong>SIGINT</strong>：中断信号（通常由 Ctrl + C 触发）</li><li><strong>SIGHUP</strong>：用户关闭终端窗口</li><li><strong>SIGWINCH</strong>：终端窗口大小发生变化</li><li><strong>SIGSTOP / SIGCONT</strong>：暂停 / 恢复进程</li></ul><hr><h2 id="Shell-中的作业控制（Job-Control-in-the-Shell）"><a href="#Shell-中的作业控制（Job-Control-in-the-Shell）" class="headerlink" title="Shell 中的作业控制（Job Control in the Shell）"></a>Shell 中的作业控制（Job Control in the Shell）</h2><p>作业控制允许你管理在 shell 中运行的进程。</p><ul><li><strong>前台进程（foreground process）</strong><ul><li>直接与终端交互</li><li>例如正在运行的编辑器或脚本</li></ul></li><li><strong>后台进程（background process）</strong><ul><li>无需用户交互</li><li>不会阻塞终端</li></ul></li></ul><p>常用作业控制命令：</p><ul><li><strong>Ctrl + Z</strong><br>暂停当前前台进程，发送 <code>SIGTSTP</code> 信号</li><li><strong><code>jobs</code></strong><br>列出当前 shell 中的作业（暂停或后台）</li><li><strong><code>fg %jobid</code></strong><br>将作业切换到前台</li><li><strong><code>bg %jobid</code></strong><br>在后台继续执行作业</li><li><strong><code>command &amp;</code></strong><br>直接在后台运行命令</li></ul><hr><h2 id="服务与守护进程（Services-and-Daemons）"><a href="#服务与守护进程（Services-and-Daemons）" class="headerlink" title="服务与守护进程（Services and Daemons）"></a>服务与守护进程（Services and Daemons）</h2><p><strong>服务（service）</strong> 是一种特殊的进程，称为 <strong>守护进程（daemon）</strong>。</p><p>守护进程的特点：</p><ul><li>非交互式</li><li>长时间运行</li><li>在后台执行</li></ul><p>常见示例：</p><ul><li>Web 服务：<code>nginx</code></li><li>远程登录：<code>sshd</code></li><li>系统日志：<code>rsyslogd</code></li></ul><hr><h2 id="使用-systemd-管理服务"><a href="#使用-systemd-管理服务" class="headerlink" title="使用 systemd 管理服务"></a>使用 systemd 管理服务</h2><p>(Managing Services with systemd)</p><p>在现代 Linux 系统中，服务由 <strong>init 系统</strong> 管理，最常见的是 <strong>systemd</strong>。</p><p>与 systemd 交互的主要命令是：</p><pre><code class="lang-bash">systemctl`</code></pre><hr><h2 id="systemd-单元文件（Systemd-Unit-Files）"><a href="#systemd-单元文件（Systemd-Unit-Files）" class="headerlink" title="systemd 单元文件（Systemd Unit Files）"></a>systemd 单元文件（Systemd Unit Files）</h2><p>systemd 使用 <strong>单元文件（unit files）</strong> 定义服务行为：</p><ul><li><p>服务如何启动</p></li><li><p>服务如何停止</p></li><li><p>服务如何重启</p></li><li><p>systemctl 管理命令如何作用于服务</p></li></ul><p><img src="https://sawansri.com/blog/processes-and-services/images/service.png" alt="systemd 服务示意图"></p><hr><h2 id="常用-systemctl-命令（Essential-systemctl-Commands）"><a href="#常用-systemctl-命令（Essential-systemctl-Commands）" class="headerlink" title="常用 systemctl 命令（Essential systemctl Commands）"></a>常用 <code>systemctl</code> 命令（Essential systemctl Commands）</h2><ul><li><p><code>systemctl status [name]</code>：查看服务的详细状态</p></li><li><p><code>systemctl start [name]</code>：启动服务</p></li><li><p><code>systemctl stop [name]</code>：停止服务</p></li><li><p><code>systemctl restart [name]</code>：重启服务</p></li><li><p><code>systemctl enable [name]</code>：设置服务开机自启</p></li><li><p><code>systemctl disable [name]</code>：禁止服务开机自启</p></li><li><p><code>systemctl reload [name]</code>：重新加载服务配置</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LSAD</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OCF Linux System Administration DeCal note3</title>
    <link href="/2026/02/08/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20note3/"/>
    <url>/2026/02/08/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20note3/</url>
    
    <content type="html"><![CDATA[<h1 id="📦-Linux-包管理（Packaging）"><a href="#📦-Linux-包管理（Packaging）" class="headerlink" title="📦 Linux 包管理（Packaging）"></a>📦 Linux 包管理（Packaging）</h1><h2 id="一、为什么需要包管理？"><a href="#一、为什么需要包管理？" class="headerlink" title="一、为什么需要包管理？"></a>一、为什么需要包管理？</h2><h3 id="1-从-tree-命令说起"><a href="#1-从-tree-命令说起" class="headerlink" title="1. 从 tree 命令说起"></a>1. 从 <code>tree</code> 命令说起</h3><p>当你在终端中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tree<br></code></pre></td></tr></table></figure><p>看似只是执行了一个简单命令，但实际上你运行的是一个<strong>完整的软件程序</strong>，它通常包含：</p><ul><li>可执行文件  </li><li>库文件  </li><li>文档  </li><li>可能的配置文件  </li></ul><p>👉 问题来了：</p><ul><li>如果我只有 <strong>1 个程序</strong>，还能手动管理  </li><li><strong>如果我有 1000 个程序呢？</strong></li></ul><hr><h3 id="2-手动管理软件会遇到的问题"><a href="#2-手动管理软件会遇到的问题" class="headerlink" title="2. 手动管理软件会遇到的问题"></a>2. 手动管理软件会遇到的问题</h3><p>PPT 中提出了一系列关键问题：</p><ul><li>如果我有 <strong>1000 个软件包</strong>？</li><li>如果存在：<ul><li><strong>运行时依赖（Runtime dependencies）</strong></li><li><strong>构建依赖（Build dependencies）</strong></li></ul></li><li>如果还涉及：<ul><li><strong>版本管理</strong></li><li><strong>源码管理</strong></li></ul></li></ul><p>📌 结论：  </p><blockquote><p>软件包管理的复杂度极高，必须依赖自动化的包管理工具。</p></blockquote><hr><h2 id="二、APT：Advanced-Package-Tool"><a href="#二、APT：Advanced-Package-Tool" class="headerlink" title="二、APT：Advanced Package Tool"></a>二、APT：Advanced Package Tool</h2><h3 id="1-什么是-APT？"><a href="#1-什么是-APT？" class="headerlink" title="1. 什么是 APT？"></a>1. 什么是 APT？</h3><p><strong>APT（Advanced Package Tool）</strong> 是 Debian 系 Linux 发行版使用的高级包管理工具，用来：</p><ul><li>自动分析并解决依赖关系  </li><li>管理软件版本  </li><li>从软件仓库下载、校验并安装软件  </li></ul><p>👉 APT 是一个<strong>高级前端工具</strong>，并不直接完成底层安装。</p><hr><h2 id="三、Linux-与发行版（Distributions）"><a href="#三、Linux-与发行版（Distributions）" class="headerlink" title="三、Linux 与发行版（Distributions）"></a>三、Linux 与发行版（Distributions）</h2><h3 id="1-Linux-本身的作用"><a href="#1-Linux-本身的作用" class="headerlink" title="1. Linux 本身的作用"></a>1. Linux 本身的作用</h3><p>Linux 本质上只是一个 <strong>内核（Kernel）</strong>，主要负责：</p><ul><li>管理 CPU  </li><li>管理内存  </li><li>管理硬件资源  </li><li>为程序分配系统资源  </li></ul><p>但一个完整的操作系统还需要：</p><ul><li>Shell（如 bash）  </li><li>基础命令（ls、cat、cp 等）  </li><li>初始化系统（init / systemd）  </li><li><strong>包管理器（APT、YUM、Nix 等）</strong></li></ul><hr><h3 id="2-什么是-Linux-发行版？"><a href="#2-什么是-Linux-发行版？" class="headerlink" title="2. 什么是 Linux 发行版？"></a>2. 什么是 Linux 发行版？</h3><p>Linux 发行版 =</p><blockquote><p>Linux 内核 + 用户空间工具 + 初始化系统 + 包管理系统 + 发行版维护策略</p></blockquote><p>PPT 中提到的发行版包括：</p><ul><li>Debian  </li><li>Ubuntu  </li><li>Arch  </li><li>openSUSE  </li><li>NixOS  </li><li>以及其他发行版</li></ul><hr><h2 id="四、Debian-发行版"><a href="#四、Debian-发行版" class="headerlink" title="四、Debian 发行版"></a>四、Debian 发行版</h2><h3 id="1-Debian-是什么？"><a href="#1-Debian-是什么？" class="headerlink" title="1. Debian 是什么？"></a>1. Debian 是什么？</h3><ul><li>一个 Linux 发行版  </li><li><strong>1993 年发布</strong>  </li><li>历史悠久、社区成熟  </li></ul><hr><h3 id="2-为什么选择-Debian？"><a href="#2-为什么选择-Debian？" class="headerlink" title="2. 为什么选择 Debian？"></a>2. 为什么选择 Debian？</h3><p>PPT 给出的理由包括：</p><ul><li><p><strong>用户友好</strong></p><ul><li>开箱即用  </li><li>安装相对简单  </li></ul></li><li><p><strong>极度稳定</strong></p><ul><li>新版本大约每 <strong>2 年</strong> 发布一次  </li></ul></li><li><p><strong>非常流行</strong></p><ul><li>Ubuntu 等发行版基于 Debian  </li></ul></li><li><p><strong>社区广泛使用</strong></p><ul><li>在 OCF（Open Computing Facility）中被使用  </li></ul></li></ul><p>📌 Debian 的核心理念：<strong>稳定优先</strong></p><hr><h2 id="五、APT-常用命令"><a href="#五、APT-常用命令" class="headerlink" title="五、APT 常用命令"></a>五、APT 常用命令</h2><p>以下是 PPT 中列出的常见 APT 命令：</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>apt install</code></td><td>安装软件包</td></tr><tr><td><code>apt remove</code></td><td>删除软件包</td></tr><tr><td><code>apt list</code></td><td>列出已安装的软件</td></tr><tr><td><code>apt show</code></td><td>显示软件包的详细信息</td></tr><tr><td><code>apt search</code></td><td>搜索软件包</td></tr><tr><td><code>apt update</code></td><td>更新软件包索引</td></tr><tr><td><code>apt upgrade</code></td><td>升级所有已安装软件</td></tr></tbody></table></div><hr><h2 id="六、apt-install-的完整工作流程（重点）"><a href="#六、apt-install-的完整工作流程（重点）" class="headerlink" title="六、apt install 的完整工作流程（重点）"></a>六、<code>apt install</code> 的完整工作流程（重点）</h2><p>当你执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install package_name<br></code></pre></td></tr></table></figure><p>APT 会按顺序完成以下步骤：</p><hr><h3 id="1-读取软件包索引"><a href="#1-读取软件包索引" class="headerlink" title="1. 读取软件包索引"></a>1. 读取软件包索引</h3><p>索引文件位于：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/var/lib/apt/lists/<br></code></pre></td></tr></table></figure><ul><li>保存了所有软件仓库中的包信息  </li><li><code>apt update</code> 的本质就是更新这里  </li></ul><hr><h3 id="2-分析依赖关系"><a href="#2-分析依赖关系" class="headerlink" title="2. 分析依赖关系"></a>2. 分析依赖关系</h3><p>APT 会：</p><ul><li>找出目标软件需要的依赖  </li><li>递归分析依赖的依赖  </li></ul><p>👉 这是 APT 自动化能力的核心所在。</p><hr><h3 id="3-检查已安装软件"><a href="#3-检查已安装软件" class="headerlink" title="3. 检查已安装软件"></a>3. 检查已安装软件</h3><p>已安装软件信息存放在：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/var/lib/dpkg/status<br></code></pre></td></tr></table></figure><p>用于判断：</p><ul><li>哪些依赖已经存在  </li><li>哪些依赖需要额外安装  </li></ul><hr><h3 id="4-从镜像站下载-deb-包"><a href="#4-从镜像站下载-deb-包" class="headerlink" title="4. 从镜像站下载 .deb 包"></a>4. 从镜像站下载 <code>.deb</code> 包</h3><ul><li>从镜像服务器（Mirrors）下载  </li><li>下载的是 <strong>二进制格式的 <code>.deb</code> 包</strong></li></ul><hr><h3 id="5-校验软件包完整性"><a href="#5-校验软件包完整性" class="headerlink" title="5. 校验软件包完整性"></a>5. 校验软件包完整性</h3><ul><li>校验哈希值  </li><li>确保软件未被篡改，保证安全性  </li></ul><hr><h3 id="6-调用-dpkg-完成安装"><a href="#6-调用-dpkg-完成安装" class="headerlink" title="6. 调用 dpkg 完成安装"></a>6. 调用 <code>dpkg</code> 完成安装</h3><p>APT 最终会调用底层工具：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">dpkg<br></code></pre></td></tr></table></figure><p>来完成真正的软件安装。</p><p>📌 总结关系：</p><ul><li><strong>APT：负责依赖分析与整体管理</strong>  </li><li><strong>dpkg：负责具体的安装与卸载</strong></li></ul><hr><h2 id="七、dpkg：Debian-的底层包管理工具"><a href="#七、dpkg：Debian-的底层包管理工具" class="headerlink" title="七、dpkg：Debian 的底层包管理工具"></a>七、dpkg：Debian 的底层包管理工具</h2><h3 id="1-dpkg-是什么？"><a href="#1-dpkg-是什么？" class="headerlink" title="1. dpkg 是什么？"></a>1. dpkg 是什么？</h3><ul><li>Debian 的底层包管理系统  </li><li>直接操作 <code>.deb</code> 软件包  </li><li><strong>不自动解决依赖关系</strong></li></ul><hr><h3 id="2-dpkg-的特点"><a href="#2-dpkg-的特点" class="headerlink" title="2. dpkg 的特点"></a>2. dpkg 的特点</h3><ul><li>软件包格式：<code>.deb</code>  </li><li>功能较为底层：<ul><li>安装  </li><li>卸载  </li></ul></li><li>如果依赖缺失，安装会失败  </li></ul><hr><h3 id="3-手动使用-dpkg"><a href="#3-手动使用-dpkg" class="headerlink" title="3. 手动使用 dpkg"></a>3. 手动使用 dpkg</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -i package.deb<br></code></pre></td></tr></table></figure><p>📌 实际使用中通常通过 APT 间接调用 dpkg，而不是直接使用。</p><hr><h2 id="八、-deb-软件包的内部结构"><a href="#八、-deb-软件包的内部结构" class="headerlink" title="八、.deb 软件包的内部结构"></a>八、<code>.deb</code> 软件包的内部结构</h2><p><code>.deb</code> 并不只是一个可执行文件，而是一个完整的软件包格式。</p><hr><h3 id="1-control-tar-（控制信息）"><a href="#1-control-tar-（控制信息）" class="headerlink" title="1. control.tar.*（控制信息）"></a>1. <code>control.tar.*</code>（控制信息）</h3><p>包含内容：</p><ul><li>软件包名称  </li><li>版本号  </li><li>依赖信息  </li><li>维护者信息  </li><li>软件描述  </li></ul><p>查看方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg-deb --info package.deb<br></code></pre></td></tr></table></figure><hr><h3 id="2-data-tar-（程序数据）"><a href="#2-data-tar-（程序数据）" class="headerlink" title="2. data.tar.*（程序数据）"></a>2. <code>data.tar.*</code>（程序数据）</h3><p>包含：</p><ul><li>可执行文件  </li><li>配置文件  </li><li>文档  </li><li>安装到系统中的目录结构  </li></ul><p>查看方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg-deb --contents package.deb<br></code></pre></td></tr></table></figure><hr><p>📌 <code>.deb</code> 包本质上由以下部分组成：</p><blockquote><p>程序文件 + 元数据 + 安装规则</p></blockquote><hr><h2 id="九、总结：为什么包管理如此复杂？"><a href="#九、总结：为什么包管理如此复杂？" class="headerlink" title="九、总结：为什么包管理如此复杂？"></a>九、总结：为什么包管理如此复杂？</h2><p>PPT 给出的最终结论是：</p><blockquote><p><strong>Package Management is complex!</strong></p></blockquote><p>原因包括：</p><ul><li>软件之间依赖关系复杂  </li><li>不同版本之间可能不兼容  </li><li>需要进行安全与完整性校验  </li><li>存在多个软件仓库来源  </li><li>需要支持升级、维护与回滚  </li></ul><p>👉 <strong>APT 的意义在于隐藏这些复杂性，让用户通过简单命令完成软件管理。</strong></p><hr>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LSAD</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OCF Linux System Administration DeCal note2</title>
    <link href="/2026/02/08/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20note2/"/>
    <url>/2026/02/08/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20note2/</url>
    
    <content type="html"><![CDATA[<h1 id="Core-Shell-amp-Bash-Scripting"><a href="#Core-Shell-amp-Bash-Scripting" class="headerlink" title="Core Shell &amp; Bash Scripting"></a>Core Shell &amp; Bash Scripting</h1><p>（核心 Shell 与 Bash 脚本）</p><p>Presented to you by<br><img src="https://blog.jaysa.net/assets/ocf-box.png" alt=""></p><p>and jaysa :)</p><p><img src="https://blog.jaysa.net/assets/bash-cover.png" alt=""></p><hr><h2 id="使用-Vim-提升效率"><a href="#使用-Vim-提升效率" class="headerlink" title="使用 Vim 提升效率"></a>使用 Vim 提升效率</h2><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#getting-faster-with-vim" title="Permanent link">¶</a></p><p>希望你现在已经可以比较熟练地在 vim 中编辑文件了，但你可能还是觉得自己<strong>很慢</strong>。</p><p>别担心！<br>随着你把新的命令逐渐变成肌肉记忆，你一定会越来越快。</p><p>如果你真的非常投入学习，建议你：</p><blockquote><p><strong>每天学一个新命令。</strong></p></blockquote><p>只要有机会就用它，直到它变成一种自然反应。</p><p>你掌握的命令越多，当你在课堂上记笔记时，<strong>坐在你后面的那个人就会觉得你越酷。</strong></p><p><img src="https://blog.jaysa.net/assets/nerd-cat.png" alt=""></p><p>↑<br>你在用 VS Code 写代码时</p><p><img src="https://blog.jaysa.net/assets/hacker-cat.png" alt=""></p><p>↑<br>你如果使用 Vim 的样子</p><p>如果你不知道接下来该学哪些命令，可以看看这篇文章：</p><p>👉 <strong>Learn Vim Progressively</strong><br><a href="https://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/">https://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/</a></p><p>它给出了一个<strong>循序渐进学习 Vim 技巧的合理顺序</strong>。</p><p>👉 <strong>今天的实验我希望你尽量坚持使用 Vim！</strong></p><hr><h2 id="Spotify-太烂了"><a href="#Spotify-太烂了" class="headerlink" title="Spotify 太烂了"></a>Spotify 太烂了</h2><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#spotify-sucks" title="Permanent link">¶</a></p><p>说实话，如果 Spotify 没那么烂，我今天可能都不会站在这里。</p><p>有一天我刚在 YouTube 看完一个视频，Spotify 就立刻给我推送了一个“精准推荐”的播客。</p><p>不知道为什么，这一下彻底触发了我。</p><p>于是我开始思考：</p><blockquote><p><strong>我能不能把对设备和软件的控制权，从这些大公司手里拿回来？</strong></p></blockquote><p>我们在 UC Berkeley。<br>所以我知道，你和我一样聪明，不应该被迫忍受：</p><ul><li>强制推荐内容</li><li>桌面开始菜单里的广告快捷方式（我们甚至还花钱买了系统！）</li><li>音乐品味、媒体内容完全由广告算法决定</li></ul><p>我希望你在这门课中学到的技能，能像当初帮助我一样：</p><blockquote><p><strong>让你重新掌控自己的设备和软件。</strong></p></blockquote><p>Bash 脚本正是其中一项非常重要、也非常基础的技能。</p><hr><h2 id="那我们自己做一个替代方案……"><a href="#那我们自己做一个替代方案……" class="headerlink" title="那我们自己做一个替代方案……"></a>那我们自己做一个替代方案……</h2><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#lets-make-an-alternative" title="Permanent link">¶</a></p><p>卸载 Spotify 之后，我很难找到一种能接近 Spotify 使用体验的听歌方式。</p><p>不过……</p><p>前段时间我在家打扫房间时，翻出了一台：</p><blockquote><p><strong>很久以前圣诞节收到的 iPod Shuffle。</strong></p></blockquote><p>我研究了一下如何在 Linux 上使用 iPod Shuffle<br>（因为我没有任何苹果设备）。</p><p>然后发现了一个 Python 脚本：</p><blockquote><p><strong>ipod-shuffle-4g</strong></p></blockquote><p>这正是我上周给大家展示过的那个脚本。</p><p>现在我们来试着用它，把音乐上传到我的 iPod。</p><p>假设我用某个“神秘的在线视频转 mp3 网站”，<br>从 YouTube 下载了一个 mp3 文件。</p><p>（别 @ 我盗版问题，我这周四去看 Red Leather 现场演出给的钱<br>比 Spotify 给他的播放分成多得多。）</p><p><img src="https://blog.jaysa.net/assets/first-script.png" alt=""></p><p>谁能告诉我：<br>我运行每一条命令时都发生了什么？</p><p>好，现在我们已经成功：</p><ul><li>手动下载了一个 mp3</li><li>手动上传到了 iPod</li></ul><p>但这离“方便”还差得很远。</p><p>而且我已经忘了刚刚用的命令是什么。</p><hr><h2 id="Bash-脚本"><a href="#Bash-脚本" class="headerlink" title="Bash 脚本"></a>Bash 脚本</h2><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#bash-scripting" title="Permanent link">¶</a></p><p>那我们把刚刚那条命令保存成一个脚本吧。</p><p><img src="https://blog.jaysa.net/assets/script-1.png" alt=""></p><p>现在运行这个脚本：</p><p><img src="https://blog.jaysa.net/assets/script-2.png" alt=""></p><blockquote><p>虽然在这个例子中 <code>./script.sh</code> 和 <code>bash script.sh</code> 效果一样，<br>但它们本质上是不同的：</p><ul><li><code>./</code>：直接执行文件</li><li><code>bash</code>：把文件内容作为输入传给 bash 解释器</li></ul><p>一般我更推荐使用 <code>./</code>，这样你就不用记脚本是用什么语言写的。</p></blockquote><hr><h2 id="流（Streams）"><a href="#流（Streams）" class="headerlink" title="流（Streams）"></a>流（Streams）</h2><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#streams" title="Permanent link">¶</a></p><p>这样只是稍微好了一点。</p><p>如果我希望：</p><blockquote><p><strong>在运行脚本时直接指定音乐文件路径，而不是手动 cp 到 iPod 根目录呢？</strong></p></blockquote><p>为此，我们需要从命令行获取用户输入。</p><p>这叫：</p><blockquote><p><strong>STDIN（标准输入）</strong></p></blockquote><p>GNU 官方文档（read 命令）：</p><p><a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-read">https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-read</a></p><p>Bash 中还有很多操作数据流的方法，例如：</p><ol><li><strong>重定向</strong></li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">echo <span class="hljs-string">&quot;hello&quot;</span> &gt; <span class="hljs-keyword">out</span>.txt<br></code></pre></td></tr></table></figure><p>把 <code>hello</code> 写入当前目录下的新文件 <code>out.txt</code></p><ol><li><strong>追加</strong></li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">echo <span class="hljs-string">&quot;hello&quot;</span> &gt;&gt; <span class="hljs-keyword">out</span>.txt<br></code></pre></td></tr></table></figure><p>将内容追加到文件末尾</p><ul><li>这和重定向有什么区别？</li></ul><ol><li><strong>管道</strong></li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">command</span>1 | <span class="hljs-keyword">command</span>2<br></code></pre></td></tr></table></figure><p>把第一个命令的输出作为第二个命令的输入<br>连接 stdout 和 stdin。</p><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#variables" title="Permanent link">¶</a></p><p>我们还需要把输入内容保存起来。</p><p>我们用一个叫做 <code>song_name</code> 的变量。</p><p><img src="https://blog.jaysa.net/assets/script-3.png" alt=""><br><img src="https://blog.jaysa.net/assets/script-4.png" alt=""></p><p>你也可以用更基础的方式定义变量，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">FOO=1<br>OUTPUT=$((FOO+<span class="hljs-number">1</span>))<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$OUTPUT</span><br></code></pre></td></tr></table></figure><p>终端输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><hr><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#conditionals" title="Permanent link">¶</a></p><p>现在我们已经可以：</p><ul><li>接收歌曲名称</li><li>之后把它传给 Python 脚本</li></ul><p>另外，我会使用一个非常酷的音乐管理工具：</p><blockquote><p><strong>beets</strong></p></blockquote><p>用来管理我电脑里的音乐库。</p><p><img src="https://blog.jaysa.net/assets/script-6.png" alt=""></p><p><img src="https://blog.jaysa.net/assets/script-5.png" alt=""></p><p><img src="https://blog.jaysa.net/assets/script-7.png" alt=""></p><p><img src="https://blog.jaysa.net/assets/script-8.png" alt=""></p><p>GNU Bash 条件表达式文档：</p><p><a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html">https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html</a></p><h3 id="if–else-示例"><a href="#if–else-示例" class="headerlink" title="if–else 示例"></a>if–else 示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> -eq 79 ];<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;nice&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;darn&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="elif-示例"><a href="#elif-示例" class="headerlink" title="elif 示例"></a>elif 示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> -eq 79 ];<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;nice&quot;</span><br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> -eq 42 ];<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;the answer!&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;wat r numbers&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="case-示例"><a href="#case-示例" class="headerlink" title="case 示例"></a>case 示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;are you 21?&quot;</span> ANSWER<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$ANSWER</span>&quot;</span> <span class="hljs-keyword">in</span><br>  <span class="hljs-string">&quot;yes&quot;</span>)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;i give u cookie&quot;</span>;;<br>  <span class="hljs-string">&quot;no&quot;</span>)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;thats illegal&quot;</span>;;<br>  <span class="hljs-string">&quot;are you?&quot;</span>)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;lets not&quot;</span>;;<br>  *)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;please answer&quot;</span><br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><hr><h2 id="现在画剩下的猫头鹰吧"><a href="#现在画剩下的猫头鹰吧" class="headerlink" title="现在画剩下的猫头鹰吧"></a>现在画剩下的猫头鹰吧</h2><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#now-draw-the-rest-of-the-owl" title="Permanent link">¶</a></p><p>现在我们用学到的内容改进脚本：</p><ul><li>使用 <code>yt-dlp</code> 自动下载音乐</li><li>不再手动操作</li></ul><p><img src="https://blog.jaysa.net/assets/rest-of-owl.jpg" alt=""></p><p><img src="https://blog.jaysa.net/assets/script-9.png" alt=""></p><p><img src="https://blog.jaysa.net/assets/script-10.png" alt=""></p><hr><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#loops" title="Permanent link">¶</a></p><p>Bash 中主要有两种循环：</p><ul><li><code>for</code></li><li><code>while</code></li></ul><hr><h3 id="for-循环语法"><a href="#for-循环语法" class="headerlink" title="for 循环语法"></a>for 循环语法</h3><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#for-loop-syntax" title="Permanent link">¶</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">n=0<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> &#123;1..10&#125;<br><span class="hljs-keyword">do</span><br>    n=$(<span class="hljs-built_in">expr</span> <span class="hljs-variable">$x</span> + <span class="hljs-variable">$n</span>)<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$n</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">55<br></code></pre></td></tr></table></figure><hr><h3 id="while-循环语法"><a href="#while-循环语法" class="headerlink" title="while 循环语法"></a>while 循环语法</h3><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#while-loop-syntax" title="Permanent link">¶</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;nightmare &quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>程序会不断输出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nightmare</span><br></code></pre></td></tr></table></figure><p>直到用户手动终止。</p><hr><p>现在我们在脚本中使用 <code>while</code> 循环：</p><p><img src="https://blog.jaysa.net/assets/script-11.png" alt=""></p><p><code>&lt;&lt;&lt;</code> 会把整个 <code>song_path</code> 变量作为输入喂给循环。</p><p>参考资料：</p><ul><li><p>while 逐行读取文件原理<br><a href="https://stackoverflow.com/questions/10929453/read-a-file-line-by-line-assigning-the-value-to-a-variable">https://stackoverflow.com/questions/10929453/read-a-file-line-by-line-assigning-the-value-to-a-variable</a></p></li><li><p>here string（&lt;&lt;&lt;）解释<br><a href="https://unix.stackexchange.com/questions/80362/what-does-mean">https://unix.stackexchange.com/questions/80362/what-does-mean</a></p></li></ul><blockquote><p>我还使用了 Python 脚本的一个依赖：</p><p><strong>mutagen</strong></p><p>我通过 nix 临时安装它，用来根据音频元数据生成播放列表。</p><p><code>-i</code> 参数正是用于这个目的。</p><p>下周我们会详细学习包管理，如果你想了解 nix，可以来找我聊 🙂</p></blockquote><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#functions" title="Permanent link">¶</a></p><p>今天的示例里我没有使用函数，但你在实验中可能会用到。</p><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">greet</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hey there <span class="hljs-variable">$1</span>&quot;</span><br>&#125;<br><br>greet <span class="hljs-string">&quot;sysadmin decal&quot;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hey there sysadmin decal</span><br></code></pre></td></tr></table></figure><hr><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p><a href="https://blog.jaysa.net/2025/09/16/core-shell--bash-scripting/#tips" title="Permanent link">¶</a></p><ul><li><p>Bash 语法真的<strong>非常奇怪</strong></p><ul><li>空格极其重要</li><li>一定要仔细看报错信息</li></ul></li><li><p>一如既往：</p><blockquote><p><strong>用 Google 走向自由</strong></p></blockquote></li><li><p><strong>ncmpcpp!!!</strong></p><ul><li>终端用户界面（TUI） &gt; 图形界面（GUI）</li><li>Linux 上很多工具都有 TUI 版本</li><li>通常更快、更自由（FOSS）</li><li>而且和 Vim 一样：</li></ul></li></ul><blockquote><p><strong>会让你看起来超级超级酷</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LSAD</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OCF Linux System Administration DeCal lab4</title>
    <link href="/2026/02/08/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20lab4/"/>
    <url>/2026/02/08/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20lab4/</url>
    
    <content type="html"><![CDATA[<h1 id="实验-4：进程与服务"><a href="#实验-4：进程与服务" class="headerlink" title="实验 4：进程与服务"></a>实验 4：进程与服务</h1><p>Lab 4 - Processes and Services<br>OCF Sysadmin DeCal</p><hr><h2 id="目录（Table-of-Contents）"><a href="#目录（Table-of-Contents）" class="headerlink" title="目录（Table of Contents）"></a>目录（Table of Contents）</h2><ul><li><a href="https://decal.ocf.berkeley.edu/labs/4/#overview">概述</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/4/#part-0-set-up-networking">第 0 部分：配置网络</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/4/#part-1-using-systemd">第 1 部分：使用 systemd</a><ul><li><a href="https://decal.ocf.berkeley.edu/labs/4/#what-services-are-running-right-now">当前正在运行哪些服务？</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/4/#controlling-services">控制服务</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/4/#creating-a-service">创建一个服务</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/4/#debugging">调试</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/4/#crash-the-service">让服务崩溃！</a></li></ul></li><li><a href="https://decal.ocf.berkeley.edu/labs/4/#part-2-processes">第 2 部分：进程</a><ul><li><a href="https://decal.ocf.berkeley.edu/labs/4/#htop">htop</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/4/#the-process-hierarchy">进程层级结构</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/4/#orphan-processes">孤儿进程</a></li></ul></li><li><a href="https://decal.ocf.berkeley.edu/labs/4/#exploration">拓展阅读</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/4/#submission">提交</a></li></ul><hr><h2 id="概述（Overview）"><a href="#概述（Overview）" class="headerlink" title="概述（Overview）"></a>概述（Overview）</h2><p>在本次实验中，我们将深入学习 <strong>进程（processes）</strong> 和 <strong>systemd</strong>。<br>我们将通过 <strong>从零开始编写一个 systemd 服务</strong> 的方式，来展示使用 systemd 管理服务的优势。</p><p>本实验应当在你的 <strong>Linux 虚拟机（VM）</strong> 上完成。</p><hr><h2 id="第-0-部分：配置网络（Part-0-Set-up-networking）"><a href="#第-0-部分：配置网络（Part-0-Set-up-networking）" class="headerlink" title="第 0 部分：配置网络（Part 0: Set up networking）"></a>第 0 部分：配置网络（Part 0: Set up networking）</h2><p>在开始本实验之前，你需要确保 <strong>可以在网页浏览器中访问你 VM 上运行的服务</strong>。</p><p>我们的虚拟机 <strong>仅支持 IPv6</strong>，因此如果你当前没有 IPv6 网络连接，你需要先连接校园的 <strong>GlobalProtect VPN</strong>。</p><hr><h2 id="第-1-部分：使用-systemd（Part-1-Using-systemd）"><a href="#第-1-部分：使用-systemd（Part-1-Using-systemd）" class="headerlink" title="第 1 部分：使用 systemd（Part 1: Using systemd）"></a>第 1 部分：使用 systemd（Part 1: Using systemd）</h2><h3 id="当前正在运行哪些服务？"><a href="#当前正在运行哪些服务？" class="headerlink" title="当前正在运行哪些服务？"></a>当前正在运行哪些服务？</h3><p>(What services are running right now?)</p><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl<br>````<br><br>你会看到一个很长的表格，其中列出了 systemd 已知的所有单元（unit）。<br><br>我们现在只关注服务，运行：<br><br>```bash<br>systemctl --<span class="hljs-built_in">type</span>=service<br></code></pre></td></tr></table></figure><p>现在你可以看到计算机上所有正在运行的服务。<br>这些服务本质上都是在后台运行的 <strong>守护进程（daemon）</strong>。</p><p>你能认出其中的一些服务吗？</p><p><strong>问题 1：</strong><br>你系统上正在运行的一个 systemd 服务叫什么名字？它是做什么的？<br>（如果你不确定，可以搜索它的用途）</p><hr><h3 id="控制服务（Controlling-Services）"><a href="#控制服务（Controlling-Services）" class="headerlink" title="控制服务（Controlling Services）"></a>控制服务（Controlling Services）</h3><p>现在我们使用 systemd 来控制一个 <strong>nginx Web 服务器</strong>。</p><p>如果你还没有安装 nginx，请运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install nginx<br></code></pre></td></tr></table></figure><p>安装完成后，启动服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl start nginx<br></code></pre></td></tr></table></figure><p>检查 nginx 是否正在运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status nginx<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>如果你已经有其他 Web 服务器在运行，可能需要先停止它，以释放 80 端口供 nginx 使用。</p></blockquote><hr><h4 id="修改监听端口"><a href="#修改监听端口" class="headerlink" title="修改监听端口"></a>修改监听端口</h4><p>现在让 nginx 在 <strong>非标准端口 420</strong> 上监听连接。</p><p>编辑文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/nginx/sites-available/default<br></code></pre></td></tr></table></figure><p>将下面两行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">listen</span> <span class="hljs-number">80</span> default_server;<br><span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">80</span> default_server;<br></code></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">listen</span> <span class="hljs-number">420</span> default_server;<br><span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">420</span> default_server;<br></code></pre></td></tr></table></figure><blockquote><p>提示：<br>第一行用于配置 <strong>IPv4</strong><br>第二行用于配置 <strong>IPv6</strong></p></blockquote><hr><h4 id="重新加载配置"><a href="#重新加载配置" class="headerlink" title="重新加载配置"></a>重新加载配置</h4><p>告诉 systemd nginx 的配置发生了变化，需要重新加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl reload nginx<br></code></pre></td></tr></table></figure><p>现在：</p><ul><li><p>访问 <code>http://[yourusername].decal.ocfhosted.com:80</code><br>  → 会得到 <strong>connection refused</strong></p></li><li><p>Web 服务只会在<br>  <code>http://[yourusername].decal.ocfhosted.com:420</code><br>  上可用</p></li></ul><p>注意：并非所有服务都支持 reload。<br>如果不支持，systemd 会提示你，此时你必须使用 restart：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart yourservice<br></code></pre></td></tr></table></figure><p>最后，停止 nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl stop nginx<br></code></pre></td></tr></table></figure><hr><p><strong>问题 2：</strong><br><code>systemctl reload yourservice</code> 和<br><code>systemctl restart yourservice</code> 有什么区别？</p><p><strong>问题 3：</strong><br>上传一张截图，展示浏览器成功访问<br><code>http://[yourusername].decal.ocfhosted.com:420</code></p><p>如果你无法访问 IPv6 网站，可以在 VM 上运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl localhost:420<br></code></pre></td></tr></table></figure><p>并提交输出内容（应为 HTML 页面）。</p><hr><h3 id="创建一个服务（Creating-a-service）"><a href="#创建一个服务（Creating-a-service）" class="headerlink" title="创建一个服务（Creating a service）"></a>创建一个服务（Creating a service）</h3><p>我们将搭建一个 Web 服务器，并为其创建一个 systemd 单元。</p><p>确保已安装 git，如果没有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install git<br></code></pre></td></tr></table></figure><p>如果你还没有下载 decal-labs 仓库，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/ocf/decal-labs<br></code></pre></td></tr></table></figure><p>实验材料位于：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">decal-labs/4<br></code></pre></td></tr></table></figure><p>安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update<br>apt install build-essential make python3-virtualenv<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./run<br></code></pre></td></tr></table></figure><p>此时会在 <code>http://localhost:5000</code> 启动一个简单的 Web 服务器。<br>默认情况下，只能在 VM 本地访问。</p><hr><h4 id="你的任务"><a href="#你的任务" class="headerlink" title="你的任务"></a>你的任务</h4><p>请编写一个 systemd 服务来管理该 Web 服务器。</p><p>创建文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/systemd/system/toy.service<br></code></pre></td></tr></table></figure><p>可以参考课程幻灯片，或 DigitalOcean 的教程：<br><a href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files">https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files</a></p><p>服务文件模板如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=<br><span class="hljs-attr">Requires</span>=<br><span class="hljs-attr">After</span>=<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">ExecStart</span>=<br>User=<br></code></pre></td></tr></table></figure><p>编写时可思考：</p><ul><li><p>Web 服务器启动前需要哪些单元？</p></li><li><p>systemd 应运行哪个脚本启动服务器？</p><ul><li><p>必须使用 <strong>绝对路径</strong></p></li><li><p>可使用 <code>realpath -se &lt;脚本路径&gt;</code> 获取</p></li></ul></li><li><p>默认以 root 运行是否安全？</p></li></ul><p>完成后，启动并设置开机自启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start toy.service<br>systemctl <span class="hljs-built_in">enable</span> toy.service<br></code></pre></td></tr></table></figure><hr><h3 id="调试（Debugging）"><a href="#调试（Debugging）" class="headerlink" title="调试（Debugging）"></a>调试（Debugging）</h3><p>查看服务状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status toy.service<br></code></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">journalctl -u toy.service<br></code></pre></td></tr></table></figure><blockquote><p>提示：<br>可以省略 <code>.service</code><br>但如果是其他类型（target / socket / timer），必须写全</p></blockquote><hr><h3 id="让服务崩溃！（Crash-the-service-）"><a href="#让服务崩溃！（Crash-the-service-）" class="headerlink" title="让服务崩溃！（Crash the service!）"></a>让服务崩溃！（Crash the service!）</h3><p>systemd 的一大优势是：<br><strong>服务崩溃后可以自动恢复</strong>。</p><p>你可以通过以下方式让服务崩溃：</p><ul><li>发送 POST 请求到<br>  <code>http://localhost:5000/crash</code><br>  请求体为：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;crash&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;true&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>或手动向进程发送信号（kill）</li></ul><p>检查状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status toy.service<br></code></pre></td></tr></table></figure><p>状态应为 <code>inactive</code> 或 <code>failed</code>。</p><p><strong>问题 4：</strong><br>你是通过什么命令让服务崩溃的？</p><hr><h4 id="添加自动重启"><a href="#添加自动重启" class="headerlink" title="添加自动重启"></a>添加自动重启</h4><p>在 <code>/etc/systemd/system/toy.service</code> 的 <code>[Service]</code> 中加入：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">Restart</span>=always<br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>重新加载配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>再次启动并崩溃服务，你会看到它在 <strong>10 秒后自动重启</strong>。</p><p><strong>问题 5：</strong><br>上传你完整配置好的 <code>toy.service</code> 文件到 Gradescope。</p><hr><h2 id="第-2-部分：进程（Part-2-Processes）"><a href="#第-2-部分：进程（Part-2-Processes）" class="headerlink" title="第 2 部分：进程（Part 2: Processes）"></a>第 2 部分：进程（Part 2: Processes）</h2><p><strong>本部分无需提交作业，但你必须亲自操作以理解进程与 htop。</strong></p><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps<br></code></pre></td></tr></table></figure><p>示例输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">PID TTY          TIME CMD<br>3371 pts/2    00:00:00 zsh<br>3416 pts/2    00:00:00 ps<br></code></pre></td></tr></table></figure><p>在另一个终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sleep</span> 1000 &amp;<br></code></pre></td></tr></table></figure><p>再次运行 <code>ps</code>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">PID TTY          TIME CMD<br>3371 pts/2    00:00:00 zsh<br>3726 pts/2    00:00:00 sleep<br>3752 pts/2    00:00:00 ps<br></code></pre></td></tr></table></figure><p>在第一个终端运行 <code>ps</code>，你会发现 <code>sleep</code> 不显示。</p><p>为什么？（提示：TTY 列）</p><p>使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -u<br></code></pre></td></tr></table></figure><p>显示当前用户的所有进程。</p><p>终止 sleep：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> 3726<br></code></pre></td></tr></table></figure><p>常见用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef<br></code></pre></td></tr></table></figure><hr><h3 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h3><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install htop<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">htop<br></code></pre></td></tr></table></figure><p>按 <code>&lt;F2&gt;</code> → Display options → 勾选<br><strong>Hide userland process threads</strong></p><p>在另一个终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>该命令会耗尽哪种资源？<br>（可按 <code>&lt;</code> 切换排序方式）</p><p>结束后使用 <code>Ctrl+C</code> 退出。</p><hr><h3 id="进程层级结构（The-process-hierarchy）"><a href="#进程层级结构（The-process-hierarchy）" class="headerlink" title="进程层级结构（The process hierarchy）"></a>进程层级结构（The process hierarchy）</h3><p>在 htop 中按 <code>&lt;F5&gt;</code> 进入树形视图。</p><p>所有进程最终都源自 <code>/sbin/init</code>（systemd）。</p><hr><h3 id="孤儿进程（Orphan-processes）"><a href="#孤儿进程（Orphan-processes）" class="headerlink" title="孤儿进程（Orphan processes）"></a>孤儿进程（Orphan processes）</h3><p>在第二个终端 ssh 进 VM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sleep</span> 1000 &amp;<br></code></pre></td></tr></table></figure><p>在 htop 中找到该进程，查看其父进程。</p><p>杀死父进程（SIGTERM），sleep 会被 init（PID 1）收养。</p><p>再次尝试，向父进程发送 <code>SIGHUP</code>，观察 sleep 是否仍存在。</p><hr><h2 id="拓展阅读（Exploration）"><a href="#拓展阅读（Exploration）" class="headerlink" title="拓展阅读（Exploration）"></a>拓展阅读（Exploration）</h2><ul><li><p>init 系统（Wikipedia）<br>  <a href="https://en.wikipedia.org/wiki/Init">https://en.wikipedia.org/wiki/Init</a></p></li><li><p>构建一个基本 init 系统<br>  <a href="https://felipec.wordpress.com/2013/11/04/init/">https://felipec.wordpress.com/2013/11/04/init/</a></p></li><li><p>dumb-init<br>  <a href="https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html">https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html</a></p></li><li><p>僵尸进程<br>  <a href="https://www.howtogeek.com/119815/htg-explains-what-is-a-zombie-process-on-linux/">https://www.howtogeek.com/119815/htg-explains-what-is-a-zombie-process-on-linux/</a></p></li><li><p>Socket 激活<br>  <a href="http://0pointer.de/blog/projects/socket-activated-containers.html">http://0pointer.de/blog/projects/socket-activated-containers.html</a></p></li><li><p>关于 systemd 的争议<br>  <a href="http://without-systemd.org/wiki/index.php/Main_Page">http://without-systemd.org/wiki/index.php/Main_Page</a></p></li><li><p>Unix 线程 / 进程 / 会话详解<br>  <a href="https://www.win.tue.nl/~aeb/linux/lk/lk-10.html">https://www.win.tue.nl/~aeb/linux/lk/lk-10.html</a></p></li></ul><hr><h2 id="提交（Submission）"><a href="#提交（Submission）" class="headerlink" title="提交（Submission）"></a>提交（Submission）</h2><p>前往 <strong>Gradescope</strong> 提交你的作业答案。</p><h1 id="实验-4：进程与服务（Lab-4-–-Processes-and-Services）"><a href="#实验-4：进程与服务（Lab-4-–-Processes-and-Services）" class="headerlink" title="实验 4：进程与服务（Lab 4 – Processes and Services）"></a>实验 4：进程与服务（Lab 4 – Processes and Services）</h1><h2 id="一、实验概述"><a href="#一、实验概述" class="headerlink" title="一、实验概述"></a>一、实验概述</h2><p>本实验围绕 Linux 中的<strong>进程（process）</strong>与 <strong>systemd 服务（service）</strong>展开，通过实际操作 systemd、编写并管理自定义 Web 服务，以及使用进程管理工具（ps、htop）来理解系统中进程的运行机制和资源管理方式。</p><p>实验环境为基于 Ubuntu / Debian 的 Linux 虚拟机。</p><hr><h2 id="二、使用-systemd-管理服务（Part-1）"><a href="#二、使用-systemd-管理服务（Part-1）" class="headerlink" title="二、使用 systemd 管理服务（Part 1）"></a>二、使用 systemd 管理服务（Part 1）</h2><h3 id="问题-1：系统中正在运行的-systemd-服务"><a href="#问题-1：系统中正在运行的-systemd-服务" class="headerlink" title="问题 1：系统中正在运行的 systemd 服务"></a>问题 1：系统中正在运行的 systemd 服务</h3><p><strong>问题：</strong> 你系统上正在运行的一个 systemd 服务叫什么名字？它是做什么的？</p><p><strong>回答：</strong><br>系统中正在运行的一个 systemd 服务是 <strong><code>cron.service</code></strong>。</p><p><code>cron.service</code> 是一个后台守护进程，用于<strong>定期执行计划任务</strong>。它会根据系统或用户在 <code>crontab</code> 中配置的规则，在指定时间自动运行命令或脚本，例如日志清理、系统维护任务和自动备份等。该服务是 Linux 系统中实现任务自动化的重要组成部分。</p><hr><h3 id="问题-2：systemctl-reload-与-systemctl-restart-的区别"><a href="#问题-2：systemctl-reload-与-systemctl-restart-的区别" class="headerlink" title="问题 2：systemctl reload 与 systemctl restart 的区别"></a>问题 2：<code>systemctl reload</code> 与 <code>systemctl restart</code> 的区别</h3><p><strong>问题：</strong> <code>systemctl reload yourservice</code> 和 <code>systemctl restart yourservice</code> 有什么区别？</p><p><strong>回答：</strong><br><code>systemctl reload yourservice</code> 会在<strong>不终止服务进程</strong>的情况下重新加载服务的配置文件，适用于支持热加载（hot reload）的服务，例如 nginx，可以在不中断现有连接的情况下更新配置。</p><p><code>systemctl restart yourservice</code> 会<strong>先停止服务进程，再重新启动服务</strong>，这会导致服务短暂不可用，但能够确保程序状态和配置被完全重置，适用于不支持 reload 的服务或服务状态异常时。</p><hr><h3 id="创建并管理-Web-服务（toy-service）"><a href="#创建并管理-Web-服务（toy-service）" class="headerlink" title="创建并管理 Web 服务（toy.service）"></a>创建并管理 Web 服务（toy.service）</h3><p>本实验要求将提供的 Web 服务器脚本交由 systemd 管理，而不是手动运行。</p><h4 id="systemd-服务文件示例"><a href="#systemd-服务文件示例" class="headerlink" title="systemd 服务文件示例"></a>systemd 服务文件示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=Toy Web Server (DeCal Lab 4)<br>After=network.target<br>Wants=network.target<br><br>[Service]<br>Type=simple<br>User=jay<br>WorkingDirectory=/home/jay/LSAD/decal-labs/4<br>ExecStart=/home/jay/LSAD/decal-labs/4/run<br>Restart=always<br>RestartSec=10<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><ul><li><p><code>After=network.target</code>：确保网络可用后再启动 Web 服务</p></li><li><p><code>User=jay</code>：避免使用 root 用户运行 Web 服务，提高安全性</p></li><li><p><code>ExecStart</code>：使用绝对路径指定启动脚本</p></li><li><p><code>Restart=always</code>：服务崩溃后自动重启</p></li></ul><p>通过 <code>systemctl start toy.service</code>、<code>systemctl stop toy.service</code>、<code>systemctl status toy.service</code> 等命令即可统一管理该 Web 服务。</p><hr><h3 id="问题-4：如何让服务崩溃"><a href="#问题-4：如何让服务崩溃" class="headerlink" title="问题 4：如何让服务崩溃"></a>问题 4：如何让服务崩溃</h3><p><strong>问题：</strong> 你是通过什么命令让服务崩溃的？</p><p><strong>回答：</strong><br>我是通过向 Web 服务器发送一个特定的 HTTP 请求来触发其崩溃的，使用的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X POST -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> \<br>     -d <span class="hljs-string">&#x27;&#123;&quot;crash&quot;:&quot;true&quot;&#125;&#x27;</span> http://localhost:5000/crash<br></code></pre></td></tr></table></figure><p>该请求会触发服务器程序中预先实现的崩溃逻辑，使主进程退出，systemd 随即将服务标记为失败状态。</p><hr><h3 id="自动重启机制说明"><a href="#自动重启机制说明" class="headerlink" title="自动重启机制说明"></a>自动重启机制说明</h3><p>在 <code>toy.service</code> 中加入以下配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">Restart</span>=always<br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>当服务因异常退出或被信号终止时，systemd 会等待 10 秒后重新执行 <code>ExecStart</code>，从而实现服务的自动恢复，提高服务的可靠性与可用性。</p><hr><h2 id="三、进程管理与资源观察（Part-2）"><a href="#三、进程管理与资源观察（Part-2）" class="headerlink" title="三、进程管理与资源观察（Part 2）"></a>三、进程管理与资源观察（Part 2）</h2><h3 id="htop-与-yes-命令实验"><a href="#htop-与-yes-命令实验" class="headerlink" title="htop 与 yes 命令实验"></a>htop 与 yes 命令实验</h3><p>安装并运行 <code>htop</code> 后，在另一个终端执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p><strong>实验现象：</strong></p><ul><li><p>在 htop 中可以观察到 <code>yes</code> 进程的 CPU 使用率接近 100%</p></li><li><p>内存和磁盘 I/O 使用率变化不明显</p></li></ul><p><strong>结论：</strong><br><code>yes</code> 命令在无限循环中不断向标准输出打印字符，几乎不进行阻塞或休眠操作，因此会持续占用 CPU 时间。该实验表明该命令主要<strong>耗尽的是 CPU 资源</strong>。</p><hr>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LSAD</tag>
      
      <tag>lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OCF Linux System Administration DeCal lab3</title>
    <link href="/2026/02/08/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20lab3/"/>
    <url>/2026/02/08/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="实验-3：软件包与打包（Packages-and-Packaging）"><a href="#实验-3：软件包与打包（Packages-and-Packaging）" class="headerlink" title="实验 3：软件包与打包（Packages and Packaging）"></a>实验 3：软件包与打包（Packages and Packaging）</h1><p>OCF 系统管理员 DeCal</p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="https://decal.ocf.berkeley.edu/labs/3/#about-this-lab">关于本实验</a><ul><li><a href="https://decal.ocf.berkeley.edu/labs/3/#grading-note">评分说明</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/3/#workflow">实验流程</a></li></ul></li><li><a href="https://decal.ocf.berkeley.edu/labs/3/#debian-an-introduction-to-apt-and-dpkg">Debian：<code>apt</code> 与 <code>dpkg</code> 简介</a><ul><li><a href="https://decal.ocf.berkeley.edu/labs/3/#apt"><code>apt</code></a></li><li><a href="https://decal.ocf.berkeley.edu/labs/3/#dpkg"><code>dpkg</code></a></li></ul></li><li><a href="https://decal.ocf.berkeley.edu/labs/3/#getting-started">开始之前</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/3/#exercise-1-compiling-and-packaging">练习 1：编译与打包</a><ul><li><a href="https://decal.ocf.berkeley.edu/labs/3/#writing-and-compiling-the-program">编写并编译程序</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/3/#packaging-the-executable">将可执行文件打包</a></li></ul></li><li><a href="https://decal.ocf.berkeley.edu/labs/3/#exercise-2-troubleshooting">练习 2：故障排查</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/3/#exercise-3-spelunking">练习 3：深入探索（Spelunking）</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/3/#for-hotshots">进阶挑战（For Hotshots）</a></li><li><a href="https://decal.ocf.berkeley.edu/labs/3/#resources">参考资源</a></li></ul><hr><h2 id="关于本实验"><a href="#关于本实验" class="headerlink" title="关于本实验"></a>关于本实验</h2><h3 id="评分说明"><a href="#评分说明" class="headerlink" title="评分说明"></a>评分说明</h3><p>实验是 <strong>按完成情况评分</strong> 的。请将本实验视为探索的起点，而不仅仅是为了拿到一个分数。</p><h3 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h3><p>本实验应当在你的 <strong>Linux 虚拟机</strong> 上完成，而不是在 tsunami 上完成。<br>实验的部分步骤可能需要 <strong>root 权限</strong>。</p><hr><h2 id="Debian：apt-与-dpkg-简介"><a href="#Debian：apt-与-dpkg-简介" class="headerlink" title="Debian：apt 与 dpkg 简介"></a>Debian：<code>apt</code> 与 <code>dpkg</code> 简介</h2><p>在本课程中，我们将主要使用 <strong>Debian</strong>。正如本周课程中所提到的，Debian 使用 <strong>apt/dpkg</strong> 作为其软件包管理系统。<br>其他 Linux 发行版会使用不同的包管理器。</p><hr><h3 id="apt"><a href="#apt" class="headerlink" title="apt"></a><code>apt</code></h3><p>Debian 的前端包管理器是 <strong><code>apt</code></strong>。在大多数情况下，只要你需要和包管理器打交道，<code>apt</code> 通常就是首选工具。</p><p>在使用 <code>apt</code> 之前，一个良好的习惯是 <strong>先更新软件包列表</strong>，以确保包管理器可以找到并获取最新版本的软件包。可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update<br></code></pre></td></tr></table></figure><p>查找要安装的软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt search [软件包名 | 描述]<br></code></pre></td></tr></table></figure><p>安装软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install [软件包名]<br></code></pre></td></tr></table></figure><p>移除软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt remove [软件包名]<br></code></pre></td></tr></table></figure><p>在使用已安装的软件一段时间后，你可能会注意到它们 <strong>不会自动更新</strong>（这在其他操作系统中有时是默认行为）。<br>要更新系统中已安装的软件包，请运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt upgrade<br></code></pre></td></tr></table></figure><p>或者在某些情况下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt dist-upgrade<br></code></pre></td></tr></table></figure><p>通常情况下使用 <code>apt upgrade</code> 就足够了，但在某些特定场景下需要使用 <code>apt dist-upgrade</code>。<br>关于这两者的区别，可以阅读这里的说明：<br><a href="https://askubuntu.com/questions/194651/why-use-apt-get-upgrade-instead-of-apt-get-dist-upgrade">https://askubuntu.com/questions/194651/why-use-apt-get-upgrade-instead-of-apt-get-dist-upgrade</a></p><p>在某些情况下，你可能希望 <strong>精确控制要安装的软件包版本</strong>。<br>要查看可以安装的版本列表，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt policy [软件包名]<br></code></pre></td></tr></table></figure><p>该命令会根据优先级（pin priority）列出候选安装版本，以及系统兼容的其他版本。</p><p>要为指定的目标发行版安装软件包，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt -t [目标发行版] install [软件包名]<br></code></pre></td></tr></table></figure><p>此外，<code>apt</code> 还有一些用于清理不再需要的依赖、彻底清除软件包的命令，这些可以通过 <code>man</code> 手册查看。</p><p>⚠️ 注意：<br>由于上述命令会直接修改系统，你通常需要使用 <code>sudo</code> 来运行它们。</p><hr><h3 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a><code>dpkg</code></h3><p><strong><code>dpkg</code></strong> 是 Debian 的 <strong>后端包管理器</strong>。<br>传统上，<code>dpkg</code> 主要用于 <strong>安装本地的软件包</strong>。<br>使用 <code>dpkg</code> 你还可以检查软件包信息，以及修复损坏的安装。</p><p>安装本地软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -i [软件包文件名]<br></code></pre></td></tr></table></figure><p>移除系统中的软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg --remove [软件包名]<br></code></pre></td></tr></table></figure><p>查看软件包的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -I [软件包文件名]<br></code></pre></td></tr></table></figure><p>修复或配置所有已解包但尚未完成配置的安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg --configure -a<br></code></pre></td></tr></table></figure><hr><h2 id="开始之前（Getting-Started）"><a href="#开始之前（Getting-Started）" class="headerlink" title="开始之前（Getting Started）"></a>开始之前（Getting Started）</h2><p>在本实验中，我们将使用：</p><ul><li><code>gcc</code>：用于编译源代码  </li><li><code>fpm</code>：一个简单的打包工具  </li></ul><p>首先，使用前面介绍的命令安装以下软件：</p><ul><li><code>gcc</code></li><li><code>make</code></li><li><code>ruby-dev</code></li><li><code>ruby-ffi</code></li></ul><p>然后检查 GCC 和 Ruby 是否已安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc --version<br>ruby --version<br></code></pre></td></tr></table></figure><p>接着，使用 Ruby 自带的包管理器 <code>gem</code> 安装 <code>fpm</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> gem install fpm<br></code></pre></td></tr></table></figure><p>检查 <code>fpm</code> 是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fpm<br></code></pre></td></tr></table></figure><p>现在克隆 <code>decal-labs</code> 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/0xcf/decal-labs.git<br></code></pre></td></tr></table></figure><hr><h2 id="练习-1：编译与打包"><a href="#练习-1：编译与打包" class="headerlink" title="练习 1：编译与打包"></a>练习 1：编译与打包</h2><p>手动为 Debian 打包软件通常非常困难且容易令人沮丧，尤其是对初学者而言。<br>因此，在本课程中我们将使用一个非常实用的 Ruby 工具 —— <strong>fpm</strong>，它可以大大简化打包过程。</p><p><strong>注意：</strong><br>这种方法非常适合快速打包或回移植（backport）你自己的应用程序，但并不完全符合<br><a href="https://www.debian.org/doc/manuals/maint-guide/">Debian 新维护者指南</a> 所规定的正式标准。</p><p>如果你想挑战自己，可以尝试不用 <code>fpm</code>，而是根据以下文档使用 <code>dpkg-buildpackage</code>：<br><a href="https://www.debian.org/doc/manuals/maint-guide/build.en.html">https://www.debian.org/doc/manuals/maint-guide/build.en.html</a></p><hr><h3 id="编写并编译程序"><a href="#编写并编译程序" class="headerlink" title="编写并编译程序"></a>编写并编译程序</h3><p>我们将编写一个非常简单的 C 程序，名为 <strong>hellopenguin</strong>，它会输出：</p><blockquote><p>Hello Penguin!</p></blockquote><p>创建源文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> hellopenguin.c<br></code></pre></td></tr></table></figure><p>使用你喜欢的编辑器（如 <code>vim</code>、<code>emacs</code> 或 <code>nano</code>），在 <code>hellopenguin.c</code> 中写入以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello Penguin!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译该程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc hellopenguin.c -o hellopenguin<br></code></pre></td></tr></table></figure><p>该命令会将源文件 <code>hellopenguin.c</code> 编译为名为 <code>hellopenguin</code> 的可执行文件。</p><hr><h3 id="将可执行文件打包"><a href="#将可执行文件打包" class="headerlink" title="将可执行文件打包"></a>将可执行文件打包</h3><p>在 Debian 中，用户级可执行程序通常放在 <code>/usr/bin/</code> 目录下。</p><p>创建目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p packpenguin/usr/bin<br></code></pre></td></tr></table></figure><p>将编译好的可执行文件移动进去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> hellopenguin packpenguin/usr/bin/<br></code></pre></td></tr></table></figure><p>现在创建名为 <code>hellopenguin</code> 的 <code>.deb</code> 软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fpm -s <span class="hljs-built_in">dir</span> -t deb -n hellopenguin -v 1.0~ocf1 -C packpenguin<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-s dir</code>：输入源是一个目录  </li><li><code>-t deb</code>：输出为 <code>.deb</code> 软件包  </li><li><code>-n hellopenguin</code>：包名  </li><li><code>-v 1.0~ocf1</code>：版本号  </li><li><code>-C packpenguin</code>：指定打包目录  </li></ul><p>安装生成的软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dpkg -i ./hellopenguin_1.0~ocf1_amd64.deb<br></code></pre></td></tr></table></figure><blockquote><p>对于 M1 用户，文件名可能是 <code>hellopenguin_1.0~ocf1_arm64.deb</code></p></blockquote><p>现在你应该可以直接运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hellopenguin<br></code></pre></td></tr></table></figure><hr><h2 id="练习-2：故障排查"><a href="#练习-2：故障排查" class="headerlink" title="练习 2：故障排查"></a>练习 2：故障排查</h2><p>进入 <code>ex2</code> 目录，尝试使用 <code>dpkg</code> 安装 <code>ocfspy</code> 软件包。<br>该安装过程 <strong>应该会报错</strong>，请注意错误信息。</p><p><strong>提示：</strong></p><ul><li>检查软件包内容以获取更多信息  </li><li>生成该程序的源文件就在目录中  </li><li>可以参考练习 1 的编译与打包流程  </li></ul><p>完成后，请回答并在 Gradescope 上提交以下问题。</p><h3 id="编译与打包"><a href="#编译与打包" class="headerlink" title="编译与打包"></a>编译与打包</h3><ol><li>如果我们将 <code>hellopenguin</code> 打包到 <code>/usr/share</code> 而不是 <code>/usr/bin</code>，还能从任意目录运行它吗？</li><li>你对上一问的理由是什么？</li></ol><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ol><li>在安装 <code>ocfspy</code> 时，缺失的是哪个软件包？</li><li>修复依赖问题后，<code>ocfspy</code> 输出的密码是什么？</li></ol><p>完成后，你可能希望从系统中移除 <code>hellopenguin</code>、<code>ocfdocs</code> 和 <code>ocfspy</code> 以清理虚拟机环境。</p><hr><h2 id="练习-3：深入探索（Spelunking）"><a href="#练习-3：深入探索（Spelunking）" class="headerlink" title="练习 3：深入探索（Spelunking）"></a>练习 3：深入探索（Spelunking）</h2><p>我们将换一个角度，通过分析一个真实的软件包来了解其内部结构。</p><p>请选择一个 Debian 仓库中的软件包下载并解包，例如：</p><ul><li><code>tmux</code></li><li><code>sl</code></li><li><code>tree</code></li></ul><p>或从以下列表中选择：<br><a href="https://packages.debian.org/stable/">https://packages.debian.org/stable/</a></p><p>⚠️ 注意：<br>本练习主要用于 <strong>学习与探索</strong>，你实际上不会通过这种方式来安装软件包。</p><p>完成解包后，请在 Gradescope 上回答以下问题：</p><ol><li>你选择了哪个软件包？</li><li>该软件包的依赖是什么？在哪个文件中可以找到？</li><li>解包 <code>data.tar.gz</code> 并查看其内容。如果存在除 <code>usr/bin/</code> 和 <code>usr/share/</code> 以外的目录，请选择一个并说明其用途。</li><li>你还发现了该软件包的哪一个有趣之处？</li></ol><p><strong>提示：</strong></p><ul><li>下载软件包的命令是：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt download &lt;软件包名&gt;<br></code></pre></td></tr></table></figure></li><li>使用 <code>aunpack</code> 可能需要先安装：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install atool<br></code></pre></td></tr></table></figure></li><li>建议选择体积较小的软件包  </li><li>课程中的演示视频会非常有帮助  </li></ul><hr><h2 id="进阶挑战（For-Hotshots）"><a href="#进阶挑战（For-Hotshots）" class="headerlink" title="进阶挑战（For Hotshots）"></a>进阶挑战（For Hotshots）</h2><p>在之前的示例中，我们都是 <strong>先编译，再打包</strong>。<br>这种方式的好处是：软件包只要运行环境相似，就能正常工作。</p><p>但一旦涉及不同的硬件架构，就需要为不同系统分别编译并打包。</p><p><strong>挑战：</strong></p><p>创建一个新的软件包，该软件包在安装过程中：</p><ol><li>解压源代码  </li><li>编译程序  </li><li>将相关文件移动到正确位置  </li><li>删除无关文件  </li></ol><hr><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>以下资源在编写本实验时非常有帮助，如果你有兴趣，可以进一步阅读：</p><ul><li>fpm<br><a href="https://github.com/jordansissel/fpm/wiki">https://github.com/jordansissel/fpm/wiki</a></li><li>TLDR pages（更易读的 man 手册）<br><a href="https://tldr.sh/">https://tldr.sh/</a></li><li>dpkg<br><a href="https://linux.die.net/man/1/dpkg">https://linux.die.net/man/1/dpkg</a> 或 <code>man dpkg</code></li><li>apt<br><a href="https://linux.die.net/man/8/apt">https://linux.die.net/man/8/apt</a> 或 <code>man apt</code></li><li>Debian 新维护者指南<br><a href="https://www.debian.org/doc/manuals/maint-guide/">https://www.debian.org/doc/manuals/maint-guide/</a></li></ul><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>本实验的目的是通过使用 <code>dpkg</code> 安装本地 <code>.deb</code> 软件包，理解 Debian 包管理中 <strong>依赖关系处理机制</strong>，并掌握在依赖缺失时的排错与修复流程。</p><p>重点在于理解以下概念：</p><ul><li><code>dpkg</code> 是底层包管理工具，不会自动解决依赖</li><li>依赖缺失会导致软件包处于 <em>unconfigured</em> 状态</li><li>需要通过分析报错信息并手动补齐依赖来完成安装</li></ul><hr><h2 id="二、实验过程与问题定位"><a href="#二、实验过程与问题定位" class="headerlink" title="二、实验过程与问题定位"></a>二、实验过程与问题定位</h2><h3 id="1-尝试安装-ocfspy"><a href="#1-尝试安装-ocfspy" class="headerlink" title="1. 尝试安装 ocfspy"></a>1. 尝试安装 ocfspy</h3><p>在 <code>ex2</code> 目录中，尝试使用 <code>dpkg</code> 安装 <code>ocfspy</code> 软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dpkg -i ocfspy_1.0~ocf1_amd64.deb<br></code></pre></td></tr></table></figure><p>安装过程中出现如下错误信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">dpkg: dependency problems prevent configuration of ocfspy:<br> ocfspy depends on ocfdocs; however:<br>  Package ocfdocs is not installed.<br><br>dpkg: error processing package ocfspy (--install):<br> dependency problems - leaving unconfigured<br></code></pre></td></tr></table></figure><p>由此可以确认，<code>ocfspy</code> 在安装时由于 <strong>依赖包缺失</strong> 而无法完成配置。</p><hr><h3 id="2-确认缺失依赖"><a href="#2-确认缺失依赖" class="headerlink" title="2. 确认缺失依赖"></a>2. 确认缺失依赖</h3><p>从 <code>dpkg</code> 的错误提示中可以直接看出：</p><ul><li><code>ocfspy</code> 依赖的软件包是 <code>ocfdocs</code></li><li>当前系统中未安装该软件包</li></ul><p>因此，问题的根本原因是：  </p><blockquote><p><strong><code>ocfdocs</code> 软件包未安装，导致 <code>ocfspy</code> 无法完成配置</strong></p></blockquote><hr><h2 id="三、修复依赖并完成安装"><a href="#三、修复依赖并完成安装" class="headerlink" title="三、修复依赖并完成安装"></a>三、修复依赖并完成安装</h2><h3 id="1-编译-ocfdocs-程序"><a href="#1-编译-ocfdocs-程序" class="headerlink" title="1. 编译 ocfdocs 程序"></a>1. 编译 ocfdocs 程序</h3><p>实验目录中提供了 <code>ocfdocs.c</code> 源文件，首先将其编译为可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc ocfdocs.c -o ocfdocs<br></code></pre></td></tr></table></figure><hr><h3 id="2-使用-fpm-打包-ocfdocs"><a href="#2-使用-fpm-打包-ocfdocs" class="headerlink" title="2. 使用 fpm 打包 ocfdocs"></a>2. 使用 fpm 打包 ocfdocs</h3><p>使用 <code>fpm</code> 将编译得到的可执行文件打包为 <code>.deb</code> 软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fpm -s <span class="hljs-built_in">dir</span> -t deb -n ocfdocs ./ocfdocs<br></code></pre></td></tr></table></figure><p>生成的软件包为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ocfdocs_1.0_amd64.deb<br></code></pre></td></tr></table></figure><hr><h3 id="3-安装-ocfdocs"><a href="#3-安装-ocfdocs" class="headerlink" title="3. 安装 ocfdocs"></a>3. 安装 ocfdocs</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dpkg -i ocfdocs_1.0_amd64.deb<br></code></pre></td></tr></table></figure><p>安装完成后，<code>ocfdocs</code> 已成功注册到系统中。</p><hr><h3 id="4-重新安装-ocfspy"><a href="#4-重新安装-ocfspy" class="headerlink" title="4. 重新安装 ocfspy"></a>4. 重新安装 ocfspy</h3><p>在依赖补齐后，再次安装 <code>ocfspy</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dpkg -i ocfspy_1.0~ocf1_amd64.deb<br></code></pre></td></tr></table></figure><p>此时安装顺利完成，说明依赖问题已被成功修复。</p><hr><h2 id="四、问题回答（Gradescope）"><a href="#四、问题回答（Gradescope）" class="headerlink" title="四、问题回答（Gradescope）"></a>四、问题回答（Gradescope）</h2><h3 id="编译与打包-1"><a href="#编译与打包-1" class="headerlink" title="编译与打包"></a>编译与打包</h3><p><strong>问题 1：</strong><br>如果将 <code>hellopenguin</code> 打包到 <code>/usr/share</code> 而不是 <code>/usr/bin</code>，是否还能从任意目录运行？</p><p><strong>回答：</strong><br>通常不能直接从任意目录运行。</p><hr><p><strong>问题 2：</strong><br>请说明理由。</p><p><strong>理由说明：</strong></p><ul><li>Shell 在执行命令时，会按照环境变量 <code>PATH</code> 中列出的目录顺序查找可执行文件</li><li><code>/usr/bin</code> 通常包含在 <code>PATH</code> 中，用于存放用户可执行程序</li><li><code>/usr/share</code> 按照 Linux 文件系统层次结构（FHS）的约定，用于存放与体系结构无关的共享数据（如文档、资源文件等），通常不在 <code>PATH</code> 中</li><li>因此，将可执行文件放入 <code>/usr/share</code> 后，除非使用完整路径或手动修改 <code>PATH</code>，否则无法直接从任意目录运行</li></ul><hr><h3 id="调试（Debugging）"><a href="#调试（Debugging）" class="headerlink" title="调试（Debugging）"></a>调试（Debugging）</h3><p><strong>问题 1：</strong><br>在安装 <code>ocfspy</code> 时，缺失的是哪个软件包？</p><p><strong>回答：</strong><br>缺失的软件包是 <code>ocfdocs</code>。</p><p>该结论直接来源于 <code>dpkg</code> 的错误提示信息，明确指出 <code>ocfspy</code> 依赖 <code>ocfdocs</code>，但系统中未安装该软件包。</p><hr><p><strong>问题 2：</strong><br>修复依赖问题后，<code>ocfspy</code> 输出的密码是什么？</p><p><strong>回答：</strong><br>The password is Sinkhole.</p><hr>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LSAD</tag>
      
      <tag>lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OCF Linux System Administration DeCal lab1</title>
    <link href="/2026/01/29/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20lab1/"/>
    <url>/2026/01/29/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20lab1/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介 #"></a>简介 <a href="https://decal.ocf.berkeley.edu/labs/1/#introduction">#</a></h2><p>欢迎来到第一次实验！</p><p>所有实验都会根据<strong>完整度和投入程度</strong>进行评分，所以不用太担心是否得到完全正确的答案。（我们会在实验截止后发布助教参考答案！）</p><p>实验通常在布置后一周截止。如果你需要帮助，记得在 Edstem 或 Discord / Matrix / IRC 的 <code>#decal</code> 频道提问！</p><p>在完成实验的同时，将答案同步提交到 Gradescope 可能会比较方便。</p><p><strong>实用小技巧（Pro Tips）</strong></p><ul><li>以下命令可能会对你有所帮助：<br><code>vim, ls, cd, man, file, grep, cat, less, wget, nano, tar, ...</code>（以及其他较差的文本编辑器）</li><li>Google 和 <code>man</code> 是你的好朋友！</li></ul><p><strong>有多余时间？想让这个实验更简单一些？</strong></p><ul><li>如果你想在开始实验前更熟悉 vim，可以运行 <code>vimtutor</code> 命令完成 vim 教程。</li><li>查看 <a href="https://labex.io/linuxjourney">linuxjourney.com</a>，尤其是其中的<br>“Command Line”、“Text-Fu” 和 “Advanced Text-Fu” 部分。</li></ul><hr><h2 id="第一部分：Shell-探险"><a href="#第一部分：Shell-探险" class="headerlink" title="第一部分：Shell 探险 #"></a>第一部分：Shell 探险 <a href="https://decal.ocf.berkeley.edu/labs/1/#part-1-shell-spelunking">#</a></h2><p><strong>所有操作都必须通过 shell 完成！</strong></p><p>本实验的目的是让你熟悉使用 shell 来完成你通常会使用图形界面（GUI）完成的事情。虽然这些任务看起来可能很简单或受限，但你很快就会发现，这些命令拥有大量不同的选项（flags），可以完成许多使用传统方法几乎不可能或极其繁琐的操作。</p><p>现在不需要完全理解这些命令是如何工作的——只要你能逐渐熟悉这些工具即可。下周我们将更深入地探索它们！</p><ol><li>使用你的 OCF 账号，在 OCF 的台式机、笔记本或其他电脑上，通过 <code>ssh</code> 登录：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>tsunami<span class="hljs-selector-class">.ocf</span><span class="hljs-selector-class">.berkeley</span><span class="hljs-selector-class">.edu</span><br><br></code></pre></td></tr></table></figure><ol><li>运行以下命令下载我们提供的文件：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>wget [https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/0xcf/</span>decal-labs<span class="hljs-regexp">/raw/m</span>aster<span class="hljs-regexp">/b1/</span>b01.tgz](https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/0xcf/</span>decal-labs<span class="hljs-regexp">/raw/m</span>aster<span class="hljs-regexp">/b1/</span>b01.tgz)<br><br></code></pre></td></tr></table></figure><p><code>.tgz</code> 文件实际上是两种文件格式的组合。有时你也会看到 <code>.tar.gz</code>。</p><p>一种常见（而且很古老）的归档方式是使用磁带。然而，为了进行归档，数据必须是单个文件，而我们往往希望一次归档多个文件。这正是 <code>tar</code> 命令的用途（<code>tar</code> 是 <em>tape archive</em> 的缩写）。</p><p><code>tar</code> 会将多个文件打包（或解包）成一个文件。</p><p>但除非你明确要求，否则 <code>tar</code> 本身并不会进行压缩。这时就需要使用 <code>gzip</code>（或 <code>bzip2</code>）。</p><p><code>gzip</code> 会压缩文件，因此通常会联合使用 tar + gzip。流程如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><br>file --<span class="hljs-function"><span class="hljs-params">(tar)</span>--&gt;</span> file.tar --<span class="hljs-function"><span class="hljs-params">(gzip)</span>--&gt;</span> file.tar.gz<br><br></code></pre></td></tr></table></figure><p>如果你仔细阅读 <code>tar</code> 的文档，会发现可以通过一个选项让它在打包时同时使用 <code>gzip</code>，从而节省一整行 shell 命令！</p><p>要解压我们提供的文件，请运行：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>tar xvzf <span class="hljs-keyword">b01.tgz</span><br><span class="hljs-keyword"></span><br></code></pre></td></tr></table></figure><p>这会生成一个名为 <code>b01</code> 的目录，供你完成本实验的其余部分。</p><p><code>tar</code> 因其参数选项复杂而“臭名昭著”：</p><p><img src="https://imgs.xkcd.com/comics/tar.png" alt="XKCD 1168" title="我不知道更糟糕的是：使用 tar 15 年后我依旧记不住参数，还是在技术进步了 15 年之后，我仍然在折腾那些在我刚开始用 tar 时就已经 15 岁的参数。"></p><ol><li><p>进入 <code>b01</code> 目录。运行 <code>pwd</code>（Present Working Directory）确保你在该目录中。<br><strong>从概念上讲，<code>pwd</code> 输出的是什么？</strong></p></li><li><p><code>b01</code> 目录中有一个隐藏文件。<br><strong>秘密是什么？</strong></p></li></ol><blockquote><p>hunter2</p></blockquote><ol><li>一个恶意用户入侵了我的电脑，并在 <code>nonsense/</code> 目录中的所有文件里分散留下了一条信息。<br>这条信息写了什么？<br><strong>你是如何找到这条信息的？</strong></li></ol><h3 id="1-cat-naming-is-hard-：批量读取"><a href="#1-cat-naming-is-hard-：批量读取" class="headerlink" title="1. cat naming_is_hard*：批量读取"></a>1. <code>cat naming_is_hard*</code>：批量读取</h3><ul><li><p><strong><code>cat</code></strong>: 这个命令的作用是“连接（concatenate）并打印”文件内容。</p></li><li><p><strong><code>naming_is_hard*</code></strong>: 这里的 <code>*</code> 是一个<strong>通配符</strong>。</p><ul><li><p>它告诉 Shell：“帮我找到当前目录下所有以 <code>naming_is_hard</code> 开头的文件。”</p></li><li><p>因为你的文件末尾有编号（00, 01, 02…），Shell 会按照<strong>字母/数字顺序</strong>将它们排列好。</p></li></ul></li><li><p><strong>结果</strong>：它会将这 19 个文件的内容按顺序首尾相连地“喷”出来。</p></li></ul><h3 id="2-管道符-：接力传输"><a href="#2-管道符-：接力传输" class="headerlink" title="2. | (管道符)：接力传输"></a>2. <code>|</code> (管道符)：接力传输</h3><ul><li><p><strong>作用</strong>：管道符就像一根水管。</p></li><li><p>它把左边 <code>cat</code> 命令产生的全部文字（原本要显示在屏幕上的），直接传送到右边命令的“入口”。</p></li></ul><h3 id="3-tr-d-39-n-39-：清理格式"><a href="#3-tr-d-39-n-39-：清理格式" class="headerlink" title="3. tr -d &#39;\n&#39;：清理格式"></a>3. <code>tr -d &#39;\n&#39;</code>：清理格式</h3><ul><li><p><strong><code>tr</code></strong>: 代表 “translate”，用于转换或删除字符。</p></li><li><p><strong><code>-d</code></strong>: 代表 “delete”（删除）。</p></li><li><p><strong><code>&#39;\n&#39;</code></strong>: 代表 <strong>换行符</strong>。</p></li><li><p><strong>为什么要写这一步？</strong></p><ul><li><p>通常每个文件存入内容时，结尾可能自带一个换行。如果你直接 <code>cat</code>，输出可能是 19 行零散的字符。</p></li><li><p>删除换行符后，所有文件里的碎片会被<strong>强行挤在同一行</strong>，组成一个完整的句子或字符串。</p></li></ul></li></ul><hr><ol><li><p>使用一条命令删除 <code>nonsense/</code> 中的所有内容。<br><strong>你是如何做到的？</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Bash</span><br><br>rm -rf nonsense/*<br><br>---<br><br><span class="hljs-section">### ⚠️ 危险指令说明：请务必核对路径</span><br><br>在执行这条命令前，请确保你已经通过 <span class="hljs-code">`ls`</span> 确认了你确实在 <span class="hljs-code">`nonsense/`</span> 的上一级目录，或者使用的是绝对路径。<br><br><span class="hljs-section">### 命令拆解：</span><br><br><span class="hljs-bullet">*</span> <span class="hljs-code">`rm`</span>：代表 &quot;remove&quot;（删除）。<br><span class="hljs-bullet">*</span> <span class="hljs-code">`-r`</span>：代表 &quot;recursive&quot;（递归）。它会告诉系统删除文件夹下的所有文件以及子文件夹。<br><span class="hljs-bullet">*</span> <span class="hljs-code">`-f`</span>：代表 &quot;force&quot;（强制）。它会跳过确认步骤，直接删除那些受保护的文件（除非你没有权限），且在文件不存在时不会报错。<br><span class="hljs-bullet">*</span> <span class="hljs-code">`nonsense/*`</span>：<br><span class="hljs-bullet">    *</span> <span class="hljs-code">`nonsense/`</span> 指定了目标目录。<br><span class="hljs-bullet">    *</span> <span class="hljs-code">`*`</span> 是通配符，代表“该目录下的所有东西”。使用它意味着你保留了 <span class="hljs-code">`nonsense/`</span> 这个文件夹本身，但清空了它的“肚子”。<br></code></pre></td></tr></table></figure></li><li><p><code>b01</code> 中有一个名为 <code>big_data.txt</code> 的文件。<br>它包含 80 MB 的随机文本。</p></li></ol><p>作为对比：列夫·托尔斯泰的《战争与和平》这本描写法国入侵俄国、拿破仑时代对沙皇社会影响、并通过五个俄国贵族家庭展开叙事、且包含大量哲学独白章节的巨著，全文也只有 <strong>3.2 MB</strong>。</p><p>因此，我不推荐你使用 <code>cat</code> 来打印这个文件。你可以试试，但你会等很久。</p><p>文件中有你需要找到的文本！请在<strong>不真正打开整个文件</strong>的情况下找到它。</p><p>在文件中唯一的 URL 上方两行，有一个隐藏答案。<br><strong>这个答案是什么？</strong></p><p>=================== THE SOLUTION IS MORE COFFEE ===============================</p><p>请在终端输入以下命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">grep -<span class="hljs-keyword">B </span><span class="hljs-number">2</span> <span class="hljs-string">&quot;http&quot;</span> <span class="hljs-keyword">big_data.txt</span><br><span class="hljs-keyword"></span><br>🔍 命令参数解析<br><br>grep：强大的文本搜索工具，它会逐行扫描文件，而不会把整个大文件一次性加载到内存中。<br><br><span class="hljs-string">&quot;http&quot;</span>：这是我们要找的关键词。绝大多数 URL 都包含这个前缀。<br><br>-<span class="hljs-keyword">B </span><span class="hljs-number">2</span>：这里的 <span class="hljs-keyword">B </span>代表 <span class="hljs-keyword">Before（之前）。2 </span>表示打印匹配行及其前面的 <span class="hljs-number">2</span> 行内容。<br></code></pre></td></tr></table></figure><p>提示：  </p><ul><li>URL 是由什么构成的（https…）？  </li><li>什么是 <em>Context Line Control</em>？</li></ul><ol><li>尝试执行：</li></ol><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>./<span class="hljs-built_in">a_script</span><br><br></code></pre></td></tr></table></figure><p>你应该会看到：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix"><br>permission <span class="hljs-params">denied:</span> <span class="hljs-symbol">./a_script</span><br><br></code></pre></td></tr></table></figure><p>这是因为文件有三种不同的权限：</p><ul><li>读（read）</li><li>写（write）</li><li>执行（execute）</li></ul><p><strong><code>a_script</code> 缺少哪一种权限？</strong><br>修改文件权限，使你能够运行该脚本。<br><strong>你是如何做到的？</strong></p><h2 id="1-使用符号模式（推荐，更直观）"><a href="#1-使用符号模式（推荐，更直观）" class="headerlink" title="1. 使用符号模式（推荐，更直观）"></a>1. 使用符号模式（推荐，更直观）</h2><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x a_script<br></code></pre></td></tr></table></figure><ul><li><strong>解释：</strong> <code>+x</code> 表示为当前用户、组和其他用户同时<strong>添加（+）执行（x）权限</strong>。</li></ul><h2 id="2-使用绝对模式（数字模式）"><a href="#2-使用绝对模式（数字模式）" class="headerlink" title="2. 使用绝对模式（数字模式）"></a>2. 使用绝对模式（数字模式）</h2><p>如果你想赋予自己完全的读、写、执行权限，可以输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 755 a_script<br></code></pre></td></tr></table></figure><ul><li><strong>解释：</strong> <code>7</code> (4+2+1) 代表拥有者拥有读、写、执行权限；<code>5</code> (4+1) 代表组用户和其他用户拥有读和执行权限。</li></ul><ol><li>最后，目录中有一个名为 <code>hello_world</code> 的空文件。<br>请把你的名字写进去！<br><strong>你是如何完成的？</strong></li></ol><blockquote><p>打开我的vscode直接输入hello jayzhao</p></blockquote><hr><h2 id="第二部分：综合问题"><a href="#第二部分：综合问题" class="headerlink" title="第二部分：综合问题 #"></a>第二部分：综合问题 <a href="https://decal.ocf.berkeley.edu/labs/1/#part-2-general-questions">#</a></h2><p>你可以自由使用 Google，并在终端中（如适用）验证你的推测。</p><ol><li><p>Linux / OSX 与 Windows 等操作系统的主要区别是什么？</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>Linux / macOS 属于 <span class="hljs-strong">**类 Unix 系统**</span>，遵循 Unix 设计思想<br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span>Windows 使用 <span class="hljs-strong">**NT 内核**</span>，体系不同<br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span>Linux 使用单一目录树（<span class="hljs-code">`/`</span>），Windows 使用盘符（C:、D:）<br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span>Linux 权限严格，Windows 相对宽松<br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span>Linux 更适合服务器与开发环境<br></code></pre></td></tr></table></figure></li><li><p>命令行使用方式与普通（图形化）操作系统使用方式有哪些不同？</p></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">命令行：通过输入命令操作，支持脚本和自动化<br><br>图形界面：通过鼠标点击操作，直观但效率低<br><br>命令行适合批量、远程和重复操作<br><br>图形界面适合日常普通使用<br></code></pre></td></tr></table></figure><ol><li><p>Linux 文件系统中的根目录是什么？<br>请从概念层面回答，越深入越好。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>根目录是 <span class="hljs-code">`/`</span><br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span>是整个 Linux 文件系统的起点<br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span>所有文件、磁盘、设备最终都挂载在 <span class="hljs-code">`/`</span> 下<br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span>Linux 只有一棵目录树，没有盘符概念<br></code></pre></td></tr></table></figure></li><li><p><code>ls</code> 有很多有用的参数。请尝试使用它们获取以下信息：</p></li></ol><ul><li>文件权限  </li><li>所有者名称  </li><li>所属用户组  </li><li>文件大小  </li><li>最近修改日期  </li></ul><p>此外，我希望：</p><ul><li>显示文件大小  </li><li>按最后修改时间排序  </li><li>最旧的文件排在最上面  </li></ul><p>我该如何实现？<br><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ldif">示例命令：<br>ls -lhtr<br><br>各参数含义：<br>参数含义<br>ls列出目录内容（list）<br><span class="hljs-literal">-</span>l使用长格式显示详细信息<br><span class="hljs-literal">-</span>h以人类可读方式显示文件大小（KB / MB / GB）<br><span class="hljs-literal">-</span>t按最后修改时间排序<br><span class="hljs-literal">-</span>r反向排序（旧的在前，新 的在后）<br><br><span class="hljs-comment">### `-l` 显示的信息包括：</span><br><br>`-rw-r--r--  1 user group  4096  Jan 28 12:30 file.txt`<br><br>含义依次是：<br><br>1. 文件类型和权限<br>    <br>2. 硬链接数量<br>    <br>3. 所有者用户名<br>    <br>4. 所属用户组<br>    <br>5. 文件大小（字节）<br>    <br>6. 最近修改时间<br>    <br>7. 文件名<br></code></pre></td></tr></table></figure></p><ol><li><p>我希望使用 <code>head</code> 命令显示 <code>big_data.txt</code> 的前 <strong>4 行</strong>，而不是默认的 10 行。<br>我该怎么做？</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment">### 命令：</span><br><br>`head -n 4 big_data.txt`<br><br>---<br><br><span class="hljs-comment">### 参数说明：</span><br><br>|<span class="hljs-string">参数</span>|<span class="hljs-string">含义</span>|<br>|<span class="hljs-string">---</span>|<span class="hljs-string">---</span>|<br>|<span class="hljs-string">`head`</span>|<span class="hljs-string">显示文件开头内容</span>|<br>|<span class="hljs-string">`-n`</span>|<span class="hljs-string">指定显示的行数</span>|<br>|<span class="hljs-string">`4`</span>|<span class="hljs-string">显示前 4 行</span>|<br>|<span class="hljs-string">`big_data.txt`</span>|<span class="hljs-string">要读取的文件</span>|<br></code></pre></td></tr></table></figure></li><li><p>以下两条命令有什么区别？</p></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br><span class="hljs-keyword">cat</span> foo &gt; <span class="hljs-keyword">out</span>.txt<br><br></code></pre></td></tr></table></figure><p>与</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br><span class="hljs-keyword">cat</span> foo &gt;&gt; <span class="hljs-keyword">out</span>.txt<br><br></code></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment">### 覆盖写入：</span><br><br>`cat foo &gt; out.txt`<br><br>|<span class="hljs-string">部分</span>|<span class="hljs-string">含义</span>|<br>|<span class="hljs-string">---</span>|<span class="hljs-string">---</span>|<br>|<span class="hljs-string">`cat`</span>|<span class="hljs-string">输出文件内容</span>|<br>|<span class="hljs-string">`foo`</span>|<span class="hljs-string">被读取的文件</span>|<br>|<span class="hljs-string">`&gt;`</span>|<span class="hljs-string">输出重定向（覆盖原文件）</span>|<br>|<span class="hljs-string">`out.txt`</span>|<span class="hljs-string">写入目标文件</span>|<br><br>📌 若文件存在，会先清空内容。<br><br>---<br><br><span class="hljs-comment">### 追加写入：</span><br><br>`cat foo &gt;&gt; out.txt`<br><br>|<span class="hljs-string">部分</span>|<span class="hljs-string">含义</span>|<br>|<span class="hljs-string">---</span>|<span class="hljs-string">---</span>|<br>|<span class="hljs-string">`&gt;&gt;`</span>|<span class="hljs-string">输出重定向（追加到末尾）</span>|<br><br>📌 原内容不会被删除。<br></code></pre></td></tr></table></figure><ol><li>简要说明：<strong>宽松许可证（permissive）</strong> 与 <strong>copyleft 许可证</strong> 的区别是什么？<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">## 🟢 宽松许可证（Permissive）</span><br><br><span class="hljs-string">特点：</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">几乎无限制</span><br>    <br><span class="hljs-bullet">-</span> <span class="hljs-string">可闭源</span><br>    <br><span class="hljs-bullet">-</span> <span class="hljs-string">可商业使用</span><br>    <br><span class="hljs-bullet">-</span> <span class="hljs-string">只需保留版权声明</span><br>    <br><br><span class="hljs-string">👉</span> <span class="hljs-string">**“你爱咋用咋用”**</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment">## 🔴 Copyleft 许可证（传染式）</span><br><br><span class="hljs-string">特点：</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">修改后必须开源</span><br>    <br><span class="hljs-bullet">-</span> <span class="hljs-string">衍生作品必须使用同许可证</span><br>    <br><span class="hljs-bullet">-</span> <span class="hljs-string">强制共享改进成果</span><br>    <br><br><span class="hljs-string">👉</span> <span class="hljs-string">**“你用我，就必须开放”**</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment">## 📌 核心区别一句话：</span><br><br><span class="hljs-string">|类型|是否强制开源|</span><br><span class="hljs-string">|---|---|</span><br><span class="hljs-string">|Permissive|❌</span> <span class="hljs-string">不强制|</span><br><span class="hljs-string">|Copyleft|✅</span> <span class="hljs-string">强制|</span><br></code></pre></td></tr></table></figure></li><li>请举一个宽松许可证的例子。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">常见宽松许可证：</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">**MIT</span> <span class="hljs-string">License**</span><br>    <br><span class="hljs-bullet">-</span> <span class="hljs-string">BSD</span> <span class="hljs-string">License</span><br>    <br><span class="hljs-bullet">-</span> <span class="hljs-string">Apache</span> <span class="hljs-string">License</span> <span class="hljs-number">2.0</span><br>    <br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment">### ⭐ 最典型例子：</span><br><br><span class="hljs-string">&gt;</span> <span class="hljs-string">**MIT</span> <span class="hljs-string">License**</span><br><br><span class="hljs-string">几乎所有前端框架都在用：</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">React</span><br>    <br><span class="hljs-bullet">-</span> <span class="hljs-string">Vue</span><br>    <br><span class="hljs-bullet">-</span> <span class="hljs-string">jQuery</span><br>    <br><span class="hljs-bullet">-</span> <span class="hljs-string">Node.js</span><br></code></pre></td></tr></table></figure></li><li>请各举一个你正在使用的：</li></ol><ul><li>(a) 开源软件  </li><li>(b) 自由但闭源的软件  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">## (a) 正在使用的开源软件<br><br>例如：<br><br><span class="hljs-bullet">- </span><span class="hljs-strong">**Linux**</span><br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span><span class="hljs-strong">**Git**</span><br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span><span class="hljs-strong">**VS Code**</span><br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span><span class="hljs-strong">**Firefox**</span><br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span><span class="hljs-strong">**Vim**</span><br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span><span class="hljs-strong">**Docker**</span><br><span class="hljs-code">    </span><br><br>（源码可看、可改、可编译）<br><br><span class="hljs-bullet">---</span><br><span class="hljs-bullet"></span><br><span class="hljs-bullet"></span>## (b) 自由但闭源的软件<br><br>特点：<br><br><span class="hljs-bullet">- </span>免费使用<br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span>不提供源码<br><span class="hljs-code">    </span><br><br>例如：<br><br><span class="hljs-bullet">- </span><span class="hljs-strong">**Google Chrome**</span><br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span><span class="hljs-strong">**Discord**</span><br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span><span class="hljs-strong">**Zoom**</span><br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span><span class="hljs-strong">**Spotify**</span><br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span><span class="hljs-strong">**微信**</span><br><span class="hljs-code">    </span><br><span class="hljs-bullet">- </span><span class="hljs-strong">**QQ**</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="第三部分：获取你的虚拟机"><a href="#第三部分：获取你的虚拟机" class="headerlink" title="第三部分：获取你的虚拟机 #"></a>第三部分：获取你的虚拟机 <a href="https://decal.ocf.berkeley.edu/labs/1/#part-3-obtaining-your-vm">#</a></h2><p>使用公共的 OCF 登录服务器可以完成类似本实验的基础操作，但如果你想拥有 root 权限（几乎可以做任何事），你就需要一台属于自己的机器！</p><p>我们将为所有拥有 Berkeley CalNet 账号的 DeCal 学生提供一台虚拟机（VM）。<br>请查看你的 <code>@berkeley.edu</code> 邮箱！</p><p>如果你不是伯克利学生，则需要自行获取一台机器。当然，如果你只是出于兴趣，也可以自行搭建虚拟机。</p><p>一般来说，有两种方式获得虚拟机：</p><ul><li>使用你自己的电脑（本地）</li><li>使用别人的电脑（云端）</li></ul><hr><h3 id="本地方案"><a href="#本地方案" class="headerlink" title="本地方案 #"></a>本地方案 <a href="https://decal.ocf.berkeley.edu/labs/1/#local-setups">#</a></h3><ul><li><a href="https://www.virtualbox.org/">VirtualBox</a></li><li><a href="https://getutm.app/">UTM</a> —— 仅适用于 macOS</li></ul><hr><h3 id="云端方案"><a href="#云端方案" class="headerlink" title="云端方案 #"></a>云端方案 <a href="https://decal.ocf.berkeley.edu/labs/1/#cloud-setups">#</a></h3><p>这些通常是付费服务，但如果你拥有学生邮箱，它们通常会提供<strong>完全足够本课程使用的免费额度</strong>。</p><ul><li><a href="https://www.digitalocean.com/github-students">Digital Ocean</a></li><li><a href="https://cloud.google.com/free/">GCP</a></li><li><a href="https://azure.microsoft.com/en-us/free/students/">Azure</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LSAD</tag>
      
      <tag>lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OCF Linux System Administration DeCal note1</title>
    <link href="/2026/01/28/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20note1/"/>
    <url>/2026/01/28/%E5%AD%A6%E9%99%A2%E6%B4%BE/LSAD%20note1/</url>
    
    <content type="html"><![CDATA[<p><img src="https://blog.jaysa.net/assets/ocf-box.png" alt=""></p><p><img src="https://blog.jaysa.net/assets/linuxtm.png" alt=""></p><h2 id="Shell（命令行解释器）¶"><a href="#Shell（命令行解释器）¶" class="headerlink" title="Shell（命令行解释器）¶"></a>Shell（命令行解释器）<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#the-shell" title="Permanent link">¶</a></h2><p>Shell 是一种<strong>命令行界面（CLI）</strong>，用于与计算机进行交互。</p><p>常见的 shell 包括：</p><ul><li>bash  </li><li>zsh  </li><li>fish  </li></ul><blockquote><p>提示：如果你不知道自己正在使用 zsh 还是 bash，可以运行<br><code>echo $0</code></p></blockquote><p>基本命令结构：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-selector-attr">[command]</span> <span class="hljs-selector-attr">[flags]</span> <span class="hljs-selector-attr">[arguments]</span><br><br></code></pre></td></tr></table></figure><ul><li>示例：<code>ls -a ~/</code><ul><li><code>ls</code>：列出目录内容</li><li><code>-a</code>：不忽略以 <code>.</code> 开头的文件</li><li><code>~/</code>：你当前用户的主目录</li></ul></li></ul><p>常见的 shell 命令：</p><ul><li><code>cd</code> —— 切换目录  </li><li><code>ls</code> —— 列出目录内容  </li><li><code>cat</code> —— 拼接并输出文件内容  </li><li><code>head</code> —— 读取前 10 行  </li><li><code>less</code> —— 阅读较大的文件  </li><li><code>mv</code> —— 移动  </li><li><code>cp</code> —— 复制  </li><li><code>rm</code> —— 删除文件  </li></ul><p>还有非常多的命令……</p><p>如果你不知道某个操作对应的命令，可以直接搜索：</p><blockquote><p>“how to <em>_</em> linux”</p></blockquote><p>例如：</p><ul><li>我想解压一个文件  </li><li>搜索：“how to unzip a file linux”  </li><li>查看 Stack Overflow  </li><li>发现要使用 <code>unzip</code> 命令  </li><li>结果发现系统还没安装 unzip  </li><li>用你发行版的包管理器安装  </li><li>成功 🎉  </li></ul><p>上面提到的这些常见命令属于：</p><blockquote><p><strong>GNU Core Utilities（GNU 核心工具集）</strong></p></blockquote><hr><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><ul><li>Vim  </li><li>Nano  </li><li>Emacs  </li></ul><p><img src="https://blog.jaysa.net/assets/xkcd.png" alt=""></p><p>你将在今天的实验中学到更多内容。</p><hr><h2 id="Linux-是如何诞生的？¶"><a href="#Linux-是如何诞生的？¶" class="headerlink" title="Linux 是如何诞生的？¶"></a>Linux 是如何诞生的？<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#how-did-linux-come-to-be" title="Permanent link">¶</a></h2><p><strong>GNU/Linux</strong>：</p><ul><li>Linux 是操作系统的 <strong>内核（kernel）</strong></li><li>GNU 是其他关键软件（例如 GNU Coreutils）</li></ul><p><img src="https://blog.jaysa.net/assets/history-of-unix.svg" alt=""></p><hr><h2 id="许可证（Licenses）¶"><a href="#许可证（Licenses）¶" class="headerlink" title="许可证（Licenses）¶"></a>许可证（Licenses）<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#licenses" title="Permanent link">¶</a></h2><p>你在看别人的代码时，发现了一个奇怪的文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><br><span class="hljs-attribute">LICENSE</span><br><br></code></pre></td></tr></table></figure><p>例如：</p><p><a href="https://github.com/nims11/IPod-Shuffle-4g">github.com/nims11/IPod-Shuffle-4g</a></p><p>或者：</p><p>你在 GitHub 上新建仓库时，看到了：</p><blockquote><p>“Choose a license（选择许可证）”</p></blockquote><hr><h2 id="自由软件-vs-开源软件¶"><a href="#自由软件-vs-开源软件¶" class="headerlink" title="自由软件 vs 开源软件¶"></a>自由软件 vs 开源软件<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#free-vs-open-source" title="Permanent link">¶</a></h2><hr><h3 id="自由软件（Free-Software）¶"><a href="#自由软件（Free-Software）¶" class="headerlink" title="自由软件（Free Software）¶"></a>自由软件（Free Software）<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#free-software" title="Permanent link">¶</a></h3><p>Richard Stallman（GNU 软件开发者、自由软件基金会创始人）</p><p>——如果你在 61c 课程中使用过 gcc，<br>或者用过 <code>ls</code>、<code>cd</code> 命令，<br>那你就用过他写的软件。</p><p>他这个人有点……古怪。</p><p>这是他的网站：</p><p><a href="https://stallman.org/">stallman.org</a></p><p>自由软件允许用户：</p><ol><li>运行软件  </li><li>修改软件  </li><li>重新分发软件  </li><li>分发修改后的软件  </li></ol><p>相关演讲：</p><p><a href="https://www.youtube.com/watch?v=Ag1AKIl_2GM">Free Software, Free Society TED Talk</a></p><p>为了推广这一理念，诞生了 <strong>GPL 许可证</strong>。</p><hr><h2 id="GNU-通用公共许可证（GPL）¶"><a href="#GNU-通用公共许可证（GPL）¶" class="headerlink" title="GNU 通用公共许可证（GPL）¶"></a>GNU 通用公共许可证（GPL）<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#gnu-general-public-license-gpl" title="Permanent link">¶</a></h2><blockquote><p><strong>“病毒式许可证（Viral license）”</strong>  </p><p>Copyleft 许可证有时被称为“病毒许可证”，<br>因为任何衍生作品都必须同样是自由软件。  </p><p>这意味着该许可证会像病毒一样传播。  </p><p>这可能会让一些人不愿意在自己的项目中使用你的代码，<br>从而削弱你作品的传播效果。</p><p><strong>“你”</strong>：<br>一个狂热的 copyleft 支持者，<br>有时也被称为<br>“很难相处的人”<br>和<br>“在派对上一定超级有趣的人”。</p></blockquote><p>那如果我根本不在乎 copyleft，<br>也不在乎别人怎么用我的代码呢？</p><hr><h2 id="MIT-许可证¶"><a href="#MIT-许可证¶" class="headerlink" title="MIT 许可证¶"></a>MIT 许可证<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#mit-license" title="Permanent link">¶</a></h2><blockquote><p>MIT License</p><p>Copyright (c) [year] [fullname]</p><p>特此免费授予任何获得本软件及其相关文档文件（以下简称“软件”）副本的人无限制使用本软件的权利，包括但不限于使用、复制、修改、合并、发布、分发、再授权和/或销售软件副本的权利，并允许被授予软件的人这样做，但须满足以下条件：</p><p>上述版权声明和本许可声明应包含在软件的所有副本或重要部分中。</p><p>本软件按“原样”提供，不提供任何形式的担保，包括但不限于对适销性、特定用途适用性及非侵权性的担保。在任何情况下，作者或版权持有人均不对任何索赔、损害或其他责任负责，无论是在合同、侵权或其他行为中产生的，还是由于软件或软件的使用或其他交易引起的。</p></blockquote><p>真正的自由。</p><p>Live, laugh, kumbaya.</p><blockquote><p><strong>“绿帽许可证（Cuck license）”</strong>  </p><p>宽松许可证有时被称为“绿帽许可证”，<br>因为你冒着被大公司拿走你的成果、<br>然后闭源变成专有软件的风险。</p><p>他们会把你的水装进 AWS 的瓶子里，<br>再卖给你的朋友、家人和二次元老婆。</p><p>你被绿了。</p></blockquote><p>相关讨论：</p><p><a href="https://news.ycombinator.com/item?id=37383680">hacker news post w/ gentoo wiki article</a></p><hr><h2 id="BSD-和其他许可证呢？¶"><a href="#BSD-和其他许可证呢？¶" class="headerlink" title="BSD 和其他许可证呢？¶"></a>BSD 和其他许可证呢？<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#what-about-bsd-and-other-licenses" title="Permanent link">¶</a></h2><p>时间不够讲。</p><p>如果你感到困惑，或者想了解更多选择，请查看：</p><p><a href="https://choosealicense.com/">choosealicense.com</a></p><hr><h2 id="Jaysa，我为什么要关心这些许可证？我只是想做点酷东西。¶"><a href="#Jaysa，我为什么要关心这些许可证？我只是想做点酷东西。¶" class="headerlink" title="Jaysa，我为什么要关心这些许可证？我只是想做点酷东西。¶"></a>Jaysa，我为什么要关心这些许可证？我只是想做点酷东西。<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#jaysa-why-should-i-bother-with-all-this-license-stuff-i-just-wanna-make-cool-things" title="Permanent link">¶</a></h2><p>我认为：你在很多方面都很穷。</p><p>P.S.<br>如果这不是真的，欢迎前往：</p><p><a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/ocf.io/donate">ocf.io/donate</a></p><p>把你所有的钱都捐给我们吧，求你了 👉👈</p><hr><h2 id="1-——-你穷到根本不用担心公司抄袭你呕心沥血做的个人项目。¶"><a href="#1-——-你穷到根本不用担心公司抄袭你呕心沥血做的个人项目。¶" class="headerlink" title="1 —— 你穷到根本不用担心公司抄袭你呕心沥血做的个人项目。¶"></a>1 —— 你穷到根本不用担心公司抄袭你呕心沥血做的个人项目。<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#1-you-are-too-broke-to-have-a-company-rip-off-your-personal-projects-that-you-poured-your-blood-sweat-and-tears-into" title="Permanent link">¶</a></h2><p>案例参考：</p><p><a href="https://www.techpowerup.com/238677/minix-creator-andrew-tanenbaum-sends-open-letter-to-intel-over-minix-drama">MINIX 作者与 Intel IME 芯片事件</a></p><hr><h2 id="2-——-你现在也穷到没资格被解雇或被起诉。¶"><a href="#2-——-你现在也穷到没资格被解雇或被起诉。¶" class="headerlink" title="2 —— 你现在也穷到没资格被解雇或被起诉。¶"></a>2 —— 你现在也穷到没资格被解雇或被起诉。<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#2-you-are-too-broke-to-get-fired-or-sued-right-now" title="Permanent link">¶</a></h2><p>今年仍在持续发展的案例：</p><blockquote><p>“现代智能电视内置的软件会追踪用户的观看习惯，以便在电视屏幕上投放定向广告。</p><p>软件自由保护组织（SFC）购买了一台 Vizio 电视，希望开发一个可自定义、不会追踪用户的开源操作系统版本。</p><p>该电视运行的是 Linux，而 Linux 在法律上要求制造商必须公开允许用户修改系统的源代码。</p><p>当 SFC 要求 Vizio 提供完整对应源代码（CCS）时，Vizio 拒绝了。</p><p>SFC 随后在橙县高等法院起诉了 Vizio，以获取这份必要信息。”</p><p>—— <a href="https://sfconservancy.org/copyleft-compliance/vizio.html">Software Freedom Conservancy</a></p></blockquote><p>现在，让我们回到那个 iPod shuffle 的 Python 脚本：</p><p><a href="https://github.com/nims11/IPod-Shuffle-4g">github.com/nims11/IPod-Shuffle-4g</a></p><hr><h2 id="示例¶"><a href="#示例¶" class="headerlink" title="示例¶"></a>示例<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#examples" title="Permanent link">¶</a></h2><hr><h3 id="情况一¶"><a href="#情况一¶" class="headerlink" title="情况一¶"></a>情况一<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#situation-1" title="Permanent link">¶</a></h3><p>我在为 ncmpcpp（一个终端音乐播放器）开发的插件中使用了该脚本。</p><p>我将插件以 <strong>GPLv3</strong> 发布，而不是 GPLv2。</p><p><strong>我们是 GNU + OK！！！</strong><br><img src="https://blog.jaysa.net/assets/happy-feet.jpg" alt=""></p><blockquote><p>“本程序是自由软件；你可以根据自由软件基金会发布的 GNU 通用公共许可证重新分发和/或修改它；许可证版本为第 2 版，或（由你选择）任何更新版本。”</p><p>—— <a href="https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt">GPL 2.0</a></p></blockquote><hr><h3 id="情况一-·-第二部分¶"><a href="#情况一-·-第二部分¶" class="headerlink" title="情况一 · 第二部分¶"></a>情况一 · 第二部分<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#situation-1-part-2" title="Permanent link">¶</a></h3><p>我开始怀旧了……</p><p>我把许可证换成了 GPLv1，<br>因为老东西就是好。</p><p><strong>我们要进监狱了！！！</strong><br><img src="https://blog.jaysa.net/assets/go-to-jail.jpg" alt=""></p><p>我在插件中使用该脚本，<br>却用 GPLv3 发布了它，而不是 GPLv2。</p><hr><h3 id="情况二¶"><a href="#情况二¶" class="headerlink" title="情况二¶"></a>情况二<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#situation-2" title="Permanent link">¶</a></h3><p>我 fork 了 ipod-shuffle-4g 仓库，<br>并修改它以支持更老版本的 iPod shuffle。</p><p>我把代码发布到了 GitHub，<br>但<strong>忘记加许可证</strong>。</p><p><strong>我们又要回监狱了！！！</strong><br><img src="https://blog.jaysa.net/assets/go-to-jail.jpg" alt=""></p><p>我分发了一个修改后的版本（公开发布），<br>但它没有使用 GPL 兼容许可证。</p><p>此时 copyleft / “病毒式” 特性就生效了。</p><hr><h3 id="情况三¶"><a href="#情况三¶" class="headerlink" title="情况三¶"></a>情况三<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#situation-3" title="Permanent link">¶</a></h3><p>我用 MIT 许可证创建了一个开源软件。</p><p>但我需要钱。</p><p>而且没人赞助我，<br>因为我的代码“显然没有 Linux 内核那么重要”。</p><p>于是：</p><p>我创建了一个私有 fork，<br>包含额外功能，<br>只有赞助者才能访问。</p><p><strong>我们是赞助软件（Sponsorware）！！！</strong><br><img src="https://blog.jaysa.net/assets/happy-feet-sponsorware.jpg" alt=""></p><p>这是专有软件，<br>因为用户只拥有自由 #1（使用权）。</p><p>参考：</p><ul><li><a href="https://squidfunk.github.io/mkdocs-material/insiders/license/#fair-use-policy">mkdocs material 的许可证</a>  </li><li><a href="https://en.wikipedia.org/wiki/Open-core_model"><em>Open-core</em> 模式</a></li></ul><hr><h3 id="情况四¶"><a href="#情况四¶" class="headerlink" title="情况四¶"></a>情况四<a href="https://blog.jaysa.net/2025/09/09/intro-to-linux-and-foss/#situation-4" title="Permanent link">¶</a></h3><p>我用 <strong>AGPL</strong> 许可证写了一个很酷的数据库软件。</p><blockquote><p>“GNU Affero 通用公共许可证要求网络服务器的运营者向服务器用户提供其正在运行的修改版本的源代码。</p><p>因此，在公共服务器上使用修改后的版本，就等同于向公众开放源代码。”</p></blockquote><p>我的软件很棒，大家都很喜欢！</p><p>但大厂找到了漏洞。</p><p>有人从咨询俱乐部毕业后，<br>为 Amazon / Google Cloud / Azure 想出了一个绝妙点子：</p><blockquote><p>把我的软件托管在他们的平台上，然后收费。</p></blockquote><p>我被 <strong>SaaS（软件即服务）</strong> 背刺了。</p><p><strong>我们是 MongoDB！！！</strong><br><img src="https://blog.jaysa.net/assets/happy-feet-mongodb.jpg" alt=""></p><p>因此后来诞生了：</p><p><strong>Server Side Public License（SSPL）</strong></p><p>在 SSPL 下：</p><p>云服务商必须开源用户运行 MongoDB 所需的全部软件与 API。</p><p>详情：</p><p><a href="https://www.mongodb.com/legal/licensing/server-side-public-license">www.mongodb.com/legal/licensing/server-side-public-license</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LSAD</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dijkstra模板</title>
    <link href="/2026/01/27/Leetcode/Dijkstra%E6%A8%A1%E6%9D%BF/"/>
    <url>/2026/01/27/Leetcode/Dijkstra%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a>743. 网络延迟时间</h1><p>有 <code>n</code> 个网络节点，标记为 <code>1</code> 到 <code>n</code>。</p><p>给你一个列表 <code>times</code>，表示信号经过 <strong>有向</strong> 边的传递时间。 <code>times[i] = (ui, vi, wi)</code>，其中 <code>ui</code> 是源节点，<code>vi</code> 是目标节点， <code>wi</code> 是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 <code>K</code> 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 <code>-1</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png" alt="示例图"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2<br>输出：2<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：times = [[1,2,1]], n = 2, k = 1<br>输出：1<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：times = [[1,2,1]], n = 2, k = 2<br>输出：-1<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= n &lt;= 100</code></li><li><code>1 &lt;= times.length &lt;= 6000</code></li><li><code>times[i].length == 3</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li><code>0 &lt;= wi &lt;= 100</code></li><li>所有 <code>(ui, vi)</code> 对都 <strong>互不相同</strong>（即，不含重复边）<h2 id="Dikstra-算法介绍"><a href="#Dikstra-算法介绍" class="headerlink" title="Dikstra 算法介绍"></a>Dikstra 算法介绍</h2></li></ul><p>定义 $g[i][j]$ 表示节点 $i$ 到节点 $j$ 这条边的边权。如果没有 $i$ 到 $j$ 的边，则 $g[i][j] = \infty$。</p><p>定义 $dis[i]$ 表示起点 $k$ 到节点 $i$ 的最短路长度，一开始 $dis[k] = 0$，其余 $dis[i] = \infty$ 表示尚未计算出。</p><p>我们的目标是计算出最终的 $dis$ 数组。 </p><ul><li><p>首先更新起点 $k$ 到其邻居 $y$ 的最短路，即更新 $dis[y]$ 为 $g[k][y]$。</p></li><li><p>然后取除了起点 $k$ 以外的 $dis[i]$ 的最小值，假设最小值对应的节点是 $3$。此时可以断言：$dis[3]$ 已经是 $k$ 到 $3$ 的最短路长度，不可能有其它 $k$ 到 $3$ 的路径更短！反证法：假设存在更短的路径，那我们一定会从 $k$ 出发经过一个点 $u$，它的 $dis[u]$ 比 $dis[3]$ 还要小，然后再经过一些边到达 $3$，得到更小的 $dis[3]$。但 $dis[3]$ 已经是最小的了，并且图中<strong>没有负数边权</strong>，所以 $u$ 是不存在的，矛盾。故原命题成立，此时我们得到了 $dis[3]$ 的最终值。</p></li><li><p>用节点 $3$ 到其邻居 $y$ 的边权 $g[3][y]$ 更新 $dis[y]$：如果 $dis[3] + g[3][y] &lt; dis[y]$，那么更新 $dis[y]$ 为 $dis[3] + g[3][y]$，否则不更新。</p></li><li><p>然后取除了节点 $k, 3$ 以外的 $dis[i]$ 的最小值，重复上述过程。</p></li><li><p>由数学归纳法可知，这一做法可以得到每个点的最短路。当所有点的最短路都已确定时，算法结束。</p></li></ul><hr><h3 id="写法一：朴素-Dijkstra（适用于稠密图）"><a href="#写法一：朴素-Dijkstra（适用于稠密图）" class="headerlink" title="写法一：朴素 Dijkstra（适用于稠密图）"></a>写法一：朴素 Dijkstra（适用于稠密图）</h3><blockquote><p><strong>稠密图</strong>：边的数量级和 $n^2$ 相当的图。</p></blockquote><p>对于本题，在计算最短路时，如果发现当前找到的最小最短路等于 $\infty$，说明有节点无法到达，可以提前结束算法，返回 $-1$。</p><p>如果所有节点都可以到达，返回 $\max(dis)$。</p><p>代码实现时，节点编号改成从 $0$ 开始。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">networkDelayTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE / <span class="hljs-number">2</span>; <span class="hljs-comment">// 防止加法溢出</span><br>        <span class="hljs-type">int</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n]; <span class="hljs-comment">// 邻接矩阵</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : g) &#123;<br>            Arrays.fill(row, INF);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] t : times) &#123;<br>            g[t[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>][t[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] = t[<span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dis, INF);<br>        dis[k - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[] done = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (!done[i] &amp;&amp; (x &lt; <span class="hljs-number">0</span> || dis[i] &lt; dis[x])) &#123;<br>                    x = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> maxDis; <span class="hljs-comment">// 最后一次算出的最短路就是最大的</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (dis[x] == INF) &#123; <span class="hljs-comment">// 有节点无法到达</span><br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>            maxDis = dis[x]; <span class="hljs-comment">// 求出的最短路会越来越大</span><br>            done[x] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 最短路长度已确定（无法变得更小）</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; y &lt; n; y++) &#123;<br>                <span class="hljs-comment">// 更新 x 的邻居的最短路</span><br>                dis[y] = Math.min(dis[y], dis[x] + g[x][y]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：$O(n^2)$。</li><li><strong>空间复杂度</strong>：$O(n^2)$。</li></ul><hr><h3 id="写法二：堆优化-Dijkstra（适用于稀疏图）"><a href="#写法二：堆优化-Dijkstra（适用于稀疏图）" class="headerlink" title="写法二：堆优化 Dijkstra（适用于稀疏图）"></a>写法二：堆优化 Dijkstra（适用于稀疏图）</h3><blockquote><p><strong>稀疏图</strong>：边的数量远小于 $n^2$ 的图。</p></blockquote><p>寻找最小值的过程可以用一个最小堆来快速完成：</p><ul><li>一开始把 $(dis[k], k)$ 二元组入堆。</li><li>当节点 $x$ 首次出堆时，$dis[x]$ 就是写法一中寻找的最小最短路。</li><li>更新 $dis[y]$ 时，把 $(dis[y], y)$ 二元组入堆。</li></ul><p>注意，如果一个节点 $x$ 在出堆前，其最短路长度 $dis[x]$ 被多次更新，那么堆中会有多个重复的 $x$，并且包含 $x$ 的二元组中的 $dis[x]$ 是互不相同的（因为我们只有在找到更小的最短路时才会把二元组入堆）。</p><p>所以写法一中的 $done$ 数组可以省去，取而代之的是用出堆的最短路值（记作 $dx$）与当前的 $dis[x]$ 比较，如果 $dx &gt; dis[x]$ 说明 $x$ 之前出过堆，我们已经更新了 $x$ 的邻居的最短路，所以这次就不用更新了，继续外层循环。</p><h4 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h4><p><strong>问：为什么代码要判断 <code>dx &gt; dis[x]</code>？</strong></p><p><strong>答</strong>：对于同一个 $x$，例如先入堆一个比较大的 $dis[x] = 10$，后面又把 $dis[x]$ 更新成 $5$，之后这个 $5$ 会先出堆，然后再把 $10$ 出堆。$10$ 出堆时候是没有必要去更新周围邻居的最短路的，因为 $5$ 出堆之后，就已经把邻居的最短路更新过了，用 $10$ 是无法把邻居的最短路变得更短的，所以直接 <code>continue</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">networkDelayTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt;[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[n]; <span class="hljs-comment">// 邻接表</span><br>        Arrays.setAll(g, i -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] t : times) &#123;<br>            g[t[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;t[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, t[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> n; <span class="hljs-comment">// 未确定最短路的节点个数</span><br>        <span class="hljs-type">int</span>[] dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dis, Integer.MAX_VALUE);<br>        dis[k - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; (a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]));<br>        pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] p = pq.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> p[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> p[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (dx &gt; dis[x]) &#123; <span class="hljs-comment">// x 之前出堆过</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            maxDis = dx; <span class="hljs-comment">// 求出的最短路会越来越大</span><br>            left--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] e : g[x]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newDis</span> <span class="hljs-operator">=</span> dx + e[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (newDis &lt; dis[y]) &#123;<br>                    dis[y] = newDis; <span class="hljs-comment">// 更新 x 的邻居的最短路</span><br>                    pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;newDis, y&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left == <span class="hljs-number">0</span> ? maxDis : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：$O(m \log m)$，其中 $m$ 为 $times$ 的长度。由于 $m \ge n - 1$，分析复杂度时以 $m$ 为主。注意堆中会有重复节点，所以至多有 $O(m)$ 个元素，单次操作的复杂度是 $O(\log m)$。值得注意的是，如果输入的是稠密图，写法二的时间复杂度为 $O(n^2 \log n)$，不如写法一。</li><li><strong>空间复杂度</strong>：$O(m)$。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DS</tag>
      
      <tag>Dijkstra模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Floyd模板</title>
    <link href="/2026/01/27/Leetcode/Floyd/"/>
    <url>/2026/01/27/Leetcode/Floyd/</url>
    
    <content type="html"><![CDATA[<h2 id="一、启发思考：寻找子问题"><a href="#一、启发思考：寻找子问题" class="headerlink" title="一、启发思考：寻找子问题"></a>一、启发思考：寻找子问题</h2><p><img src="/img/Floyd/2026-01-30-16-55-03.png" alt=""></p><h2 id="二、递归怎么写：状态定义与状态转移方程"><a href="#二、递归怎么写：状态定义与状态转移方程" class="headerlink" title="二、递归怎么写：状态定义与状态转移方程"></a>二、递归怎么写：状态定义与状态转移方程</h2><p>定义 $dfs(k, i, j)$ 表示从 $i$ 到 $j$ 的最短路长度，并且这条最短路的中间节点编号都 $\le k$。注意中间节点不包含 $i$ 和 $j$。</p><p>根据上面的讨论：</p><ul><li><strong>不选 $k$</strong>，那么中间节点的编号都 $\le k - 1$，即 $dfs(k, i, j) = dfs(k - 1, i, j)$。</li><li><strong>选 $k$</strong>，问题分解成从 $i$ 到 $k$ 的最短路，以及从 $k$ 到 $j$ 的最短路。由于这两条最短路的中间节点都不包含 $k$，所以中间节点的编号都 $\le k - 1$，故得到 $dfs(k, i, j) = dfs(k - 1, i, k) + dfs(k - 1, k, j)$。</li></ul><p>这两种情况取最小值，就得到了 $dfs(k, i, j)$。写成式子就是</p><script type="math/tex; mode=display">dfs(k, i, j) = \min(dfs(k - 1, i, j), dfs(k - 1, i, k) + dfs(k - 1, k, j))</script><p><strong>递归边界：</strong> $dfs(-1, i, j) = w[i][j]$。$k = -1$ 表示 $i$ 和 $j$ 之间没有任何中间节点，此时最短路长度只能是连接 $i$ 和 $j$ 的边的边权，即 $w[i][j]$。如果没有连接 $i$ 和 $j$ 的边，则 $w[i][j] = \infty$。</p><p><strong>递归入口：</strong> $dfs(n - 1, i, j)$，表示从 $i$ 到 $j$ 的最短路长度。$k = n - 1$ 是因为本题节点编号为 $0$ 到 $n - 1$，任意最短路的中间节点编号都 $\le n - 1$。</p><h3 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h3><p><strong>问：</strong> 为什么要强调「中间节点不包含 $i$ 和 $j$」？我看代码中没有判断这个呀？</p><p><strong>答：</strong> 只要最短路是简单路径（没有重复节点），中间节点就必然不会包含 $i$ 和 $j$。强调这个事实，便于大家理解后文空间优化写法的正确性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 会超时的递归代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheCity</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> distanceThreshold)</span> &#123;<br>        <span class="hljs-type">int</span>[][] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : w) &#123;<br>            Arrays.fill(row, Integer.MAX_VALUE / <span class="hljs-number">2</span>); <span class="hljs-comment">// 防止加法溢出</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] e : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>], y = e[<span class="hljs-number">1</span>], wt = e[<span class="hljs-number">2</span>];<br>            w[x][y] = w[y][x] = wt;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minCnt</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j != i &amp;&amp; dfs(n - <span class="hljs-number">1</span>, i, j, w) &lt;= distanceThreshold) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &lt;= minCnt) &#123; <span class="hljs-comment">// 相等时取最大的 i</span><br>                minCnt = cnt;<br>                ans = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] w)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 递归边界</span><br>            <span class="hljs-keyword">return</span> w[i][j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dfs(k - <span class="hljs-number">1</span>, i, j, w), dfs(k - <span class="hljs-number">1</span>, i, k, w) + dfs(k - <span class="hljs-number">1</span>, k, j, w));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：$O(n^2 3^n)$。外面调用 $O(n^2)$ 次 $dfs$，它的搜索树是一棵满三叉树（每个非叶节点都有三个子节点），树高为 $O(n)$，所以节点个数为 $O(3^n)$，遍历搜索树需要 $O(3^n)$ 的时间。</li><li>空间复杂度：$O(n)$。递归需要 $O(n)$ 的栈空间。</li></ul><h3 id="三、递归-记录返回值-记忆化搜索"><a href="#三、递归-记录返回值-记忆化搜索" class="headerlink" title="三、递归 + 记录返回值 = 记忆化搜索"></a>三、递归 + 记录返回值 = 记忆化搜索</h3><p>上面的做法太慢了，怎么优化呢？</p><p>比如，从 2 到 1 的最短路可以分解出从 2 到 7 的最短路（中间节点 $\le 6$），从 2 到 3 的最短路也可以分解出从 2 到 7 的最短路（中间节点 $\le 6$）。也就是说，都会递归到 $dfs(6, 2, 7)$。</p><p>一叶知秋，$dfs$ 中有大量重复递归调用（递归入参相同）。由于 $dfs$ 没有副作用，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用<strong>记忆化搜索</strong>来优化：</p><ul><li>如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个 $memo$ 数组中。</li><li>如果一个状态不是第一次遇到（$memo$ 中保存的结果不等于 $memo$ 的初始值），那么可以直接返回 $memo$ 中保存的结果。</li></ul><p>注意：$memo$ 数组的初始值一定不能等于要记忆化的值。本题可以初始化成 0，因为边权都是正数。</p><blockquote><p>Python 用户可以无视上面这段，直接用 <code>@cache</code> 装饰器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheCity</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> distanceThreshold)</span> &#123;<br>        <span class="hljs-type">int</span>[][] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : w) &#123;<br>            Arrays.fill(row, Integer.MAX_VALUE / <span class="hljs-number">2</span>); <span class="hljs-comment">// 防止加法溢出</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] e : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>], y = e[<span class="hljs-number">1</span>], wt = e[<span class="hljs-number">2</span>];<br>            w[x][y] = w[y][x] = wt;<br>        &#125;<br>        <span class="hljs-type">int</span>[][][] memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n][n];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minCnt</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j != i &amp;&amp; dfs(n - <span class="hljs-number">1</span>, i, j, memo, w) &lt;= distanceThreshold) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &lt;= minCnt) &#123; <span class="hljs-comment">// 相等时取最大的 i</span><br>                minCnt = cnt;<br>                ans = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][][] memo, <span class="hljs-type">int</span>[][] w)</span> &#123;<br>        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 递归边界</span><br>            <span class="hljs-keyword">return</span> w[i][j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[k][i][j] != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 之前计算过</span><br>            <span class="hljs-keyword">return</span> memo[k][i][j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[k][i][j] = Math.min(dfs(k - <span class="hljs-number">1</span>, i, j, memo, w),<br>                dfs(k - <span class="hljs-number">1</span>, i, k, memo, w) + dfs(k - <span class="hljs-number">1</span>, k, j, memo, w));<br>    &#125;<br>&#125;   <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DS</tag>
      
      <tag>Floyd模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何判断质数</title>
    <link href="/2026/01/27/Leetcode/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%B4%A8%E6%95%B0/"/>
    <url>/2026/01/27/Leetcode/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1）只判断奇数（单个数判质数）"><a href="#1）只判断奇数（单个数判质数）" class="headerlink" title="1）只判断奇数（单个数判质数）"></a>1）只判断奇数（单个数判质数）</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><p>除了 <strong>2</strong> 以外，所有 <strong>偶数都不是质数</strong>。</p></li><li><p>判断 <code>n</code> 是否为质数时：</p><ol><li><p><code>n &lt;= 1</code> 不是质数</p></li><li><p><code>n == 2</code> 是质数</p></li><li><p><code>n</code> 是偶数（<code>n % 2 == 0</code>）不是质数</p></li><li><p>只需要用 <strong>奇数因子</strong> 去试除，并且只试到 <code>√n</code>：若 <code>n = a*b</code>，则必有一个因子 <code>&lt;= √n</code>。</p></li></ol></li></ul><p>时间复杂度：<code>O(√n / 2)</code>（比普通 <code>O(√n)</code> 少一半左右尝试）</p><h3 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrimeOddCheck</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrimeOddOnly</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 只试奇数因子</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; (<span class="hljs-type">long</span>)i * i &lt;= n; i += <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isPrimeOddOnly</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * i &lt;= n; i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="2）埃氏筛法（Sieve-of-Eratosthenes，批量求-1-n-所有质数）"><a href="#2）埃氏筛法（Sieve-of-Eratosthenes，批量求-1-n-所有质数）" class="headerlink" title="2）埃氏筛法（Sieve of Eratosthenes，批量求 1..n 所有质数）"></a>2）埃氏筛法（Sieve of Eratosthenes，批量求 1..n 所有质数）</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>目标是一次性求出 <code>[2..n]</code> 中哪些是质数。</p><ul><li><p>初始化：假设所有数都是质数</p></li><li><p>从 <code>i = 2</code> 开始：</p><ul><li>如果 <code>i</code> 仍被认为是质数，就把它的倍数都标记为合数</li></ul></li><li><p>只需要筛到 <code>i*i &lt;= n</code></p></li><li><p>倍数标记从 <code>i*i</code> 开始：因为 <code>2i,3i,...,(i-1)i</code> 在更小的质数轮次里早已被标记过</p></li></ul><p>时间复杂度：<code>O(n log log n)</code><br>空间复杂度：<code>O(n)</code></p><h3 id="Java-代码-1"><a href="#Java-代码-1" class="headerlink" title="Java 代码"></a>Java 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EratosthenesSieve</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] sieve(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">boolean</span>[] isPrime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> isPrime;<br><br>        Arrays.fill(isPrime, <span class="hljs-literal">true</span>);<br>        isPrime[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>        isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; (<span class="hljs-type">long</span>)i * i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i * i; j &lt;= n; j += i) &#123;<br>                    isPrime[j] = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isPrime;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">bool</span>* <span class="hljs-title function_">sieve</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">bool</span>* isPrime = (<span class="hljs-type">bool</span>*)<span class="hljs-built_in">calloc</span>(n + <span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">bool</span>));<br>    <span class="hljs-keyword">if</span> (!isPrime) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> isPrime;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) isPrime[i] = <span class="hljs-literal">true</span>;<br>    isPrime[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>    isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt;= n; j += i) &#123;<br>                isPrime[j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isPrime; <span class="hljs-comment">// 用完记得 free</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3）线性筛（欧拉筛，Euler-Sieve）"><a href="#3）线性筛（欧拉筛，Euler-Sieve）" class="headerlink" title="3）线性筛（欧拉筛，Euler Sieve）"></a>3）线性筛（欧拉筛，Euler Sieve）</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>埃氏筛会让一个合数被“重复标记”很多次；线性筛保证：</p><blockquote><p><strong>每个合数只会被它的最小质因子筛掉一次</strong></p></blockquote><p>做法：</p><ul><li><p>维护一个质数列表 <code>primes</code></p></li><li><p>遍历 <code>i = 2..n</code>：</p><ul><li><p>若 <code>i</code> 未被标记为合数，则 <code>i</code> 是质数，加入 <code>primes</code></p></li><li><p>对每个质数 <code>p</code>：</p><ul><li><p>标记 <code>i*p</code> 为合数</p></li><li><p>如果 <code>i % p == 0</code>，停止（保证 <code>p</code> 是 <code>i</code> 的最小质因子，从而避免重复筛）</p></li></ul></li></ul></li></ul><p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(n)</code></p><h3 id="Java-代码-2"><a href="#Java-代码-2" class="headerlink" title="Java 代码"></a>Java 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EulerSieve</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] linearSieve(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">boolean</span>[] isComposite = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br>        List&lt;Integer&gt; primes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!isComposite[i]) primes.add(i);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p : primes) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)i * p;<br>                <span class="hljs-keyword">if</span> (x &gt; n) <span class="hljs-keyword">break</span>;<br>                isComposite[(<span class="hljs-type">int</span>)x] = <span class="hljs-literal">true</span>;<br><br>                <span class="hljs-keyword">if</span> (i % p == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 关键：保证每个合数只被筛一次</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 你如果想要 isPrime 数组，可以由 isComposite 转换：</span><br>        <span class="hljs-comment">// isPrime[i] = i&gt;=2 &amp;&amp; !isComposite[i]</span><br>        <span class="hljs-keyword">return</span> isComposite;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">linearSieve</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">bool</span>* isComposite, <span class="hljs-type">int</span>* primes, <span class="hljs-type">int</span>* primeCount)</span> &#123;<br>    <span class="hljs-comment">// isComposite: size n+1，外部传入并初始化为 false</span><br>    <span class="hljs-comment">// primes: size n (够用)</span><br>    <span class="hljs-comment">// primeCount: 输出质数个数</span><br><br>    *primeCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!isComposite[i]) &#123;<br>            primes[(*primeCount)++] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; *primeCount; j++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * primes[j];<br>            <span class="hljs-keyword">if</span> (x &gt; n) <span class="hljs-keyword">break</span>;<br>            isComposite[(<span class="hljs-type">int</span>)x] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 核心</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DS</tag>
      
      <tag>质数筛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面试题-场景题-QQ号去重</title>
    <link href="/2026/01/24/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E9%9D%A2%E8%AF%95%E2%80%94QQ%E5%8F%B7%E5%8E%BB%E9%87%8D/"/>
    <url>/2026/01/24/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E9%9D%A2%E8%AF%95%E2%80%94QQ%E5%8F%B7%E5%8E%BB%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="题目还原"><a href="#题目还原" class="headerlink" title="题目还原"></a>题目还原</h2><blockquote><p><strong>40 亿个 QQ 号如何去重？只有 1GB 内存。</strong></p></blockquote><p>约束非常关键：</p><ul><li><p>QQ 号 ≈ <strong>32 位无符号整数</strong></p></li><li><p>数量级：<strong>4 × 10⁹</strong></p></li><li><p>内存：<strong>1GB = 8 × 10⁹ bits</strong></p></li><li><p>目标：<strong>判断是否重复 / 去重</strong></p></li></ul><hr><h2 id="一、第一反应为什么“常规解法”全都死掉？"><a href="#一、第一反应为什么“常规解法”全都死掉？" class="headerlink" title="一、第一反应为什么“常规解法”全都死掉？"></a>一、第一反应为什么“常规解法”全都死掉？</h2><p>我们先<strong>故意犯错</strong>，这是面试官最想看到你纠错的过程。</p><h3 id="❌-HashSet"><a href="#❌-HashSet" class="headerlink" title="❌ HashSet"></a>❌ HashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Long&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>直觉上很自然，但这是<strong>灾难</strong>：</p><ul><li><p>一个 Long 对象 ≈ 16~24 字节</p></li><li><p>HashMap Node ≈ 32 字节</p></li><li><p>40 亿 × 40B ≈ <strong>160GB+</strong></p></li></ul><p>👉 <strong>直接内存爆炸</strong></p><hr><h3 id="❌-排序"><a href="#❌-排序" class="headerlink" title="❌ 排序"></a>❌ 排序</h3><ul><li><p>外部排序可行</p></li><li><p>但 <strong>IO 成本极高</strong></p></li><li><p>不符合“经典最优解”的期待</p></li></ul><hr><h2 id="二、关键洞察：这不是“存数据”，而是“存状态”"><a href="#二、关键洞察：这不是“存数据”，而是“存状态”" class="headerlink" title="二、关键洞察：这不是“存数据”，而是“存状态”"></a>二、关键洞察：这不是“存数据”，而是“存状态”</h2><p>这是整道题的<strong>灵魂跃迁点</strong>。</p><blockquote><p>❌ 我们不需要存 QQ 号<br>✅ 我们只需要存：<strong>这个 QQ 号“出现过没有”</strong></p></blockquote><p>这就像什么？</p><hr><h2 id="三、核心直觉类比（非常重要）"><a href="#三、核心直觉类比（非常重要）" class="headerlink" title="三、核心直觉类比（非常重要）"></a>三、核心直觉类比（非常重要）</h2><h3 id="🎥-类比：电影院的座位表"><a href="#🎥-类比：电影院的座位表" class="headerlink" title="🎥 类比：电影院的座位表"></a>🎥 类比：电影院的座位表</h3><ul><li><p>一个巨大的电影院</p></li><li><p><strong>每个座位一个编号（QQ号）</strong></p></li><li><p>我不关心谁坐在那</p></li><li><p>我只关心：<strong>这个座位有没有人坐过</strong></p></li></ul><p>于是你在入口放了一张<strong>“座位占用表”</strong>：</p><ul><li><p>0 → 没人坐过</p></li><li><p>1 → 已经有人坐过</p></li></ul><p>你根本不需要存“是谁”，只需要一个<strong>布尔状态</strong></p><hr><h2 id="四、数学上是否可行？（这是面试官最喜欢追问的）"><a href="#四、数学上是否可行？（这是面试官最喜欢追问的）" class="headerlink" title="四、数学上是否可行？（这是面试官最喜欢追问的）"></a>四、数学上是否可行？（这是面试官最喜欢追问的）</h2><h3 id="4-1-需要多少-bit？"><a href="#4-1-需要多少-bit？" class="headerlink" title="4.1 需要多少 bit？"></a>4.1 需要多少 bit？</h3><ul><li><p>QQ 号是 32 位整数</p></li><li><p>最大空间：2³² ≈ 4.29 × 10⁹</p></li><li><p>每个 QQ 用 <strong>1 bit</strong></p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">需要 bit 数 = 4,294,967,296 bits<br></code></pre></td></tr></table></figure><p>换算成内存：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">= 512 MB<br></code></pre></td></tr></table></figure><p>👉 <strong>1GB 内存完全够</strong></p><hr><h2 id="五、终极答案：Bitmap（位图）"><a href="#五、终极答案：Bitmap（位图）" class="headerlink" title="五、终极答案：Bitmap（位图）"></a>五、终极答案：Bitmap（位图）</h2><h3 id="5-1-本质是什么？"><a href="#5-1-本质是什么？" class="headerlink" title="5.1 本质是什么？"></a>5.1 本质是什么？</h3><p>Bitmap = <strong>用 bit 的下标直接映射值本身</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">bit[i] == 1  → i 这个 QQ 号出现过<br>bit[i] == 0  → 没出现过<br></code></pre></td></tr></table></figure><p><strong>这不是哈希，这是“直接寻址”</strong></p><hr><h2 id="六、数据结构直觉再深化"><a href="#六、数据结构直觉再深化" class="headerlink" title="六、数据结构直觉再深化"></a>六、数据结构直觉再深化</h2><h3 id="🎛-类比：超大号电闸墙"><a href="#🎛-类比：超大号电闸墙" class="headerlink" title="🎛 类比：超大号电闸墙"></a>🎛 类比：超大号电闸墙</h3><ul><li><p>一面墙有 40 亿个小电闸</p></li><li><p>每个闸只有 <strong>开 / 关</strong></p></li><li><p>QQ 号 = 电闸编号</p></li><li><p>来一个 QQ 号 → 把对应闸推上去</p></li></ul><p><strong>再来一次，如果已经是“开”的 → 重复</strong></p><hr><h2 id="七、Java-实现（工程级）"><a href="#七、Java-实现（工程级）" class="headerlink" title="七、Java 实现（工程级）"></a>七、Java 实现（工程级）</h2><h3 id="7-1-用-BitSet"><a href="#7-1-用-BitSet" class="headerlink" title="7.1 用 BitSet"></a>7.1 用 <code>BitSet</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BitSet</span> <span class="hljs-variable">bitSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitSet</span>(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">32</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> qq : inputStream) &#123;<br>    <span class="hljs-keyword">if</span> (bitSet.get((<span class="hljs-type">int</span>) qq)) &#123;<br>        <span class="hljs-comment">// 重复</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        bitSet.set((<span class="hljs-type">int</span>) qq);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="⚠-注意点（这是区分高手的地方）"><a href="#⚠-注意点（这是区分高手的地方）" class="headerlink" title="⚠ 注意点（这是区分高手的地方）"></a>⚠ 注意点（这是区分高手的地方）</h3><ol><li><p><code>BitSet</code> 用的是 <code>long[]</code>，是<strong>紧凑的</strong></p></li><li><p>不能用 boolean[]（1 byte，不是 1 bit）</p></li><li><p>JVM 堆要调大（<code>-Xmx1g</code>）</p></li><li><p>QQ 号如果是无符号 → 需要 long + 映射</p></li></ol><hr><h2 id="八、如果-QQ-号不是连续的怎么办？"><a href="#八、如果-QQ-号不是连续的怎么办？" class="headerlink" title="八、如果 QQ 号不是连续的怎么办？"></a>八、如果 QQ 号不是连续的怎么办？</h2><p>如果面试官升级问题：</p><blockquote><p>QQ 号是 <strong>64 位 long</strong>，仍然 40 亿条</p></blockquote><h3 id="👉-Bitmap-失效（需要-2⁶⁴-bits）"><a href="#👉-Bitmap-失效（需要-2⁶⁴-bits）" class="headerlink" title="👉 Bitmap 失效（需要 2⁶⁴ bits）"></a>👉 Bitmap 失效（需要 2⁶⁴ bits）</h3><p>此时你必须说出：</p><h3 id="🌟-Bloom-Filter（布隆过滤器）"><a href="#🌟-Bloom-Filter（布隆过滤器）" class="headerlink" title="🌟 Bloom Filter（布隆过滤器）"></a>🌟 Bloom Filter（布隆过滤器）</h3><ul><li><p>空间换概率</p></li><li><p>有 <strong>误判（false positive）</strong></p></li><li><p>没有 <strong>漏判（false negative）</strong></p></li></ul><p>但——<br><strong>原题是“QQ号” → 连续整数 → Bitmap 是最优解</strong></p><hr><h2 id="九、终极总结（面试官听到这里会点头）"><a href="#九、终极总结（面试官听到这里会点头）" class="headerlink" title="九、终极总结（面试官听到这里会点头）"></a>九、终极总结（面试官听到这里会点头）</h2><blockquote><p>这道题的本质不是“去重”，<br>而是 <strong>“用最小信息量表示状态”</strong></p></blockquote><div class="table-container"><table><thead><tr><th>解法</th><th>内存</th><th>正确性</th></tr></thead><tbody><tr><td>HashSet</td><td>❌ 爆炸</td><td>✅</td></tr><tr><td>排序</td><td>❌ IO大</td><td>✅</td></tr><tr><td>Bitmap</td><td>✅ 512MB</td><td>✅</td></tr><tr><td>Bloom Filter</td><td>✅ 更小</td><td>❌ 概率</td></tr></tbody></table></div><hr><h1 id="一、Bitmap-的本质（先把“模型”装进脑子）"><a href="#一、Bitmap-的本质（先把“模型”装进脑子）" class="headerlink" title="一、Bitmap 的本质（先把“模型”装进脑子）"></a>一、Bitmap 的本质（先把“模型”装进脑子）</h1><h2 id="1️⃣-Bitmap-是什么？"><a href="#1️⃣-Bitmap-是什么？" class="headerlink" title="1️⃣ Bitmap 是什么？"></a>1️⃣ Bitmap 是什么？</h2><blockquote><p>Bitmap = <strong>用 bit 的下标，直接表示“值是否存在”</strong></p></blockquote><p>不是存数据，而是存 <strong>状态</strong>。</p><hr><h2 id="2️⃣-内存映射关系（这是灵魂）"><a href="#2️⃣-内存映射关系（这是灵魂）" class="headerlink" title="2️⃣ 内存映射关系（这是灵魂）"></a>2️⃣ 内存映射关系（这是灵魂）</h2><p>假设：</p><ul><li><p>一个 <code>long</code> = <strong>64 bit</strong></p></li><li><p>我们用 <code>long[]</code> 来存 bitmap</p></li></ul><h3 id="映射公式（一定要背）"><a href="#映射公式（一定要背）" class="headerlink" title="映射公式（一定要背）"></a>映射公式（一定要背）</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">index = value / 64        // 在第几个 long<br>offset = value % 64       // 在 long 的第几位<br></code></pre></td></tr></table></figure><h3 id="设置某个值存在："><a href="#设置某个值存在：" class="headerlink" title="设置某个值存在："></a>设置某个值存在：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bitmap[index] |= (1L &lt;&lt; offset)<br></code></pre></td></tr></table></figure><h3 id="判断是否存在："><a href="#判断是否存在：" class="headerlink" title="判断是否存在："></a>判断是否存在：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">(bitmap[index] &amp; (1L &lt;&lt; offset)) != 0<br></code></pre></td></tr></table></figure><p>👉 <strong>所有 Bitmap 的实现，本质都是这三行</strong></p><hr><h2 id="二、手写一个-Java-Bitmap（⭐-面试官最爱）"><a href="#二、手写一个-Java-Bitmap（⭐-面试官最爱）" class="headerlink" title="二、手写一个 Java Bitmap（⭐ 面试官最爱）"></a>二、手写一个 Java Bitmap（⭐ 面试官最爱）</h2><h3 id="1️⃣-设计目标"><a href="#1️⃣-设计目标" class="headerlink" title="1️⃣ 设计目标"></a>1️⃣ 设计目标</h3><ul><li><p>支持：<code>add</code> / <code>contains</code></p></li><li><p>空间：<strong>1 bit / 数</strong></p></li><li><p>不用任何集合类</p></li><li><p>可控、可解释</p></li></ul><hr><h3 id="2️⃣-代码实现（标准答案级）"><a href="#2️⃣-代码实现（标准答案级）" class="headerlink" title="2️⃣ 代码实现（标准答案级）"></a>2️⃣ 代码实现（标准答案级）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBitmap</span> &#123;<br><br>    <span class="hljs-comment">// 用 long 数组存 bit</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] bits;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> maxValue 最大可能的值（例如 10 位 QQ 可传 10_000_000_000L）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBitmap</span><span class="hljs-params">(<span class="hljs-type">long</span> maxValue)</span> &#123;<br>        <span class="hljs-comment">// 需要多少个 long</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ((maxValue + <span class="hljs-number">64</span>) &gt;&gt;&gt; <span class="hljs-number">6</span>);<br>        bits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[size];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 标记某个值存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> value)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (value &gt;&gt;&gt; <span class="hljs-number">6</span>);   <span class="hljs-comment">// value / 64</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (value &amp; <span class="hljs-number">63</span>);   <span class="hljs-comment">// value % 64</span><br>        bits[index] |= (<span class="hljs-number">1L</span> &lt;&lt; offset);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断某个值是否存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(<span class="hljs-type">long</span> value)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (value &gt;&gt;&gt; <span class="hljs-number">6</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (value &amp; <span class="hljs-number">63</span>);<br>        <span class="hljs-keyword">return</span> (bits[index] &amp; (<span class="hljs-number">1L</span> &lt;&lt; offset)) != <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3️⃣-为什么这里全是位运算？（必须能讲）"><a href="#3️⃣-为什么这里全是位运算？（必须能讲）" class="headerlink" title="3️⃣ 为什么这里全是位运算？（必须能讲）"></a>3️⃣ 为什么这里全是位运算？（必须能讲）</h2><h3 id="❓-为什么不用-64-和-64？"><a href="#❓-为什么不用-64-和-64？" class="headerlink" title="❓ 为什么不用 / 64 和 % 64？"></a>❓ 为什么不用 <code>/ 64</code> 和 <code>% 64</code>？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">value &gt;&gt;&gt; <span class="hljs-number">6</span>    <span class="hljs-comment">// 等价于 value / 64</span><br>value &amp; <span class="hljs-number">63</span>     <span class="hljs-comment">// 等价于 value % 64</span><br></code></pre></td></tr></table></figure><p>👉 位运算 <strong>更快、无符号安全、CPU 友好</strong></p><p>这是<strong>工程意识</strong>。</p><hr><h2 id="三、直觉类比（把它刻进脑子）"><a href="#三、直觉类比（把它刻进脑子）" class="headerlink" title="三、直觉类比（把它刻进脑子）"></a>三、直觉类比（把它刻进脑子）</h2><h3 id="🎛-类比：64-格保险柜"><a href="#🎛-类比：64-格保险柜" class="headerlink" title="🎛 类比：64 格保险柜"></a>🎛 类比：64 格保险柜</h3><ul><li><p>每个 <code>long</code> 是一个 <strong>64 格的保险柜</strong></p></li><li><p><code>index</code> 决定你用哪一个保险柜</p></li><li><p><code>offset</code> 决定你打开哪一格</p></li><li><p><code>1L &lt;&lt; offset</code> 是你手里的“钥匙”</p></li></ul><p>你不是存东西<br>你只是 <strong>把某一格“拨到 ON”</strong></p><hr><h2 id="四、Java-自带-BitSet-是怎么干的？"><a href="#四、Java-自带-BitSet-是怎么干的？" class="headerlink" title="四、Java 自带 BitSet 是怎么干的？"></a>四、Java 自带 BitSet 是怎么干的？</h2><h3 id="1️⃣-使用方式（面试可直接说）"><a href="#1️⃣-使用方式（面试可直接说）" class="headerlink" title="1️⃣ 使用方式（面试可直接说）"></a>1️⃣ 使用方式（面试可直接说）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BitSet</span> <span class="hljs-variable">bitSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitSet</span>();<br><br>bitSet.set(qq);<br><span class="hljs-keyword">if</span> (bitSet.get(qq)) &#123;<br>    <span class="hljs-comment">// 重复</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2️⃣-BitSet-底层是什么？（关键）"><a href="#2️⃣-BitSet-底层是什么？（关键）" class="headerlink" title="2️⃣ BitSet 底层是什么？（关键）"></a>2️⃣ BitSet 底层是什么？（关键）</h3><p>👉 <strong>本质就是：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span>[] words;<br></code></pre></td></tr></table></figure><p>和你刚才写的一模一样，只是：</p><ul><li><p>自动扩容</p></li><li><p>边界检查</p></li><li><p>位运算封装好了</p></li></ul><hr><h3 id="3️⃣-BitSet-set-的源码思想（伪代码）"><a href="#3️⃣-BitSet-set-的源码思想（伪代码）" class="headerlink" title="3️⃣ BitSet set 的源码思想（伪代码）"></a>3️⃣ BitSet set 的源码思想（伪代码）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">wordIndex</span> <span class="hljs-operator">=</span> bitIndex &gt;&gt; <span class="hljs-number">6</span>;<br>words[wordIndex] |= (<span class="hljs-number">1L</span> &lt;&lt; bitIndex);<br></code></pre></td></tr></table></figure><p><strong>和你写的 MyBitmap，没有任何本质区别。</strong></p><hr><h2 id="五、工程级注意事项（高手区）"><a href="#五、工程级注意事项（高手区）" class="headerlink" title="五、工程级注意事项（高手区）"></a>五、工程级注意事项（高手区）</h2><h3 id="⚠-1️⃣-boolean-不能当-Bitmap"><a href="#⚠-1️⃣-boolean-不能当-Bitmap" class="headerlink" title="⚠ 1️⃣ boolean[] 不能当 Bitmap"></a>⚠ 1️⃣ boolean[] 不能当 Bitmap</h3><ul><li><p>boolean = <strong>1 byte = 8 bit</strong></p></li><li><p>Bitmap = <strong>1 bit</strong></p></li><li><p>直接浪费 8 倍空间</p></li></ul><hr><h3 id="⚠-2️⃣-JVM-堆设置"><a href="#⚠-2️⃣-JVM-堆设置" class="headerlink" title="⚠ 2️⃣ JVM 堆设置"></a>⚠ 2️⃣ JVM 堆设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xmx1g -Xms1g<br></code></pre></td></tr></table></figure><p>否则 Bitmap 还没用，JVM 先 OOM。</p><hr><h3 id="⚠-3️⃣-Bitmap-适合什么？不适合什么？"><a href="#⚠-3️⃣-Bitmap-适合什么？不适合什么？" class="headerlink" title="⚠ 3️⃣ Bitmap 适合什么？不适合什么？"></a>⚠ 3️⃣ Bitmap 适合什么？不适合什么？</h3><div class="table-container"><table><thead><tr><th>场景</th><th>是否适合</th></tr></thead><tbody><tr><td>连续整数</td><td>✅</td></tr><tr><td>稀疏 long</td><td>❌</td></tr><tr><td>判断是否存在</td><td>✅</td></tr><tr><td>存真实数据</td><td>❌</td></tr><tr><td>删除</td><td>⚠（只能清 bit）</td></tr></tbody></table></div><hr><h2 id="六、10-位-QQ-的正确工程姿势（回扣你的题）"><a href="#六、10-位-QQ-的正确工程姿势（回扣你的题）" class="headerlink" title="六、10 位 QQ 的正确工程姿势（回扣你的题）"></a>六、10 位 QQ 的正确工程姿势（回扣你的题）</h2><p><strong>不能一个 Bitmap 全覆盖</strong></p><p>正确做法是：</p><blockquote><p><strong>分桶 + Bitmap</strong></p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">前 2 位 → 一个桶<br>每个桶一个 Bitmap<br>一次只加载一个桶<br></code></pre></td></tr></table></figure><hr><h3 id="1-关于-maxValue-64-gt-gt-gt-6"><a href="#1-关于-maxValue-64-gt-gt-gt-6" class="headerlink" title="1. 关于 (maxValue + 64) &gt;&gt;&gt; 6"></a>1. 关于 <code>(maxValue + 64) &gt;&gt;&gt; 6</code></h3><p>这行代码的作用是<strong>计算存储 <code>maxValue</code> 个位需要多少个 <code>long</code> 元素</strong>。</p><ul><li><strong><code>&gt;&gt;&gt; 6</code></strong>：相当于除以 64（因为一个 <code>long</code> 有 64 位）。</li><li><strong><code>+ 64</code></strong>：一种保守的<strong>向上取整</strong>策略，确保空间足够，防止索引越界。</li></ul><hr><h3 id="2-关于-gt-gt-gt-（三位移码）"><a href="#2-关于-gt-gt-gt-（三位移码）" class="headerlink" title="2. 关于 &gt;&gt;&gt;（三位移码）"></a>2. 关于 <code>&gt;&gt;&gt;</code>（三位移码）</h3><p>这是 <strong>“无符号右移”</strong>，与普通的 <code>&gt;&gt;</code> 有本质区别：</p><ul><li><strong><code>&gt;&gt;</code> (带符号右移)</strong>：左边补<strong>符号位</strong>。如果是负数，高位补 1，保持负号。</li><li><strong><code>&gt;&gt;&gt;</code> (无符号右移)</strong>：左边一律补 <strong>0</strong>。不关心正负，只把数据看作纯粹的二进制位。</li></ul><p><strong>总结：</strong> 在 Bitmap 这种处理“位”而非“数值”的场景下，使用 <code>&gt;&gt;&gt;</code> 可以避免负数干扰，确保计算出的数组下标或长度永远是正数。</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>位图</tag>
      
      <tag>场景题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50 AI project0 Minesweeper</title>
    <link href="/2026/01/24/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50AI-Project1-%20Minesweeper/"/>
    <url>/2026/01/24/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50AI-Project1-%20Minesweeper/</url>
    
    <content type="html"><![CDATA[<h1 id="Minesweeper"><a href="#Minesweeper" class="headerlink" title="Minesweeper"></a>Minesweeper</h1><p>编写一个 <strong>可以自动玩扫雷（Minesweeper）的人工智能程序</strong>。</p><hr><h2 id="🕒-完成时间（When-to-Do-It）"><a href="#🕒-完成时间（When-to-Do-It）" class="headerlink" title="🕒 完成时间（When to Do It）"></a>🕒 完成时间（When to Do It）</h2><p><strong>截止时间：</strong></p><p>📅 <strong>2026 年 7 月 1 日（星期三）上午 7:59（GMT+8）</strong></p><hr><h2 id="🆘-如何获取帮助（How-to-Get-Help）"><a href="#🆘-如何获取帮助（How-to-Get-Help）" class="headerlink" title="🆘 如何获取帮助（How to Get Help）"></a>🆘 如何获取帮助（How to Get Help）</h2><ol><li>通过 <strong>Ed Discussion</strong> 提问  </li><li>通过任意一个 <strong>CS50 官方社区</strong></li></ol><hr><h2 id="📘-背景（Background）"><a href="#📘-背景（Background）" class="headerlink" title="📘 背景（Background）"></a>📘 背景（Background）</h2><h3 id="Minesweeper（扫雷）"><a href="#Minesweeper（扫雷）" class="headerlink" title="Minesweeper（扫雷）"></a>Minesweeper（扫雷）</h3><p>扫雷是一种经典的逻辑益智游戏，由一个由格子组成的网格构成，其中：</p><ul><li>某些格子中隐藏着 <strong>地雷（mines）</strong></li><li>点击含有地雷的格子会：<ul><li>引爆地雷</li><li>游戏失败</li></ul></li><li>点击一个 <strong>安全格子</strong>（没有地雷）会显示一个数字</li></ul><p>这个数字表示：</p><blockquote><p><strong>该格子周围 8 个相邻格子中，有多少个地雷</strong></p></blockquote><p>邻居格子的定义包括：</p><ul><li>上、下、左、右</li><li>四个对角方向</li></ul><hr><h3 id="游戏界面示例"><a href="#游戏界面示例" class="headerlink" title="游戏界面示例"></a>游戏界面示例</h3><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/game.png" alt="Minesweeper Game"></p><hr><h3 id="数字含义示例"><a href="#数字含义示例" class="headerlink" title="数字含义示例"></a>数字含义示例</h3><p>在下面这个 3×3 的棋盘中：</p><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/safe_cells.png" alt="Sample safe cell numbers"></p><ul><li>数字 <code>1</code> 表示周围 <strong>有 1 个地雷</strong></li><li>数字 <code>0</code> 表示周围 <strong>没有任何地雷</strong></li></ul><p>通过这些信息，具有逻辑推理能力的玩家可以判断：</p><ul><li>右下角格子 <strong>一定是地雷</strong></li><li>左上角格子 <strong>一定是安全的</strong></li></ul><p>否则，其余数字将无法成立。</p><hr><h3 id="🎯-游戏目标"><a href="#🎯-游戏目标" class="headerlink" title="🎯 游戏目标"></a>🎯 游戏目标</h3><blockquote><p><strong>找出并标记棋盘上的所有地雷。</strong></p></blockquote><p>在本项目中：</p><ul><li>玩家（或 AI）可以通过右键点击格子来标记地雷。</li></ul><hr><h2 id="🧠-命题逻辑（Propositional-Logic）"><a href="#🧠-命题逻辑（Propositional-Logic）" class="headerlink" title="🧠 命题逻辑（Propositional Logic）"></a>🧠 命题逻辑（Propositional Logic）</h2><p>在本项目中，你的目标是：</p><blockquote><p><strong>构建一个可以通过逻辑推理来玩扫雷的 AI。</strong></p></blockquote><p>回顾课堂内容：</p><ul><li>知识型智能体（Knowledge-Based Agent）</li><li>通过维护一个 <strong>知识库（Knowledge Base）</strong></li><li>利用逻辑推理做出决策</li></ul><hr><h3 id="如何表示扫雷中的知识？"><a href="#如何表示扫雷中的知识？" class="headerlink" title="如何表示扫雷中的知识？"></a>如何表示扫雷中的知识？</h3><p>我们可以将：</p><blockquote><p><strong>棋盘上的每一个格子视为一个命题变量</strong></p></blockquote><ul><li>若该格子是地雷 → 命题为 <code>True</code></li><li>若不是地雷 → 命题为 <code>False</code></li></ul><hr><h3 id="AI-可以获得哪些信息？"><a href="#AI-可以获得哪些信息？" class="headerlink" title="AI 可以获得哪些信息？"></a>AI 可以获得哪些信息？</h3><p>当 AI 点击一个安全格子时，会看到一个数字。</p><p>例如：</p><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/middle_safe.png" alt="Middle cell with labeled neighbors"></p><p>假设中间格子显示为 <code>1</code>。</p><p>这意味着：</p><blockquote><p>在 A～H 八个相邻格子中，<strong>恰好有 1 个是地雷</strong>。</p></blockquote><hr><h3 id="最弱的逻辑表达"><a href="#最弱的逻辑表达" class="headerlink" title="最弱的逻辑表达"></a>最弱的逻辑表达</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Or(A, B, C, D, E, F, G, H)<br></code></pre></td></tr></table></figure><p>表示：</p><blockquote><p>至少有一个格子是地雷。</p></blockquote><p>但这还不够精确。</p><hr><h3 id="正确含义：恰好一个"><a href="#正确含义：恰好一个" class="headerlink" title="正确含义：恰好一个"></a>正确含义：<strong>恰好一个</strong></h3><p>逻辑上真正的含义应为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">Or(<br>    And(A, Not(B), Not(C), Not(D), Not(E), Not(F), Not(G), Not(H)),<br>    And(Not(A), B, Not(C), Not(D), Not(E), Not(F), Not(G), Not(H)),<br>    And(Not(A), Not(B), C, Not(D), Not(E), Not(F), Not(G), Not(H)),<br>    And(Not(A), Not(B), Not(C), D, Not(E), Not(F), Not(G), Not(H)),<br>    And(Not(A), Not(B), Not(C), Not(D), E, Not(F), Not(G), Not(H)),<br>    And(Not(A), Not(B), Not(C), Not(D), Not(E), F, Not(G), Not(H)),<br>    And(Not(A), Not(B), Not(C), Not(D), Not(E), Not(F), G, Not(H)),<br>    And(Not(A), Not(B), Not(C), Not(D), Not(E), Not(F), Not(G), H)<br>)<br></code></pre></td></tr></table></figure><p>仅仅表达数字 <code>1</code> 就如此复杂。</p><p>如果是 <code>2</code>、<code>3</code>，复杂度会急剧上升。</p><hr><h3 id="🚫-模型检测不可行"><a href="#🚫-模型检测不可行" class="headerlink" title="🚫 模型检测不可行"></a>🚫 模型检测不可行</h3><p>在一个 8×8 的棋盘中：</p><ul><li>有 64 个格子</li><li>可能模型数量为：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>^<span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p>这在现实中是完全不可计算的。</p><hr><h2 id="✅-更高效的知识表示方法"><a href="#✅-更高效的知识表示方法" class="headerlink" title="✅ 更高效的知识表示方法"></a>✅ 更高效的知识表示方法</h2><p>我们使用如下形式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;A, B, C, D, E, F, G, H&#125; = 1<br></code></pre></td></tr></table></figure><p>含义：</p><blockquote><p>在这些格子中，<strong>恰好有 1 个地雷</strong>。</p></blockquote><hr><h3 id="每条知识句子包含："><a href="#每条知识句子包含：" class="headerlink" title="每条知识句子包含："></a>每条知识句子包含：</h3><ul><li><code>cells</code>：涉及的格子集合</li><li><code>count</code>：其中地雷的数量</li></ul><hr><h3 id="🔍-推理规则一：count-0"><a href="#🔍-推理规则一：count-0" class="headerlink" title="🔍 推理规则一：count = 0"></a>🔍 推理规则一：count = 0</h3><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/infer_safe.png" alt="infer safe"></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">D</span><span class="hljs-operator">,</span> <span class="hljs-built_in">E</span><span class="hljs-operator">,</span> <span class="hljs-variable">G</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>所有格子都是安全的。</p></blockquote><hr><h3 id="🔥-推理规则二：cells-数量-count"><a href="#🔥-推理规则二：cells-数量-count" class="headerlink" title="🔥 推理规则二：cells 数量 = count"></a>🔥 推理规则二：cells 数量 = count</h3><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/infer_mines.png" alt="infer mines"></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;E, F, H&#125;</span><span class="language-xml"> = 3</span><br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>E、F、H 全部是地雷。</p></blockquote><hr><h3 id="🔄-更新已有知识"><a href="#🔄-更新已有知识" class="headerlink" title="🔄 更新已有知识"></a>🔄 更新已有知识</h3><p>若已知：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-keyword">A</span>, B, C&#125; = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li>若 C 是安全的：</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-keyword">A</span>, B&#125; = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li>若 C 是地雷：</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-keyword">A</span>, B&#125; = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><hr><h3 id="⭐-子集推理（最关键）"><a href="#⭐-子集推理（最关键）" class="headerlink" title="⭐ 子集推理（最关键）"></a>⭐ 子集推理（最关键）</h3><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/subset_inference.png" alt="subset inference"></p><p>若：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">A</span><span class="hljs-operator">,</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">A</span><span class="hljs-operator">,</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-operator">,</span> <span class="hljs-built_in">D</span><span class="hljs-operator">,</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>则可推出：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">D</span><span class="hljs-operator">,</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><hr><h3 id="通用推理规则"><a href="#通用推理规则" class="headerlink" title="通用推理规则"></a>通用推理规则</h3><p>如果：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">set</span>1 ⊆ <span class="hljs-keyword">set</span>2<br></code></pre></td></tr></table></figure><p>那么：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">set</span>2 - <span class="hljs-keyword">set</span>1 = count2 - count1<br></code></pre></td></tr></table></figure><hr><h2 id="🚀-Getting-Started"><a href="#🚀-Getting-Started" class="headerlink" title="🚀 Getting Started"></a>🚀 Getting Started</h2><ol><li>下载项目代码：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>cdn.cs50.net<span class="hljs-regexp">/ai/</span><span class="hljs-number">2023</span><span class="hljs-regexp">/x/</span>projects<span class="hljs-regexp">/1/mi</span>nesweeper.zip<br></code></pre></td></tr></table></figure><ol><li>安装依赖：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install -r requirements.txt<br></code></pre></td></tr></table></figure><p>（主要依赖：<code>pygame</code>）</p><hr><h2 id="📂-项目结构（Understanding）"><a href="#📂-项目结构（Understanding）" class="headerlink" title="📂 项目结构（Understanding）"></a>📂 项目结构（Understanding）</h2><h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><ul><li><p><code>runner.py</code></p><ul><li>游戏界面（已完成）</li></ul></li><li><p><code>minesweeper.py</code></p><ul><li>游戏逻辑</li><li>AI 推理系统（你需要完成）</li></ul></li></ul><hr><h3 id="minesweeper-py-中的三个类"><a href="#minesweeper-py-中的三个类" class="headerlink" title="minesweeper.py 中的三个类"></a>minesweeper.py 中的三个类</h3><h4 id="1️⃣-Minesweeper"><a href="#1️⃣-Minesweeper" class="headerlink" title="1️⃣ Minesweeper"></a>1️⃣ Minesweeper</h4><p>负责棋盘逻辑（已完成）</p><hr><h4 id="2️⃣-Sentence"><a href="#2️⃣-Sentence" class="headerlink" title="2️⃣ Sentence"></a>2️⃣ Sentence</h4><p>表示逻辑语句：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">cells</span> <span class="hljs-operator">=</span> 一组未知格子<br><span class="hljs-attribute">count</span> <span class="hljs-operator">=</span> 地雷数量<br></code></pre></td></tr></table></figure><p>包含方法：</p><ul><li><code>known_mines</code></li><li><code>known_safes</code></li><li><code>mark_mine</code></li><li><code>mark_safe</code></li></ul><hr><h4 id="3️⃣-MinesweeperAI"><a href="#3️⃣-MinesweeperAI" class="headerlink" title="3️⃣ MinesweeperAI"></a>3️⃣ MinesweeperAI</h4><p>维护：</p><ul><li><code>moves_made</code></li><li><code>mines</code></li><li><code>safes</code></li><li><code>knowledge</code></li></ul><p>并根据逻辑推理选择下一步。</p><hr><h2 id="📝-作业要求（Specification）"><a href="#📝-作业要求（Specification）" class="headerlink" title="📝 作业要求（Specification）"></a>📝 作业要求（Specification）</h2><p>你需要完成以下函数：</p><h3 id="Sentence-类"><a href="#Sentence-类" class="headerlink" title="Sentence 类"></a>Sentence 类</h3><ul><li><code>known_mines</code></li><li><code>known_safes</code></li><li><code>mark_mine</code></li><li><code>mark_safe</code></li></ul><hr><h3 id="MinesweeperAI-类"><a href="#MinesweeperAI-类" class="headerlink" title="MinesweeperAI 类"></a>MinesweeperAI 类</h3><ul><li><code>add_knowledge</code></li><li><code>make_safe_move</code></li><li><code>make_random_move</code></li></ul><hr><h3 id="add-knowledge-必须实现："><a href="#add-knowledge-必须实现：" class="headerlink" title="add_knowledge 必须实现："></a>add_knowledge 必须实现：</h3><ol><li>标记该格子已被点击  </li><li>标记为安全格子  </li><li>添加新的逻辑句子  </li><li>推导新的安全格子  </li><li>推导新的地雷  </li><li>使用子集规则生成新句子  </li><li>不断重复推理直到无新知识  </li></ol><hr><h3 id="make-safe-move"><a href="#make-safe-move" class="headerlink" title="make_safe_move"></a>make_safe_move</h3><ul><li>返回一个：<ul><li>已知安全</li><li>且尚未点击的格子</li></ul></li><li>若不存在，返回 <code>None</code></li></ul><hr><h3 id="make-random-move"><a href="#make-random-move" class="headerlink" title="make_random_move"></a>make_random_move</h3><ul><li>随机选择：<ul><li>未点击</li><li>未被标记为地雷的格子</li></ul></li><li>若不存在，返回 <code>None</code></li></ul><hr><h2 id="💡-提示（Hints）"><a href="#💡-提示（Hints）" class="headerlink" title="💡 提示（Hints）"></a>💡 提示（Hints）</h2><ul><li>仔细阅读 Background（非常重要）</li><li>熟练使用 Python 的 <code>set</code></li><li>不要在遍历集合时修改集合</li><li>AI 并不保证每局都能赢（有时必须猜）</li></ul><hr><h2 id="🧪-测试（Testing）"><a href="#🧪-测试（Testing）" class="headerlink" title="🧪 测试（Testing）"></a>🧪 测试（Testing）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">check50 ai50/projects/2024/x/minesweeper<br></code></pre></td></tr></table></figure><p>风格检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">style50<br></code></pre></td></tr></table></figure><hr><h2 id="📤-提交（How-to-Submit）"><a href="#📤-提交（How-to-Submit）" class="headerlink" title="📤 提交（How to Submit）"></a>📤 提交（How to Submit）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">submit50 ai50/projects/2024/x/minesweeper<br></code></pre></td></tr></table></figure><p>或推送至：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/me50/</span>USERNAME.git<br></code></pre></td></tr></table></figure><p>分支名：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ai50<span class="hljs-regexp">/projects/</span><span class="hljs-number">2024</span><span class="hljs-regexp">/x/mi</span>nesweeper<br></code></pre></td></tr></table></figure><hr><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h1 id="一、实现思路"><a href="#一、实现思路" class="headerlink" title="一、实现思路"></a>一、实现思路</h1><p>本项目实现的是一个<strong>基于知识推理的扫雷人工智能（Knowledge-Based Agent）</strong>。</p><p>核心思想只有一句话：</p><blockquote><p><strong>把扫雷数字信息转化为逻辑约束，再通过集合推理不断推出新的安全格和地雷格。</strong></p></blockquote><hr><h2 id="1-扫雷信息如何转化为知识"><a href="#1-扫雷信息如何转化为知识" class="headerlink" title="1. 扫雷信息如何转化为知识"></a>1. 扫雷信息如何转化为知识</h2><p>当 AI 点击一个安全格时，游戏会返回一个数字：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">count</span><br></code></pre></td></tr></table></figure><p>表示：</p><blockquote><p>该格周围 8 个相邻格子中有 <code>count</code> 个地雷。</p></blockquote><p>AI 会做三件事：</p><ol><li>找出该格周围 <strong>所有状态未知的格子</strong></li><li>统计其中已经确定为地雷的数量</li><li>构造如下逻辑表达式：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&#123;相邻未知格集合&#125; <span class="hljs-operator">=</span> count<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">A</span><span class="hljs-operator">,</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-operator">,</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>含义是：</p><blockquote><p>在 A、B、C、D 四个格子中，<strong>恰好有 2 个地雷</strong>。</p></blockquote><hr><h2 id="2-知识的存储方式"><a href="#2-知识的存储方式" class="headerlink" title="2. 知识的存储方式"></a>2. 知识的存储方式</h2><p>每一条逻辑知识用一个 <code>Sentence</code> 表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Sentence(<br>    cells = 一组未知格子,<br>    count = 这些格子中地雷的数量<br>)<br></code></pre></td></tr></table></figure><p>AI 内部维护一个知识库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-variable language_">self</span>.knowledge = []<br></code></pre></td></tr></table></figure><p>用于存储所有逻辑句子。</p><hr><h2 id="3-基本推理规则"><a href="#3-基本推理规则" class="headerlink" title="3. 基本推理规则"></a>3. 基本推理规则</h2><p>AI 主要依靠以下三条规则进行推理。</p><hr><h3 id="（1）安全格推理"><a href="#（1）安全格推理" class="headerlink" title="（1）安全格推理"></a>（1）安全格推理</h3><p>若某个句子满足：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">cells</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>所有格子都不是地雷。</p></blockquote><p>因此这些格子全部是安全格。</p><hr><h3 id="（2）地雷推理"><a href="#（2）地雷推理" class="headerlink" title="（2）地雷推理"></a>（2）地雷推理</h3><p>若某个句子满足：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(cells)</span></span> == count<br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>所有格子都是地雷。</p></blockquote><hr><h3 id="（3）知识更新规则"><a href="#（3）知识更新规则" class="headerlink" title="（3）知识更新规则"></a>（3）知识更新规则</h3><p>当某个格子被确定后：</p><ul><li><p>如果是安全格：<br>从所有句子中移除该格</p></li><li><p>如果是地雷：<br>从所有句子中移除该格，并将计数减 1</p></li></ul><p>从而保证所有知识始终一致。</p><hr><h2 id="4-子集推理（核心）"><a href="#4-子集推理（核心）" class="headerlink" title="4. 子集推理（核心）"></a>4. 子集推理（核心）</h2><p>这是整个算法最重要的部分。</p><p>若存在两个逻辑句子：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">S1</span> ⊆ <span class="hljs-built_in">S2</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-keyword">A</span>, B&#125; = <span class="hljs-number">1</span><br>&#123;<span class="hljs-keyword">A</span>, B, C, D&#125; = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>则可推出：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">C</span><span class="hljs-operator">,</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>推理公式为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">S2</span> - <span class="hljs-built_in">S1</span> = count2 - count1<br></code></pre></td></tr></table></figure><p>通过不断应用该规则，AI 可以自动生成新的逻辑句子。</p><hr><h2 id="5-推理流程总结"><a href="#5-推理流程总结" class="headerlink" title="5. 推理流程总结"></a>5. 推理流程总结</h2><p>当 AI 获得新信息时，会不断循环执行：</p><ol><li>找出所有确定安全的格子</li><li>找出所有确定地雷的格子</li><li>更新所有句子</li><li>执行子集推理生成新句子</li></ol><p>直到知识库无法产生新信息为止。</p><hr><h1 id="1-Sentence-类：每段代码详细解释"><a href="#1-Sentence-类：每段代码详细解释" class="headerlink" title="1) Sentence 类：每段代码详细解释"></a>1) Sentence 类：每段代码详细解释</h1><p><code>Sentence</code> 的含义是一个约束：</p><blockquote><p><code>cells</code> 这堆格子里 <strong>恰好</strong> 有 <code>count</code> 个雷</p></blockquote><p>例如：<code>&#123;(1,2),(1,3),(2,3)&#125; = 1</code></p><hr><h2 id="1-1-known-mines"><a href="#1-1-known-mines" class="headerlink" title="1.1 known_mines"></a>1.1 <code>known_mines</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">known_mines</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 若数量等于格子数，则所有格子都必为地雷</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.count == <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.cells) <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.count &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>(<span class="hljs-variable language_">self</span>.cells)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><h3 id="这段代码在做什么？"><a href="#这段代码在做什么？" class="headerlink" title="这段代码在做什么？"></a>这段代码在做什么？</h3><ul><li>它想从一条句子里<strong>直接推出“哪些格子一定是雷”</strong>。</li></ul><h3 id="为什么-count-len-cells-就全是雷？"><a href="#为什么-count-len-cells-就全是雷？" class="headerlink" title="为什么 count == len(cells) 就全是雷？"></a>为什么 <code>count == len(cells)</code> 就全是雷？</h3><ul><li><code>cells</code> 里有 <code>len(cells)</code> 个格子</li><li>句子说其中 <strong>有 <code>count</code> 个雷</strong></li><li><p>如果 <code>count</code> 恰好等于格子数，意味着：</p><ul><li>“这里面每一个格子都是雷”，否则雷数就不够。</li></ul></li></ul><h3 id="为什么还要-count-gt-0？"><a href="#为什么还要-count-gt-0？" class="headerlink" title="为什么还要 count &gt; 0？"></a>为什么还要 <code>count &gt; 0</code>？</h3><ul><li><p>防止 <code>cells</code> 为空或一些边界情况：</p><ul><li>比如 <code>cells</code> 为空，<code>len(cells)=0</code>，<code>count</code> 也可能为 0（理论上）</li><li><code>count==len(cells)</code> 会成立，但“全是雷”没有意义</li></ul></li><li>加上 <code>count&gt;0</code> 更严谨：只有真的存在雷数量时才返回。</li></ul><h3 id="为什么-return-set-self-cells-要再套一层-set？"><a href="#为什么-return-set-self-cells-要再套一层-set？" class="headerlink" title="为什么 return set(self.cells) 要再套一层 set？"></a>为什么 <code>return set(self.cells)</code> 要再套一层 <code>set</code>？</h3><ul><li>返回一个新的集合拷贝，避免外部误修改 <code>self.cells</code>（更安全）。</li></ul><hr><h2 id="1-2-known-safes"><a href="#1-2-known-safes" class="headerlink" title="1.2 known_safes"></a>1.2 <code>known_safes</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">known_safes</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 若数量为 0，则所有格子都安全</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.count == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>(<span class="hljs-variable language_">self</span>.cells)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><h3 id="这段代码在做什么？-1"><a href="#这段代码在做什么？-1" class="headerlink" title="这段代码在做什么？"></a>这段代码在做什么？</h3><ul><li>从句子直接推出“哪些格子一定安全”。</li></ul><h3 id="为什么-count-0-就全安全？"><a href="#为什么-count-0-就全安全？" class="headerlink" title="为什么 count == 0 就全安全？"></a>为什么 <code>count == 0</code> 就全安全？</h3><ul><li>句子含义是“这些格子里有 <code>count</code> 个雷”</li><li><p>如果 <code>count=0</code>，说明：</p><ul><li>“这里面一个雷都没有”</li><li>所以全是安全格。</li></ul></li></ul><hr><h2 id="1-3-mark-mine"><a href="#1-3-mark-mine" class="headerlink" title="1.3 mark_mine"></a>1.3 <code>mark_mine</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mark_mine</span>(<span class="hljs-params">self, cell</span>):<br>    <span class="hljs-comment"># 移除该格并减少计数，因为这个雷已被“解释”掉</span><br>    <span class="hljs-keyword">if</span> cell <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.cells:<br>        <span class="hljs-variable language_">self</span>.cells.remove(cell)<br>        <span class="hljs-variable language_">self</span>.count -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="这段代码在做什么？-2"><a href="#这段代码在做什么？-2" class="headerlink" title="这段代码在做什么？"></a>这段代码在做什么？</h3><p>当外部已经确定某个格子 <code>cell</code> 是雷时，要把这个信息同步到当前句子里。</p><h3 id="为什么要-remove-cell-？"><a href="#为什么要-remove-cell-？" class="headerlink" title="为什么要 remove(cell)？"></a>为什么要 <code>remove(cell)</code>？</h3><ul><li>当前句子的 <code>cells</code> 表示“还不确定状态的格子”</li><li>既然 <code>cell</code> 已经确定是雷了，就不应该继续留在“未知集合”里。</li></ul><h3 id="为什么还要-count-1？"><a href="#为什么还要-count-1？" class="headerlink" title="为什么还要 count -= 1？"></a>为什么还要 <code>count -= 1</code>？</h3><p>因为句子原本说：</p><blockquote><p><code>cells</code> 里一共有 <code>count</code> 个雷</p></blockquote><p>如果我们已经知道其中某一个 <code>cell</code> 是雷，那么剩下的雷数量就应该减少 1：</p><ul><li>原来：<code>&#123;A, B, C&#125; = 2</code></li><li><p>若发现 <code>C</code> 是雷：</p><ul><li>剩余未知就变成 <code>&#123;A, B&#125;</code></li><li>雷数变成 <code>1</code></li></ul></li><li>所以必须 <code>count -= 1</code></li></ul><hr><h2 id="1-4-mark-safe"><a href="#1-4-mark-safe" class="headerlink" title="1.4 mark_safe"></a>1.4 <code>mark_safe</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mark_safe</span>(<span class="hljs-params">self, cell</span>):<br>    <span class="hljs-comment"># 安全格可直接移除，计数不变</span><br>    <span class="hljs-keyword">if</span> cell <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.cells:<br>        <span class="hljs-variable language_">self</span>.cells.remove(cell)<br></code></pre></td></tr></table></figure><h3 id="为什么安全格移除但-count-不变？"><a href="#为什么安全格移除但-count-不变？" class="headerlink" title="为什么安全格移除但 count 不变？"></a>为什么安全格移除但 <code>count</code> 不变？</h3><p>句子说的是“雷的数量”，安全格不是雷，因此不会占用雷数：</p><ul><li>原来：<code>&#123;A, B, C&#125; = 2</code></li><li><p>若发现 <code>C</code> 安全：</p><ul><li>剩余未知变 <code>&#123;A, B&#125;</code></li><li>雷还是 <code>2</code></li></ul></li><li>所以只移除，不减 count。</li></ul><hr><h1 id="2-MinesweeperAI-类：每段代码详细解释"><a href="#2-MinesweeperAI-类：每段代码详细解释" class="headerlink" title="2) MinesweeperAI 类：每段代码详细解释"></a>2) MinesweeperAI 类：每段代码详细解释</h1><p>AI 维护全局状态：</p><ul><li><code>moves_made</code>: 已经点过的格子</li><li><code>safes</code>: 已知安全</li><li><code>mines</code>: 已知地雷</li><li><code>knowledge</code>: 逻辑句子列表</li></ul><hr><h2 id="2-1-mark-mine"><a href="#2-1-mark-mine" class="headerlink" title="2.1 mark_mine"></a>2.1 <code>mark_mine</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mark_mine</span>(<span class="hljs-params">self, cell</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    标记某格为地雷，并同步更新所有已知句子。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-variable language_">self</span>.mines.add(cell)<br>    <span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge:<br>        sentence.mark_mine(cell)<br></code></pre></td></tr></table></figure><h3 id="这段代码做什么？"><a href="#这段代码做什么？" class="headerlink" title="这段代码做什么？"></a>这段代码做什么？</h3><ul><li>把 <code>cell</code> 放到 AI 的“地雷集合”里</li><li>并告诉知识库里的每一句话：这个格子是雷（更新约束）</li></ul><h3 id="为什么要遍历所有句子更新？"><a href="#为什么要遍历所有句子更新？" class="headerlink" title="为什么要遍历所有句子更新？"></a>为什么要遍历所有句子更新？</h3><p>因为任何一句话里只要包含这个格子，都必须变成“已解释过的雷”，不然知识库会不一致。</p><hr><h2 id="2-2-mark-safe"><a href="#2-2-mark-safe" class="headerlink" title="2.2 mark_safe"></a>2.2 <code>mark_safe</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mark_safe</span>(<span class="hljs-params">self, cell</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    标记某格为安全，并同步更新所有已知句子。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-variable language_">self</span>.safes.add(cell)<br>    <span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge:<br>        sentence.mark_safe(cell)<br></code></pre></td></tr></table></figure><p>同理：</p><ul><li>放入安全集合</li><li>同步删掉所有句子里包含它的部分（保持一致）</li></ul><hr><h1 id="2-3-add-knowledge（最关键：逐段拆解）"><a href="#2-3-add-knowledge（最关键：逐段拆解）" class="headerlink" title="2.3 add_knowledge（最关键：逐段拆解）"></a>2.3 <code>add_knowledge</code>（最关键：逐段拆解）</h1><p>函数目标：点击一个安全格 <code>cell</code>，游戏告诉你周围雷数 <code>count</code>，AI 要把它变成知识并推理。</p><hr><h3 id="1-记录“已经点过”"><a href="#1-记录“已经点过”" class="headerlink" title="(1) 记录“已经点过”"></a>(1) 记录“已经点过”</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-variable language_">self</span>.moves_made.add(cell)<br></code></pre></td></tr></table></figure><ul><li>防止后续再点同一个格子</li><li><code>make_safe_move</code> / <code>make_random_move</code> 都会依赖它过滤候选。</li></ul><hr><h3 id="2-标记为安全"><a href="#2-标记为安全" class="headerlink" title="(2) 标记为安全"></a>(2) 标记为安全</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-variable language_">self</span>.mark_safe(cell)<br></code></pre></td></tr></table></figure><p>因为调用 <code>add_knowledge(cell,count)</code> 的前提就是：<strong>这个 cell 是你点开的安全格</strong>（游戏只会对安全格给数字）。</p><hr><h3 id="3-收集未知邻居，修正计数"><a href="#3-收集未知邻居，修正计数" class="headerlink" title="(3) 收集未知邻居，修正计数"></a>(3) 收集未知邻居，修正计数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">neighbors = <span class="hljs-built_in">set</span>()<br>adjusted_count = count<br></code></pre></td></tr></table></figure><ul><li><code>neighbors</code>：用来放“周围尚未知状态”的格子</li><li><code>adjusted_count</code>：因为周围如果有一些格子已知是雷，<code>count</code> 里已经包含它们了，但我们之后的句子里不会包含这些已知雷，所以要减掉。</li></ul><hr><h3 id="4-枚举周围-8-格"><a href="#4-枚举周围-8-格" class="headerlink" title="(4) 枚举周围 8 格"></a>(4) 枚举周围 8 格</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cell[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, cell[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cell[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, cell[<span class="hljs-number">1</span>] + <span class="hljs-number">2</span>):<br></code></pre></td></tr></table></figure><p>这里 <code>+2</code> 是因为 Python range 不包含右端点。<br>所以实际 i/j 取值是：</p><ul><li><code>cell[0]-1, cell[0], cell[0]+1</code></li><li><code>cell[1]-1, cell[1], cell[1]+1</code></li></ul><p>即 3×3 的区域。</p><hr><h3 id="5-跳过自身"><a href="#5-跳过自身" class="headerlink" title="(5) 跳过自身"></a>(5) 跳过自身</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> (i, j) == cell:<br>    <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><p>扫雷规则中：数字只统计“周围”，不包括自己。</p><hr><h3 id="6-边界检查"><a href="#6-边界检查" class="headerlink" title="(6) 边界检查"></a>(6) 边界检查</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= i &lt; <span class="hljs-variable language_">self</span>.height <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= j &lt; <span class="hljs-variable language_">self</span>.width:<br></code></pre></td></tr></table></figure><p>防止访问越界（比如在角落格子时会出现 -1 或 width）。</p><hr><h3 id="7-处理邻居格子的三种情况"><a href="#7-处理邻居格子的三种情况" class="headerlink" title="(7) 处理邻居格子的三种情况"></a>(7) 处理邻居格子的三种情况</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">neighbor = (i, j)<br><span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.mines:<br>    adjusted_count -= <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.safes:<br>    neighbors.add(neighbor)<br></code></pre></td></tr></table></figure><p><strong>情况 A：邻居是已知雷</strong></p><ul><li>说明 <code>count</code> 的雷里有一个已经被我们“确定”了</li><li>但我们的新句子不会把这个格子再算进 <code>cells</code>（因为它不再未知）</li><li>所以必须：<code>adjusted_count -= 1</code></li></ul><p><strong>情况 B：邻居是已知安全</strong></p><ul><li>不加入 <code>neighbors</code></li><li>因为句子只应该描述“未知格”</li></ul><p><strong>情况 C：邻居未知</strong></p><ul><li>加入 <code>neighbors</code></li></ul><hr><h3 id="8-把新句子加入知识库"><a href="#8-把新句子加入知识库" class="headerlink" title="(8) 把新句子加入知识库"></a>(8) 把新句子加入知识库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> neighbors:<br>    <span class="hljs-variable language_">self</span>.knowledge.append(Sentence(neighbors, adjusted_count))<br></code></pre></td></tr></table></figure><p>如果周围还有未知格子，就形成约束：</p><blockquote><p><code>neighbors</code> 里恰好 <code>adjusted_count</code> 个雷</p></blockquote><hr><h2 id="2-4-推理循环（直到无新结论）"><a href="#2-4-推理循环（直到无新结论）" class="headerlink" title="2.4 推理循环（直到无新结论）"></a>2.4 推理循环（直到无新结论）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">changed = <span class="hljs-literal">True</span><br><span class="hljs-keyword">while</span> changed:<br>    changed = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><code>changed</code> 作为“本轮是否推导出新信息”的标记。<br>只要推导出了新 safe/mine/new sentence，就再循环一次。</p><hr><h3 id="1-从每个句子里提取可确定信息"><a href="#1-从每个句子里提取可确定信息" class="headerlink" title="(1) 从每个句子里提取可确定信息"></a>(1) 从每个句子里提取可确定信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">new_mines = <span class="hljs-built_in">set</span>()<br>new_safes = <span class="hljs-built_in">set</span>()<br><span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge:<br>    new_mines.update(sentence.known_mines())<br>    new_safes.update(sentence.known_safes())<br></code></pre></td></tr></table></figure><ul><li>遍历所有句子</li><li>如果发现 “全是雷” 或 “全是安全”</li><li>就把这些格子加入临时集合，等待统一更新。</li></ul><hr><h3 id="2-把推导结果同步到全局"><a href="#2-把推导结果同步到全局" class="headerlink" title="(2) 把推导结果同步到全局"></a>(2) 把推导结果同步到全局</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> mine <span class="hljs-keyword">in</span> new_mines:<br>    <span class="hljs-keyword">if</span> mine <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.mines:<br>        <span class="hljs-variable language_">self</span>.mark_mine(mine)<br>        changed = <span class="hljs-literal">True</span><br><span class="hljs-keyword">for</span> safe <span class="hljs-keyword">in</span> new_safes:<br>    <span class="hljs-keyword">if</span> safe <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.safes:<br>        <span class="hljs-variable language_">self</span>.mark_safe(safe)<br>        changed = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>这里的 <code>if mine not in self.mines</code> 是为了避免重复标记。<br>只要新增了信息，就把 <code>changed</code> 设为 True，说明还要继续推理。</p><hr><h3 id="3-清理空句子"><a href="#3-清理空句子" class="headerlink" title="(3) 清理空句子"></a>(3) 清理空句子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-variable language_">self</span>.knowledge = [s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge <span class="hljs-keyword">if</span> s.cells]<br></code></pre></td></tr></table></figure><p>如果某句子的 <code>cells</code> 被删光了，就没意义了，删掉防止污染推理。</p><hr><h3 id="4-子集推理生成新句子"><a href="#4-子集推理生成新句子" class="headerlink" title="(4) 子集推理生成新句子"></a>(4) 子集推理生成新句子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> s1 <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge:<br>    <span class="hljs-keyword">for</span> s2 <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge:<br>        <span class="hljs-keyword">if</span> s1 <span class="hljs-keyword">is</span> s2:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> s1.cells <span class="hljs-keyword">and</span> s1.cells.issubset(s2.cells):<br>            diff_cells = s2.cells - s1.cells<br>            diff_count = s2.count - s1.count<br>            candidate = Sentence(diff_cells, diff_count)<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li>遍历任意两句 <code>s1, s2</code></li><li>如果 <code>s1.cells ⊆ s2.cells</code></li><li><p>那么可以推出：</p><ul><li><code>diff_cells = s2 - s1</code></li><li><code>diff_count = count2 - count1</code></li></ul></li></ul><p>这是作业说明里最重要的推理规则。</p><hr><h3 id="5-防止重复加入"><a href="#5-防止重复加入" class="headerlink" title="(5) 防止重复加入"></a>(5) 防止重复加入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> diff_cells <span class="hljs-keyword">and</span> candidate <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge <span class="hljs-keyword">and</span> candidate <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> inferred:<br>    inferred.append(candidate)<br></code></pre></td></tr></table></figure><ul><li><code>diff_cells</code> 为空就没意义</li><li>不能重复添加同样句子，否则知识库会无限膨胀</li></ul><hr><h3 id="6-加入知识库并继续循环"><a href="#6-加入知识库并继续循环" class="headerlink" title="(6) 加入知识库并继续循环"></a>(6) 加入知识库并继续循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> inferred:<br>    <span class="hljs-variable language_">self</span>.knowledge.extend(inferred)<br>    changed = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>只要产生了新句子，就说明可能可以推出更多 safe/mine，所以继续 while 循环。</p><hr><h1 id="3-make-safe-move-逐段解释"><a href="#3-make-safe-move-逐段解释" class="headerlink" title="3) make_safe_move 逐段解释"></a>3) <code>make_safe_move</code> 逐段解释</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_safe_move</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.safes:<br>        <span class="hljs-keyword">if</span> cell <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.moves_made:<br>            <span class="hljs-keyword">return</span> cell<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><ul><li>遍历所有已知安全格</li><li>找一个没点过的就返回</li><li>如果没有可点安全格，返回 <code>None</code></li></ul><p>注意：该函数<strong>不修改任何集合</strong>，只负责“选一个”。</p><hr><h1 id="4-make-random-move-逐段解释"><a href="#4-make-random-move-逐段解释" class="headerlink" title="4) make_random_move 逐段解释"></a>4) <code>make_random_move</code> 逐段解释</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_random_move</span>(<span class="hljs-params">self</span>):<br>    candidates = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.height):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.width):<br>            cell = (i, j)<br>            <span class="hljs-keyword">if</span> cell <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.moves_made <span class="hljs-keyword">or</span> cell <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.mines:<br>                <span class="hljs-keyword">continue</span><br>            candidates.append(cell)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> candidates:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> random.choice(candidates)<br></code></pre></td></tr></table></figure><ul><li>枚举全棋盘</li><li><p>排除：</p><ul><li>已点过的格子</li><li>已知地雷格子</li></ul></li><li>剩下的是“可猜测”的候选</li><li>从候选里随机挑一个</li></ul><p>如果候选为空，说明无路可走（游戏结束或全点完），返回 <code>None</code>。</p>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50 AI project1 Knights</title>
    <link href="/2026/01/24/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50AI-Project1-Knights/"/>
    <url>/2026/01/24/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50AI-Project1-Knights/</url>
    
    <content type="html"><![CDATA[<h1 id="Knights"><a href="#Knights" class="headerlink" title="Knights"></a>Knights</h1><p>编写一个程序来解决逻辑谜题。</p><hr><h2 id="何时完成（When-to-Do-It）"><a href="#何时完成（When-to-Do-It）" class="headerlink" title="何时完成（When to Do It）"></a>何时完成（When to Do It）</h2><p><strong>截止时间：</strong><br>📅 <strong>2026 年 7 月 1 日（星期三）上午 7:59（GMT+8）之前</strong>  </p><hr><h2 id="如何获取帮助（How-to-Get-Help）"><a href="#如何获取帮助（How-to-Get-Help）" class="headerlink" title="如何获取帮助（How to Get Help）"></a>如何获取帮助（How to Get Help）</h2><ol><li>通过 <strong>Ed</strong> 提问  </li><li>通过任意一个 <strong>CS50 官方社区</strong> 提问  </li></ol><hr><h2 id="背景（Background）"><a href="#背景（Background）" class="headerlink" title="背景（Background）"></a>背景（Background）</h2><p>1978 年，逻辑学家 <strong>Raymond Smullyan</strong> 出版了一本名为<br><strong>《What is the name of this book?》</strong> 的书。</p><p>在这本书中包含了一类著名的逻辑谜题，被称为：</p><blockquote><p><strong>骑士与骗子（Knights and Knaves）谜题</strong></p></blockquote><p>在这类谜题中，有如下设定：</p><ul><li>每个角色<strong>要么是骑士（Knight），要么是骗子（Knave）</strong></li><li><strong>骑士永远说真话</strong><ul><li>如果骑士说出一句话，那么这句话一定为真</li></ul></li><li><strong>骗子永远说假话</strong><ul><li>如果骗子说出一句话，那么这句话一定为假</li></ul></li></ul><hr><h3 id="谜题目标"><a href="#谜题目标" class="headerlink" title="谜题目标"></a>谜题目标</h3><p>给定每个角色所说的句子：</p><blockquote><p><strong>判断每个角色究竟是骑士还是骗子。</strong></p></blockquote><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设只有一个角色 <strong>A</strong>。</p><p>A 说：</p><blockquote><p>“我既是骑士，又是骗子。”</p></blockquote><p>我们可以这样推理：</p><ul><li>如果 A 是骑士，那么他说的话必须为真  </li><li>但这句话<strong>不可能为真</strong><br>因为一个人不可能同时既是骑士又是骗子  </li></ul><p>因此可以得出结论：</p><blockquote><p>✅ <strong>A 一定是骗子（knave）</strong></p></blockquote><hr><p>当然，这只是最简单的情况。<br>当角色更多、语句更复杂时，推理也会变得更加困难。</p><hr><h3 id="本项目的任务"><a href="#本项目的任务" class="headerlink" title="本项目的任务"></a>本项目的任务</h3><p>你的任务是：</p><blockquote><p><strong>使用命题逻辑来表示这些谜题，<br>使得一个运行模型检测算法（model-checking）的 AI 能够自动求解它们。</strong></p></blockquote><hr><h2 id="开始（Getting-Started）"><a href="#开始（Getting-Started）" class="headerlink" title="开始（Getting Started）"></a>开始（Getting Started）</h2><p>下载并解压项目代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>cdn.cs50.net<span class="hljs-regexp">/ai/</span><span class="hljs-number">2023</span><span class="hljs-regexp">/x/</span>projects<span class="hljs-regexp">/1/</span>knights.zip<br></code></pre></td></tr></table></figure><hr><h2 id="理解项目结构（Understanding）"><a href="#理解项目结构（Understanding）" class="headerlink" title="理解项目结构（Understanding）"></a>理解项目结构（Understanding）</h2><p>请查看文件 <strong><code>logic.py</code></strong>。</p><p>你不需要完全理解其中的所有代码，但需要注意：</p><h3 id="1️⃣-逻辑连接词类"><a href="#1️⃣-逻辑连接词类" class="headerlink" title="1️⃣ 逻辑连接词类"></a>1️⃣ 逻辑连接词类</h3><p>该文件中定义了多种逻辑结构，例如：</p><ul><li><code>And</code></li><li><code>Or</code></li><li><code>Not</code></li><li><code>Implication</code></li><li>等等</li></ul><p>这些类可以<strong>互相嵌套组合</strong>。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">And(Not(A), Or(B, C))<br></code></pre></td></tr></table></figure><p>表示的逻辑含义是：</p><blockquote><p>A 不成立，<br>并且 B 或 C 成立<br>（这里的“或”为<strong>包含或</strong>，不是异或）</p></blockquote><hr><h3 id="2️⃣-model-check-函数"><a href="#2️⃣-model-check-函数" class="headerlink" title="2️⃣ model_check 函数"></a>2️⃣ <code>model_check</code> 函数</h3><p><code>logic.py</code> 中还包含一个重要函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model_check(knowledge, query)<br></code></pre></td></tr></table></figure><ul><li><p><strong>knowledge（知识库）</strong><br>一个逻辑表达式<br>如果有多条知识，可以用 <code>And(...)</code> 连接起来</p></li><li><p><strong>query（查询语句）</strong><br>想要判断是否能从知识库中推出的命题</p></li></ul><p>该函数会：</p><ul><li>枚举所有可能的模型</li><li>判断：</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">knowledge ⊨ <span class="hljs-keyword">query</span><br></code></pre></td></tr></table></figure><p>如果知识库逻辑蕴含该查询，则返回 <code>True</code>，否则返回 <code>False</code>。</p><hr><h2 id="puzzle-py-文件说明"><a href="#puzzle-py-文件说明" class="headerlink" title="puzzle.py 文件说明"></a>puzzle.py 文件说明</h2><p>在 <code>puzzle.py</code> 文件顶部，已经定义了 6 个命题符号：</p><ul><li><code>AKnight</code>：A 是骑士  </li><li><code>AKnave</code>：A 是骗子  </li></ul><p>同样地，也为 B、C 定义了对应变量。</p><hr><h3 id="知识库变量"><a href="#知识库变量" class="headerlink" title="知识库变量"></a>知识库变量</h3><p>接下来你会看到四个知识库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge0<br>knowledge1<br>knowledge2<br>knowledge3<br></code></pre></td></tr></table></figure><p>它们分别对应：</p><ul><li>Puzzle 0</li><li>Puzzle 1</li><li>Puzzle 2</li><li>Puzzle 3</li></ul><p>目前它们都是<strong>空的</strong>。</p><p>👉 <strong>你的任务就是向这些知识库中添加逻辑知识。</strong></p><hr><h3 id="main-函数做了什么？"><a href="#main-函数做了什么？" class="headerlink" title="main 函数做了什么？"></a>main 函数做了什么？</h3><p><code>main</code> 函数会：</p><ol><li>遍历所有谜题</li><li>使用模型检测算法</li><li>推断每个角色是骑士还是骗子</li><li>输出能够确定的结论</li></ol><hr><h2 id="任务说明（Specification）"><a href="#任务说明（Specification）" class="headerlink" title="任务说明（Specification）"></a>任务说明（Specification）</h2><p>请向 <code>knowledge0</code>、<code>knowledge1</code>、<code>knowledge2</code>、<code>knowledge3</code> 中添加知识，使程序能够解决以下谜题。</p><hr><h3 id="🧩-Puzzle-0"><a href="#🧩-Puzzle-0" class="headerlink" title="🧩 Puzzle 0"></a>🧩 Puzzle 0</h3><ul><li>只有一个角色：A  </li><li>A 说：</li></ul><blockquote><p>“我既是骑士，又是骗子。”</p></blockquote><hr><h3 id="🧩-Puzzle-1"><a href="#🧩-Puzzle-1" class="headerlink" title="🧩 Puzzle 1"></a>🧩 Puzzle 1</h3><ul><li>两个角色：A 和 B  </li><li>A 说：</li></ul><blockquote><p>“我们都是骗子。”</p></blockquote><ul><li>B 什么也没说</li></ul><hr><h3 id="🧩-Puzzle-2"><a href="#🧩-Puzzle-2" class="headerlink" title="🧩 Puzzle 2"></a>🧩 Puzzle 2</h3><ul><li>两个角色：A 和 B  </li><li>A 说：</li></ul><blockquote><p>“我们是同一种人。”</p></blockquote><ul><li>B 说：</li></ul><blockquote><p>“我们是不同种类的人。”</p></blockquote><hr><h3 id="🧩-Puzzle-3"><a href="#🧩-Puzzle-3" class="headerlink" title="🧩 Puzzle 3"></a>🧩 Puzzle 3</h3><ul><li><p>三个角色：A、B、C  </p></li><li><p>A 说了以下两句话之一（但你不知道是哪一句）：</p><ul><li>“我是骑士。”</li><li>“我是骗子。”</li></ul></li><li><p>B 说：</p><blockquote><p>“A 说过：‘我是骗子。’”</p></blockquote></li><li><p>B 接着又说：</p><blockquote><p>“C 是骗子。”</p></blockquote></li><li><p>C 说：</p><blockquote><p>“A 是骑士。”</p></blockquote></li></ul><hr><h3 id="通用规则"><a href="#通用规则" class="headerlink" title="通用规则"></a>通用规则</h3><p>在以上所有谜题中：</p><ul><li>每个人要么是骑士，要么是骗子</li><li>骑士说的所有话都是真的</li><li>骗子说的所有话都是假的</li></ul><hr><p>完成知识库后，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python puzzle.py<br></code></pre></td></tr></table></figure><p>即可看到谜题的解答结果。</p><hr><h2 id="提示（Hints）"><a href="#提示（Hints）" class="headerlink" title="提示（Hints）"></a>提示（Hints）</h2><ul><li><p>每个知识库通常需要编码两类信息：</p><ol><li><strong>谜题的结构性规则</strong><ul><li>每个人非骑士即骗子</li></ul></li><li><strong>角色所说的话本身</strong></li></ol></li><li><p>思考：</p><ul><li>如果一句话是由骑士说的，会意味着什么？</li><li>如果一句话是由骗子说的，又意味着什么？</li><li>如何将“说真话 / 说假话”转化为逻辑公式？</li></ul></li></ul><hr><h3 id="⚠️-注意"><a href="#⚠️-注意" class="headerlink" title="⚠️ 注意"></a>⚠️ 注意</h3><p>虽然存在很多种写法都能得出正确答案：</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge0 = AKnave<br></code></pre></td></tr></table></figure><p>确实能得到正确结果，</p><p>但这<strong>违背了本题的精神</strong>。</p><blockquote><p>你的目标是：<br><strong>让 AI 自己推理出答案，而不是你提前替它推理。</strong></p></blockquote><hr><p>你也<strong>不需要，也不应该</strong>修改 <code>logic.py</code> 文件。</p><hr><h2 id="测试（Testing）"><a href="#测试（Testing）" class="headerlink" title="测试（Testing）"></a>测试（Testing）</h2><p>如果你已经配置好 <code>check50</code>，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">check50 ai50/projects/2024/x/knights<br></code></pre></td></tr></table></figure><p>检查正确性。</p><p>使用下面命令检查代码风格：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">style50<br></code></pre></td></tr></table></figure><hr><h2 id="提交方式（How-to-Submit）"><a href="#提交方式（How-to-Submit）" class="headerlink" title="提交方式（How to Submit）"></a>提交方式（How to Submit）</h2><ol><li><p>打开以下链接并使用 GitHub 登录：<br><a href="https://submit.cs50.io/invites/d03c31aef1984c29b5e7b268c3a87b7b">https://submit.cs50.io/invites/d03c31aef1984c29b5e7b268c3a87b7b</a></p></li><li><p>安装 Git（可选安装 submit50）</p></li><li><p>提交代码：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">submit50 ai50/projects/2024/x/knights<br></code></pre></td></tr></table></figure><p>或将代码推送至：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/me50/</span>USERNAME.git<br></code></pre></td></tr></table></figure><p>分支名：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ai50<span class="hljs-regexp">/projects/</span><span class="hljs-number">2024</span><span class="hljs-regexp">/x/</span>knights<br></code></pre></td></tr></table></figure><hr><p>作业通常会在 <strong>5 分钟内完成评分</strong>。</p><p>你可以在这里查看进度：</p><p>👉 <a href="https://cs50.me/cs50ai">https://cs50.me/cs50ai</a></p><hr><h1 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h1><h2 id="1-核心逻辑支柱"><a href="#1-核心逻辑支柱" class="headerlink" title="1. 核心逻辑支柱"></a>1. 核心逻辑支柱</h2><h3 id="A-身份约束（Identity-Constraints）"><a href="#A-身份约束（Identity-Constraints）" class="headerlink" title="A. 身份约束（Identity Constraints）"></a>A. 身份约束（Identity Constraints）</h3><p>在所有谜题中，每个角色（如 A）必须满足：</p><ul><li><strong>非此即彼</strong>：A 要么是骑士，要么是骗子。逻辑表达为：<code>Or(AKnight, AKnave)</code>。</li><li><strong>互斥性</strong>：A 不能同时既是骑士又是骗子。逻辑表达为：<code>Not(And(AKnight, AKnave))</code>。</li></ul><h3 id="B-说话规则（Speech-Rules）"><a href="#B-说话规则（Speech-Rules）" class="headerlink" title="B. 说话规则（Speech Rules）"></a>B. 说话规则（Speech Rules）</h3><p>这是将自然语言转化为逻辑公式的关键。若角色 A 说出命题 $S$：</p><ul><li>如果 A 是骑士，则 $S$ 为真；如果 A 是骗子，则 $S$ 为假。</li><li>在 <code>logic.py</code> 中，这可以用 <strong>双条件（Biconditional）</strong> 完美表达：<code>Biconditional(AKnight, S)</code>，意味着 $AKnight$ 与 $S$ 的真值必须始终保持一致。</li></ul><hr><h2 id="2-谜题逻辑建模代码实现"><a href="#2-谜题逻辑建模代码实现" class="headerlink" title="2. 谜题逻辑建模代码实现"></a>2. 谜题逻辑建模代码实现</h2><p>以下是各谜题在 <code>puzzle.py</code> 中的完整逻辑构建方案：</p><h3 id="🧩-Puzzle-0-1"><a href="#🧩-Puzzle-0-1" class="headerlink" title="🧩 Puzzle 0"></a>🧩 Puzzle 0</h3><p><strong>题目</strong>：A 说：“我既是骑士，又是骗子。”<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge0 = And(<br>    <span class="hljs-comment"># 身份约束</span><br>    Or(AKnight, AKnave), Not(And(AKnight, AKnave)),<br>    <span class="hljs-comment"># 说话规则</span><br>    Biconditional(AKnight, And(AKnight, AKnave))<br>)<br><br></code></pre></td></tr></table></figure></p><h3 id="🧩-Puzzle-1-1"><a href="#🧩-Puzzle-1-1" class="headerlink" title="🧩 Puzzle 1"></a>🧩 Puzzle 1</h3><p><strong>题目</strong>：A 说：“我们两个都是骗子。” B 什么也没说。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge1 = And(<br>    <span class="hljs-comment"># A, B 身份约束</span><br>    Or(AKnight, AKnave), Not(And(AKnight, AKnave)),<br>    Or(BKnight, BKnave), Not(And(BKnight, BKnave)),<br>    <span class="hljs-comment"># A 的陈述与其身份绑定</span><br>    Biconditional(AKnight, And(AKnave, BKnave))<br>)<br><br></code></pre></td></tr></table></figure><h3 id="🧩-Puzzle-2-1"><a href="#🧩-Puzzle-2-1" class="headerlink" title="🧩 Puzzle 2"></a>🧩 Puzzle 2</h3><p><strong>题目</strong>：A 说：“我们是同类。” B 说：“我们是不同种类的人。”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge2 = And(<br>    <span class="hljs-comment"># A, B 身份约束</span><br>    Or(AKnight, AKnave), Not(And(AKnight, AKnave)),<br>    Or(BKnight, BKnave), Not(And(BKnight, BKnave)),<br>    <span class="hljs-comment"># A 说两人身份等价</span><br>    Biconditional(AKnight, Biconditional(AKnight, BKnight)),<br>    <span class="hljs-comment"># B 说两人身份不等价</span><br>    Biconditional(BKnight, Not(Biconditional(AKnight, BKnight)))<br>)<br><br></code></pre></td></tr></table></figure><h3 id="🧩-Puzzle-3-1"><a href="#🧩-Puzzle-3-1" class="headerlink" title="🧩 Puzzle 3"></a>🧩 Puzzle 3</h3><p><strong>题目</strong>：A 说了“我是骑士”或“我是骗子”；B 声称“A 说了‘我是骗子’”；B 又说“C 是骗子”；C 说“A 是骑士”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge3 = And(<br>    <span class="hljs-comment"># A, B, C 身份约束</span><br>    Or(AKnight, AKnave), Not(And(AKnight, AKnave)),<br>    Or(BKnight, BKnave), Not(And(BKnight, BKnave)),<br>    Or(CKnight, CKnave), Not(And(CKnight, CKnave)),<br><br>    <span class="hljs-comment"># 1. 关于 A 的言论逻辑：无论 A 选哪句，其身份与陈述的真值一致性是隐含的。</span><br>    <span class="hljs-comment"># 2. B 的第一句：B 声称 A 说了“我是骗子”。</span><br>    <span class="hljs-comment"># 逻辑表达：B 是骑士 当且仅当 “A 是骑士 &lt;=&gt; A 是骗子” 为真。</span><br>    Biconditional(BKnight, Biconditional(AKnight, AKnave)),<br><br>    <span class="hljs-comment"># 3. B 的第二句：B 声称“C 是骗子”。</span><br>    Biconditional(BKnight, CKnave),<br><br>    <span class="hljs-comment"># 4. C 的陈述：C 声称“A 是骑士”。</span><br>    Biconditional(CKnight, AKnight)<br>)<br><br></code></pre></td></tr></table></figure><hr><h2 id="3-模型检测算法原理"><a href="#3-模型检测算法原理" class="headerlink" title="3. 模型检测算法原理"></a>3. 模型检测算法原理</h2><p><code>model_check(knowledge, query)</code> 函数的核心任务是判断一个逻辑推论是否有效。在逻辑学中，这被称为<strong>逻辑蕴含（Entailment）</strong>，记作 。</p><p>它的工作原理可以概括为：<strong>穷举所有可能的真相组合，验证在所有使“知识库”成立的情况下，“查询语句”是否也成立。</strong></p><hr><h2 id="1-核心算法流程：递归穷举"><a href="#1-核心算法流程：递归穷举" class="headerlink" title="1. 核心算法流程：递归穷举"></a>1. 核心算法流程：递归穷举</h2><p><code>model_check</code> 使用了一种深度优先的递归搜索算法（通常称为真值表枚举）：</p><ol><li><strong>收集符号</strong>：首先找出 <code>knowledge</code> 和 <code>query</code> 中出现的所有原子命题符号（如 <code>AKnight</code>, <code>AKnave</code>）。</li><li><strong>构建模型</strong>：模型（Model）是一个字典，为每个符号分配一个布尔值（<code>True</code> 或 <code>False</code>）。</li><li><strong>递归分支</strong>：</li></ol><ul><li>从符号集合中取出一个符号 。</li><li>分别创建一个  为 <code>True</code> 的分支和  为 <code>False</code> 的分支。</li><li>在每个分支中继续为剩余符号赋值，直到所有符号都被分配了真值。</li></ul><ol><li><strong>最终评估</strong>：当一个完整的模型建立后，评估该模型是否让 <code>knowledge</code> 为真。</li></ol><ul><li>如果 <code>knowledge</code> 在该模型下为 <strong>True</strong>，则必须检查 <code>query</code> 是否也为 <strong>True</strong>。</li><li>如果 <code>knowledge</code> 为 <strong>True</strong> 但 <code>query</code> 为 <strong>False</strong>，则推论失败，返回 <code>False</code>。</li></ul><hr><h2 id="2-详细案例分析：以-Puzzle-0-为例"><a href="#2-详细案例分析：以-Puzzle-0-为例" class="headerlink" title="2. 详细案例分析：以 Puzzle 0 为例"></a>2. 详细案例分析：以 Puzzle 0 为例</h2><p>假设我们要判断：在 <strong>Puzzle 0</strong> 的条件下，<strong>A 是否为骗子（AKnave）</strong>。</p><h3 id="初始条件"><a href="#初始条件" class="headerlink" title="初始条件"></a>初始条件</h3><ul><li><strong>符号集合</strong>：<code>&#123;AKnight, AKnave&#125;</code>。</li><li><strong>知识库 (<code>knowledge</code>)</strong>：</li></ul><ol><li><code>Or(AKnight, AKnave)</code>（A 是骑士或骗子）</li><li><code>Not(And(AKnight, AKnave))</code>（不能同时是两者）</li><li><code>Biconditional(AKnight, And(AKnight, AKnave))</code>（A 是骑士，当且仅当他说的话“我是骑士也是骗子”为真）</li></ol><ul><li><strong>查询句 (<code>query</code>)</strong>：<code>AKnave</code>。</li></ul><h3 id="递归遍历过程（真值表）"><a href="#递归遍历过程（真值表）" class="headerlink" title="递归遍历过程（真值表）"></a>递归遍历过程（真值表）</h3><p>AI 会遍历以下 4 个可能的模型：</p><div class="table-container"><table><thead><tr><th>模型 #</th><th>AKnight</th><th>AKnave</th><th>知识库 (<code>knowledge</code>) 评估</th><th>查询句 (<code>query</code>) 评估</th><th>结论</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>True</td><td>True</td><td><strong>False</strong> (违反互斥规则)</td><td>True</td><td>跳过</td></tr><tr><td><strong>2</strong></td><td>True</td><td>False</td><td><strong>False</strong> (违反说话规则： 为假)</td><td>False</td><td>跳过</td></tr><tr><td><strong>3</strong></td><td><strong>False</strong></td><td><strong>True</strong></td><td><strong>True</strong> (所有条件均满足)</td><td><strong>True</strong></td><td><strong>符合蕴含</strong></td></tr><tr><td><strong>4</strong></td><td>False</td><td>False</td><td><strong>False</strong> (违反完备规则)</td><td>True</td><td>跳过</td></tr></tbody></table></div><h3 id="逻辑判定"><a href="#逻辑判定" class="headerlink" title="逻辑判定"></a>逻辑判定</h3><p>在上述所有模型中，<strong>唯一一个</strong>能让 <code>knowledge</code> 为真的模型是 <strong>模型 3</strong>。在模型 3 中，<code>AKnave</code> 的值为 <code>True</code>。因此，AI 判定 <code>knowledge</code> 逻辑蕴含 <code>AKnave</code>，返回 <code>True</code>。</p><hr><h2 id="3-代码实现逻辑拆解"><a href="#3-代码实现逻辑拆解" class="headerlink" title="3. 代码实现逻辑拆解"></a>3. 代码实现逻辑拆解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_all</span>(<span class="hljs-params">knowledge, query, symbols, model</span>):<br>    <span class="hljs-comment"># 基准情况：如果符号集为空，说明模型已完整构建</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> symbols:<br>        <span class="hljs-comment"># 逻辑蕴含的定义：如果前提为真，结论必须为真</span><br>        <span class="hljs-keyword">if</span> knowledge.evaluate(model):<br>            <span class="hljs-keyword">return</span> query.evaluate(model)<br>        <span class="hljs-comment"># 如果前提为假，根据蕴含定义，该模型自动满足</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 递归步骤：选取一个符号</span><br>        remaining = symbols.copy()<br>        p = remaining.pop()<br><br>        <span class="hljs-comment"># 分支 1：假设 p 为真</span><br>        model_true = model.copy()<br>        model_true[p] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 分支 2：假设 p 为假</span><br>        model_false = model.copy()<br>        model_false[p] = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 只有两个分支都满足蕴含关系，才返回 True</span><br>        <span class="hljs-keyword">return</span> (check_all(knowledge, query, remaining, model_true) <span class="hljs-keyword">and</span><br>                check_all(knowledge, query, remaining, model_false))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂</title>
    <link href="/2026/01/21/Leetcode/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2026/01/21/Leetcode/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/快速幂/2026-01-21-21-35-09.png" alt=""></p><p>⚠️部分语言需要注意，当 $n = -2^{31}$ 时，$-n = 2^{31}$ 比 32 位整数的最大值还大，溢出了。可以转成 64 位整数解决。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> N)</span> &#123;<br>    <span class="hljs-type">double</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n = N;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// x^-n = (1/x)^n</span><br>        n = -n;<br>        x = <span class="hljs-number">1</span> / x;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (n) &#123; <span class="hljs-comment">// 从低到高枚举 n 的每个比特位</span><br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 这个比特位是 1</span><br>            ans *= x; <span class="hljs-comment">// 把 x 乘到 ans 中</span><br>        &#125;<br>        x *= x; <span class="hljs-comment">// x 自身平方</span><br>        n &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 继续枚举下一个比特位</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> N)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> N;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// x^-n = (1/x)^n</span><br>            n = -n;<br>            x = <span class="hljs-number">1</span> / x;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 从低到高枚举 n 的每个比特位</span><br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 这个比特位是 1</span><br>                ans *= x; <span class="hljs-comment">// 把 x 乘到 ans 中</span><br>            &#125;<br>            x *= x; <span class="hljs-comment">// x 自身平方</span><br>            n &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 继续枚举下一个比特位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DS</tag>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维前缀和</title>
    <link href="/2026/01/21/Leetcode/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2026/01/21/Leetcode/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/二维前缀和/2026-01-21-21-39-29.png" alt=""></p><h1 id="算法核心笔记：二维前缀和-2D-Prefix-Sum"><a href="#算法核心笔记：二维前缀和-2D-Prefix-Sum" class="headerlink" title="算法核心笔记：二维前缀和 (2D Prefix Sum)"></a>算法核心笔记：二维前缀和 (2D Prefix Sum)</h1><blockquote><p><strong>核心洞察</strong>：二维前缀和是“容斥原理”在矩阵计算中的完美应用。它通过预处理，将任意子矩阵的和查询耗时从 $O(N \times M)$ 降低到惊人的 <strong>$O(1)$</strong>。</p></blockquote><hr><h2 id="一、-什么是二维前缀和？"><a href="#一、-什么是二维前缀和？" class="headerlink" title="一、 什么是二维前缀和？"></a>一、 什么是二维前缀和？</h2><p>如果说一维前缀和是计算“一段线段”的和，那么二维前缀和就是计算“一个矩形区域”内所有元素的总和。</p><h3 id="1-核心定义"><a href="#1-核心定义" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h3><p>我们定义一个二维数组 <code>sum[i+1][j+1]</code>，它代表：<br>以原点 <code>a[0][0]</code> 为左上角，到 <code>a[i][j]</code> 为右下角的这个<strong>大矩形</strong>中所有元素的和。</p><ul><li><strong>小技巧</strong>：为了处理边界情况（比如第一行或第一列），我们通常将前缀和数组的下标整体偏移 +1，即 <code>sum[0][0]</code> 默认为 0。</li></ul><hr><h2 id="二、-核心逻辑图解"><a href="#二、-核心逻辑图解" class="headerlink" title="二、 核心逻辑图解"></a>二、 核心逻辑图解</h2><h3 id="1-如何初始化（构建前缀和矩阵）？"><a href="#1-如何初始化（构建前缀和矩阵）？" class="headerlink" title="1. 如何初始化（构建前缀和矩阵）？"></a>1. 如何初始化（构建前缀和矩阵）？</h3><p>要算出 <code>sum[i+1][j+1]</code>，我们不能简单地加减，而是要利用已经算好的“左边”和“上边”的面积。</p><p><strong>公式：</strong></p><script type="math/tex; mode=display">sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + a[i][j]</script><p><strong>通俗解释：</strong></p><ul><li><strong>加上左边的面积</strong>：<code>sum[i+1][j]</code></li><li><strong>加上上边的面积</strong>：<code>sum[i][j+1]</code></li><li><strong>减去重叠的部分</strong>：由于左边和上边的面积都包含了左上角的 <code>sum[i][j]</code>，它被加了两次，所以要<strong>减去一次</strong>。</li><li><strong>加上当前格子的值</strong>：最后带上当前的 <code>a[i][j]</code>。</li></ul><hr><h3 id="2-如何计算任意子矩阵的元素和？"><a href="#2-如何计算任意子矩阵的元素和？" class="headerlink" title="2. 如何计算任意子矩阵的元素和？"></a>2. 如何计算任意子矩阵的元素和？</h3><p>假设我们要计算左上角为 <code>(r1, c1)</code>，右下角为 <code>(r2, c2)</code> 的子矩阵和。</p><p><strong>公式：</strong></p><script type="math/tex; mode=display">Result = sum[r2+1][c2+1] - sum[r2+1][c1] - sum[r1][c2+1] + sum[r1][c1]</script><p><strong>通俗解释（切蛋糕法）：</strong></p><ol><li>拿走右下角的大蛋糕：<code>sum[r2+1][c2+1]</code></li><li><strong>减去左侧多余的长条</strong>：<code>sum[r2+1][c1]</code></li><li><strong>减去上方多余的长条</strong>：<code>sum[r1][c2+1]</code></li><li><strong>补回多减的角</strong>：在减去左侧和上方长条时，左上角的重叠区域 <code>sum[r1][c1]</code> 被多减了一次，所以要<strong>加回来</strong>。</li></ol><hr><h2 id="三、-代码实现"><a href="#三、-代码实现" class="headerlink" title="三、 代码实现"></a>三、 代码实现</h2><h3 id="1-C-语言实现-接口封装"><a href="#1-C-语言实现-接口封装" class="headerlink" title="1. C 语言实现 (接口封装)"></a>1. C 语言实现 (接口封装)</h3><p>在 LeetCode 的 C 语言模式下，通常使用结构体来模拟类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span>** preSum;<br>    <span class="hljs-type">int</span> rowSize;<br>    <span class="hljs-type">int</span> colSize;<br>&#125; NumMatrix;<br><br><span class="hljs-comment">/** 构造函数：预处理前缀和矩阵 */</span><br>NumMatrix* <span class="hljs-title function_">numMatrixCreate</span><span class="hljs-params">(<span class="hljs-type">int</span>** matrix, <span class="hljs-type">int</span> matrixSize, <span class="hljs-type">int</span>* matrixColSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (matrixSize == <span class="hljs-number">0</span> || matrixColSize[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <br>    NumMatrix* obj = (NumMatrix*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(NumMatrix));<br>    <span class="hljs-type">int</span> rows = matrixSize;<br>    <span class="hljs-type">int</span> cols = matrixColSize[<span class="hljs-number">0</span>];<br>    obj-&gt;rowSize = rows;<br>    obj-&gt;colSize = cols;<br>    <br>    <span class="hljs-comment">// 分配 preSum 空间 (rows + 1) x (cols + 1)</span><br>    obj-&gt;preSum = (<span class="hljs-type">int</span>**)<span class="hljs-built_in">malloc</span>((rows + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>*));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= rows; i++) &#123;<br>        obj-&gt;preSum[i] = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">calloc</span>((cols + <span class="hljs-number">1</span>), <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// calloc 自动初始化为0</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 填充前缀和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;<br>            obj-&gt;preSum[i][j] = obj-&gt;preSum[i - <span class="hljs-number">1</span>][j] + <br>                                obj-&gt;preSum[i][j - <span class="hljs-number">1</span>] - <br>                                obj-&gt;preSum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <br>                                matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-comment">/** 查询函数：O(1) 时间获取子矩阵和 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">numMatrixSumRegion</span><span class="hljs-params">(NumMatrix* obj, <span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> &#123;<br>    <span class="hljs-comment">// 转换到 preSum 的 1-based 下标</span><br>    <span class="hljs-keyword">return</span> obj-&gt;preSum[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - <br>           obj-&gt;preSum[row1][col2 + <span class="hljs-number">1</span>] - <br>           obj-&gt;preSum[row2 + <span class="hljs-number">1</span>][col1] + <br>           obj-&gt;preSum[row1][col1];<br>&#125;<br><br><span class="hljs-comment">/** 析构函数：释放内存 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">numMatrixFree</span><span class="hljs-params">(NumMatrix* obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= obj-&gt;rowSize; i++) &#123;<br>        <span class="hljs-built_in">free</span>(obj-&gt;preSum[i]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(obj-&gt;preSum);<br>    <span class="hljs-built_in">free</span>(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Java-实现-经典类封装"><a href="#2-Java-实现-经典类封装" class="headerlink" title="2. Java 实现 (经典类封装)"></a>2. Java 实现 (经典类封装)</h3><p>Java 版更加简洁，利用数组初始值为 0 的特性简化了代码。</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] preSum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>            <span class="hljs-comment">// preSum[i][j] 表示从 matrix[0][0] 到 matrix[i-1][j-1] 的总和</span><br>            preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                    preSum[i][j] = preSum[i - <span class="hljs-number">1</span>][j] + <br>                                   preSum[i][j - <span class="hljs-number">1</span>] - <br>                                   preSum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <br>                                   matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> &#123;<br>        <span class="hljs-comment">// 利用容斥原理：大矩形 - 上方长条 - 左侧长条 + 重叠角落</span><br>        <span class="hljs-keyword">return</span> preSum[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - <br>               preSum[row1][col2 + <span class="hljs-number">1</span>] - <br>               preSum[row2 + <span class="hljs-number">1</span>][col1] + <br>               preSum[row1][col1];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></h2><h2 id="四、-避坑指南"><a href="#四、-避坑指南" class="headerlink" title="四、 避坑指南"></a>四、 避坑指南</h2><ol><li><strong>下标偏移</strong>：强烈建议 <code>sum</code> 数组多开一行一列（即 <code>n+1, m+1</code>），这能避免判断 <code>i-1</code> 是否越界。</li><li><strong>数据溢出</strong>：对于较大的矩阵或元素，<code>sum</code> 数组一定要使用 <code>long long</code> (C++) 或 <code>long</code> (Java)，否则容易发生溢出。</li><li><strong>坐标对应</strong>：计算时要注意题目给出的是“下标”还是“第几个数”，确保 <code>r1, c1</code> 与 <code>sum</code> 数组的对应关系正确。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DS</tag>
      
      <tag>二维前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模运算</title>
    <link href="/2026/01/21/Leetcode/%E6%A8%A1%E8%BF%90%E7%AE%97/"/>
    <url>/2026/01/21/Leetcode/%E6%A8%A1%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/">https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/</a></p><h1 id="分享丨模运算的世界：当加减乘除遇上取模（模运算恒等式-费马小定理-组合数）"><a href="#分享丨模运算的世界：当加减乘除遇上取模（模运算恒等式-费马小定理-组合数）" class="headerlink" title="分享丨模运算的世界：当加减乘除遇上取模（模运算恒等式/费马小定理/组合数）"></a>分享丨模运算的世界：当加减乘除遇上取模（模运算恒等式/费马小定理/组合数）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>某些题目，由于要计算的答案非常大（超出 64 位整数的范围），会要求把答案对 10⁹+7 取模。如果没有处理得当的话，会 WA（错误）或者 TLE（超时）。</p><p>例如计算一堆数字的乘积，如果没有及时取模，乘法会溢出（例如计算结果超出 C++ 中 <code>long long</code> 的最大值），从而得到和预期不符的答案。对于 Python 来说，虽然没有溢出的问题，但大整数（big integer）之间的运算并不是 O(1) 的，可能会导致 TLE。</p><p>如何正确地取模呢？</p><hr><h2 id="加法和乘法的取模"><a href="#加法和乘法的取模" class="headerlink" title="加法和乘法的取模"></a>加法和乘法的取模</h2><p>如果让你计算 <code>1234 × 6789</code> 的个位数，你会如何计算？</p><p>由于只有个位数会影响到乘积的个位数，那么 <code>4 × 9 = 36</code> 的个位数 6 就是答案。</p><p>对于 <code>1234 + 6789</code> 的个位数，同理，<code>4 + 9 = 13</code> 的个位数 3 就是答案。</p><p>你能把这个结论抽象成数学等式吗？</p><p>一般涉及到取模的题目，会用到如下两个恒等式，其中 mod 表示取模运算（modulo），即编程语言中的 <code>%</code>。上面计算的是 m=10 的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(a + b) mod m = ((a mod m) + (b mod m)) mod m<br>(a ⋅ b) mod m = ((a mod m) ⋅ (b mod m)) mod m<br></code></pre></td></tr></table></figure><p>证明：根据带余除法，任意整数 a 都可以表示为 <code>a = q m + r</code>（m ≠ 0），其中整数 q 为 a 除以 m 的商（quotient），整数 r 为 a 除以 m 的余数（remainder），即 r = a mod m。</p><p>设整数 a = q₁ m + r₁，b = q₂ m + r₂。</p><p>第一个恒等式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">(a + b) mod m <br>= ((q₁ + q₂)m + r₁ + r₂) mod m <br>= (r₁ + r₂) mod m <br>= ((a mod m) + (b mod m)) mod m<br></code></pre></td></tr></table></figure><p>第二个恒等式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">(a⋅b) mod m<br>= (q₁q₂m² + (q₁r₂+q₂r₁)m + r₁r₂) mod m<br>= (r₁r₂) mod m<br>= ((a mod m)⋅(b mod m)) mod m<br></code></pre></td></tr></table></figure><p>根据这两个恒等式，我们可以在计算过程中（例如循环），对加法和乘法的结果取模，而不是在循环结束后再取模。</p><p>注：如果涉及到幂运算，指数是不能随意取模的。如果指数在 64 位整数的范围内，可以用快速幂计算；如果指数超出范围，则需要使用欧拉降幂等技巧。</p><hr><h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><p>首先引入 同余（congruence modulo）的概念。</p><p>两个整数 x 和 y，如果 <code>(x − y) mod m = 0</code>（也就是 x − y 是 m 的倍数），则称 x 与 y 关于模 m 同余，记作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x ≡ y (mod m)<br></code></pre></td></tr></table></figure><p>上式也称作模 m 的同余式，简称同余式。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">42</span> ≡ <span class="hljs-number">12</span> (mod <span class="hljs-number">10</span>)<br>−<span class="hljs-number">17</span> ≡ <span class="hljs-number">3</span> (mod <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>特别地：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">m ≡ <span class="hljs-number">0</span> (mod m)<br></code></pre></td></tr></table></figure><hr><h2 id="同余式的移项"><a href="#同余式的移项" class="headerlink" title="同余式的移项"></a>同余式的移项</h2><p>同余式中的加减法可以移项。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a + b ≡ c + d (mod m)<br></code></pre></td></tr></table></figure><p>可以移项得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a − c ≡ d − b (mod m)<br></code></pre></td></tr></table></figure><p>推论：在同余式两边加上或减去同一个数，同余式仍然成立。</p><p>特别地，在同余式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0</span> ≡ m (mod m)<br></code></pre></td></tr></table></figure><p>的两边加上 −x，得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">−x ≡ m − x (mod m)<br></code></pre></td></tr></table></figure><p>例如在无符号 32 位整数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">−<span class="hljs-number">1</span> ≡ <span class="hljs-number">4294967295</span> (mod <span class="hljs-number">2</span>³²)<br></code></pre></td></tr></table></figure><hr><h2 id="负数和减法的取模"><a href="#负数和减法的取模" class="headerlink" title="负数和减法的取模"></a>负数和减法的取模</h2><p>根据同余的定义，我们有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">−<span class="hljs-number">17</span> ≡ <span class="hljs-number">3</span> (mod <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>怎么从 −17 得到 3？</p><p>我们可以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">−<span class="hljs-number">17</span> + <span class="hljs-number">10</span> + <span class="hljs-number">10</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>也可以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">−<span class="hljs-number">17</span> mod <span class="hljs-number">10</span> + <span class="hljs-number">10</span> = −<span class="hljs-number">7</span> + <span class="hljs-number">10</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>这样只需加一次 m。</p><p>一般地，如果 x &lt; 0 且 0 ≤ y &lt; m，则 x ≡ y (mod m) 相当于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x mod m + m = y<br></code></pre></td></tr></table></figure><p>也就是用「模 m 加 m」，把 x「调整」为非负数。</p><p>为了避免判断 x &lt; 0，可以统一写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(x mod m + m) mod m<br></code></pre></td></tr></table></figure><p>这样无论 x 是正是负还是零，运算结果都会落在区间 [0, m − 1] 中。</p><p>对于减法来说，当 a − b ≥ 0 时，取模可以写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(a − b) mod m<br>= ((a mod m) − (b mod m) + m) mod m<br></code></pre></td></tr></table></figure><p>注：</p><ul><li>在代码实现时，在计算中产生负数也可以，在最后用 <code>(x mod m + m) mod m</code> 调整就行。</li><li>Python 用户可以忽略，只要 m 是正整数，取模运算结果就一定是非负的。</li></ul><hr><h2 id="除法的取模"><a href="#除法的取模" class="headerlink" title="除法的取模"></a>除法的取模</h2><p>如果要计算 $\frac{24}{8} \bmod 5$，可以像加法或乘法那样，写成 $\frac{24 \bmod 5}{8 \bmod 5} \bmod 5$ 吗？这不行，$\frac{24 \bmod 5}{8 \bmod 5} = \frac{4}{3}$ 甚至不是一个整数。</p><p>先说结论，如果 $p$ 是一个质数，$a$ 是 $b$ 的倍数且 $b$ 和 $p$ 互质（$b$ 不是 $p$ 的倍数），那么有</p><script type="math/tex; mode=display">\frac{a}{b} \bmod p = (a \cdot b^{p-2}) \bmod p</script><p>上式中 $a$ 和 $b$ 可以是很大的数，例如 $a = 100!, b = 50!50!$。</p><p>由于 $10^9 + 7$ 是一个质数，所以上式可用于要求对 $10^9 + 7$ 取模的题目。如果推导出了包含除法的式子，可以用上式转换成乘法，并用快速幂计算 $b^{p-2} \bmod p$。</p><p>下面是证明。</p><p><strong>引理 1：</strong> 当 $p$ 是质数且 $1 \le i \le p - 1$ 时，有</p><script type="math/tex; mode=display">\binom{p}{i} \equiv 0 \pmod p</script><p>其中</p><script type="math/tex; mode=display">\binom{p}{i} = \frac{p!}{i!(p - i)!}</script><p><strong>证明：</strong> 注意当 $1 \le i \le p - 1$ 时，$\frac{p!}{i!(p - i)!}$ 的分母是不包含 $p$ 的。由于分子包含 $p$ 且 $\frac{p!}{i!(p - i)!}$ 是整数，所以 $\binom{p}{i}$ 可以被 $p$ 整除，即 $\binom{p}{i} \equiv 0 \pmod p$。</p><p><strong>注：</strong> 如果 $p$ 不是质数，分母可能被 $p$ 整除，上面的结论不一定成立。例如 $p = 4, i = 2$ 的情况，$\binom{p}{i} = 6$，不是 $p = 4$ 的倍数。</p><p><strong>引理 2：</strong> 对于任意整数 $x$ 和 $y$ 和任意质数 $p$，有</p><script type="math/tex; mode=display">(x + y)^p \equiv x^p + y^p \pmod p</script><p><strong>证明：</strong> 根据二项式定理，有</p><script type="math/tex; mode=display">(x + y)^p = \binom{p}{0}x^p y^0 + \binom{p}{1}x^{p-1} y^1 + \binom{p}{2}x^{p-2} y^2 + \dots + \binom{p}{p-1}x^1 y^{p-1} + \binom{p}{p}x^0 y^p</script><p>根据引理 1，除了第一项和最后一项以外，其余项都是 $p$ 的倍数，于是</p><p><strong>定理</strong>（费马小定理）：对于任意整数 $b$ 和任意质数 $p$，有 <script type="math/tex">b^p \equiv b \pmod p</script> <strong>证明</strong>：当 $b = 0$ 时，$0^p \equiv 0 \pmod p$ 成立。 假设 $b = k$ 时原命题成立，即 <script type="math/tex">k^p \equiv k \pmod p</script> 根据引理 2，我们有 <script type="math/tex">(k + 1)^p \equiv k^p + 1^p \pmod p</script> 根据归纳假设，得 <script type="math/tex">(k + 1)^p \equiv k + 1 \pmod p</script> 即当 $b = k + 1$ 时，原命题成立。 根据数学归纳法，原命题对于 $b \ge 0$ 成立。对于 $b &lt; 0$ 的情况同理。 $b^p \equiv b \pmod p$ 变形得 $b(b^{p-1} - 1) \equiv 0 \pmod p$，如果 $b$ 不是 $p$ 的倍数，那么 $b^{p-1} - 1$ 必须是 $p$ 的倍数（注意 $p$ 是质数），即 $b^{p-1} - 1 \equiv 0 \pmod p$，移项得 <script type="math/tex">b^{p-1} \equiv 1 \pmod p</script> 两边同时乘以 $\frac{a}{b}$（$a$ 是 $b$ 的倍数），得 <script type="math/tex">a \cdot b^{p-2} \equiv \frac{a}{b} \pmod p</script> 即 <script type="math/tex">\frac{a}{b} \bmod p = (a \cdot b^{p-2}) \bmod p</script> 注：除以 $b$ 相当于乘以 $b$ 的<strong>逆元</strong> $b^{-1} \bmod p$。在概率期望等题目中，会遇到 $a$ 不是 $b$ 的倍数的情况，这些题目通常会规定计算 $(a \cdot b^{-1}) \bmod p$，计算方法和上式一样。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码实现时，上面的加减乘除通常是这样写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs python">MOD = <span class="hljs-number">1_000_000_007</span><br><br>// 加<br>(a + b) % MOD<br><br>// 减，b 在 [<span class="hljs-number">0</span>,MOD-<span class="hljs-number">1</span>] 中<br>(a - b + MOD) % MOD<br><br>// 把任意整数 a 取模到 [<span class="hljs-number">0</span>,MOD-<span class="hljs-number">1</span>] 中，无论 a 是正是负<br>(a % MOD + MOD) % MOD<br><br>// 乘（注意使用 <span class="hljs-number">64</span> 位整数）<br>a * b % MOD<br><br>// 多个数相乘，要步步取模，防止溢出<br>a * b % MOD * c % MOD<br><br>// 除（MOD 是质数且 b 不是 MOD 的倍数）<br>a * qpow(b, MOD - <span class="hljs-number">2</span>, MOD) % MOD<br>````<br><br>其中 `qpow` 为**快速幂**，具体请看【图解】一张图秒懂快速幂。<br><br>&gt; 注：Python 内置快速幂函数 `<span class="hljs-built_in">pow</span>(x, y, m)` 用于计算 $x^y \bmod m$。特别地，除法也可以写成 `a * <span class="hljs-built_in">pow</span>(b, -<span class="hljs-number">1</span>, MOD) % MOD`。<br><br>总之，如果发现解答错误，可以检查下代码，看看是不是哪里漏掉取模了。<br><br>---<br><br><span class="hljs-comment">## 附：组合数的计算</span><br><br>关于组合数，我们需要预处理阶乘及其逆元，然后利用公式<br><br>$$C(n,m) = \frac&#123;n!&#125;&#123;m!(n-m)!&#125; = n! \cdot \frac&#123;<span class="hljs-number">1</span>&#125;&#123;m!&#125; \cdot \frac&#123;<span class="hljs-number">1</span>&#125;&#123;(n-m)!&#125;$$<br><br>计算。<br><br>对于阶乘 $n!$，可以用<br><br>$$n! = (n - <span class="hljs-number">1</span>)! \cdot n$$<br><br>递推计算。<br><br>对于阶乘的倒数 $\frac&#123;<span class="hljs-number">1</span>&#125;&#123;n!&#125;$，可以先计算 $N!$ 的逆元（其中 $N$ 是 $n$ 的最大值），然后用<br><br>$$\frac&#123;<span class="hljs-number">1</span>&#125;&#123;(n-<span class="hljs-number">1</span>)!&#125; = \frac&#123;<span class="hljs-number">1</span>&#125;&#123;n!&#125; \cdot n$$<br><br>倒着递推计算。<br><br>模板代码如下：<br><br>```java<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    private static final <span class="hljs-built_in">int</span> MOD = <span class="hljs-number">1_000_000_007</span>;<br>    private static final <span class="hljs-built_in">int</span> MX = <span class="hljs-number">100_001</span>; // 根据题目数据范围修改<br><br>    private static final long[] F = new long[MX]; // F[i] = i!<br>    private static final long[] INV_F = new long[MX]; // INV_F[i] = i!^-<span class="hljs-number">1</span> = <span class="hljs-built_in">pow</span>(i!, MOD-<span class="hljs-number">2</span>)<br><br>    static &#123;<br>        F[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; MX; i++) &#123;<br>            F[i] = F[i - <span class="hljs-number">1</span>] * i % MOD;<br>        &#125;<br><br>        INV_F[MX - <span class="hljs-number">1</span>] = <span class="hljs-built_in">pow</span>(F[MX - <span class="hljs-number">1</span>], MOD - <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = MX - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            INV_F[i - <span class="hljs-number">1</span>] = INV_F[i] * i % MOD;<br>        &#125;<br>    &#125;<br><br>    private static long <span class="hljs-built_in">pow</span>(long x, <span class="hljs-built_in">int</span> n) &#123;<br>        long res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (; n &gt; <span class="hljs-number">0</span>; n /= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) &#123;<br>                res = res * x % MOD;<br>            &#125;<br>            x = x * x % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    // 从 n 个数中选 m 个数的方案数<br>    private long comb(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> m) &#123;<br>        <span class="hljs-keyword">return</span> m &lt; <span class="hljs-number">0</span> || m &gt; n ? <span class="hljs-number">0</span> : F[n] * INV_F[m] % MOD * INV_F[n - m] % MOD;<br>    &#125;<br><br>    public <span class="hljs-built_in">int</span> solve(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        // 预处理的逻辑写在 static 块中，这样只会初始化一次<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果模数不是质数呢？见 <a href="https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-ii/">3463. 判断操作后字符串中的数字是否相等 II</a>。</p><h2 id="取模练习"><a href="#取模练习" class="headerlink" title="取模练习"></a>取模练习</h2><ul><li><a href="https://leetcode.cn/problems/transformed-array/">3379. 转换数组</a> 做到</li><li><a href="https://leetcode.cn/problems/binary-prefix-divisible-by-5/">1018. 可被 5 整除的二进制前缀</a> 1376</li></ul><h2 id="快速幂练习"><a href="#快速幂练习" class="headerlink" title="快速幂练习"></a>快速幂练习</h2><ul><li><a href="https://leetcode.cn/problems/double-modular-exponentiation/">2961. 双模幂运算</a> 1451</li><li><a href="https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/">2550. 猴子碰撞的方法数</a> 1663</li><li><a href="https://leetcode.cn/problems/super-pow/">372. 超级次方</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DS</tag>
      
      <tag>模运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50AI note1</title>
    <link href="/2026/01/14/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50%20AI%20note%201/"/>
    <url>/2026/01/14/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50%20AI%20note%201/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Lecture-1"><a href="#Lecture-1" class="headerlink" title="Lecture 1"></a><a href="https://cs50.harvard.edu/ai/notes/1/#lecture-1">Lecture 1</a></h1><h1 id="Knowledge"><a href="#Knowledge" class="headerlink" title="Knowledge"></a><a href="https://cs50.harvard.edu/ai/notes/1/#knowledge">Knowledge</a></h1><p>人类会基于已有知识进行推理并得出结论。AI 中也同样会用“表示知识 + 从知识中推出结论”的概念。在这一讲中，我们将探索如何实现这种行为。</p><h2 id="知识型智能体（Knowledge-Based-Agents）"><a href="#知识型智能体（Knowledge-Based-Agents）" class="headerlink" title="知识型智能体（Knowledge-Based Agents）"></a>知识型智能体（Knowledge-Based Agents）</h2><p>这些智能体通过对内部的知识表示进行运算，从而完成推理。</p><p>那么，“基于知识推理并得出结论”到底是什么意思？</p><p>我们用一个《哈利·波特》的例子开始。考虑下面这些句子：</p><ol><li>如果今天没有下雨，Harry 今天去看了 Hagrid。</li><li>Harry 今天要么去看了 Hagrid，要么去看了 Dumbledore，但不能两个都去。</li><li>Harry 今天去看了 Dumbledore。</li></ol><p>根据这三句话，我们可以回答问题：“今天下雨了吗？”，尽管每一句都没有直接告诉我们今天是否下雨。推理过程如下：</p><p>观察句子 3，我们知道 Harry 去了 Dumbledore。<br>观察句子 2，我们知道 Harry 去了 Dumbledore 或 Hagrid（二者之一），因此我们可以推出：</p><ol><li>Harry 今天没有去看 Hagrid。</li></ol><p>再观察句子 1，我们知道：如果今天没有下雨，那么 Harry 会去看 Hagrid。<br>但根据句子 4，我们知道 Harry 并没有去看 Hagrid，因此可以推出：</p><ol><li>今天下雨了。</li></ol><p>为了得出这个结论，我们使用了<strong>逻辑（logic）</strong>。这一讲将探索 AI 如何利用逻辑从已有信息推出新的结论。</p><hr><h2 id="句子（Sentence）"><a href="#句子（Sentence）" class="headerlink" title="句子（Sentence）"></a>句子（Sentence）</h2><p>句子是对世界的断言，存在于某种知识表示语言中。句子是 AI 存储知识并据此推理新信息的方式。</p><hr><h1 id="Propositional-Logic"><a href="#Propositional-Logic" class="headerlink" title="Propositional Logic"></a><a href="https://cs50.harvard.edu/ai/notes/1/#propositional-logic">Propositional Logic</a></h1><p>命题逻辑基于命题（propositions）：对世界的陈述，它们要么为真，要么为假（就像上面的句子 1-5）。</p><h2 id="命题符号（Propositional-Symbols）"><a href="#命题符号（Propositional-Symbols）" class="headerlink" title="命题符号（Propositional Symbols）"></a>命题符号（Propositional Symbols）</h2><p>命题符号通常用字母（P, Q, R）表示，用来代表一个命题。</p><h2 id="逻辑连接词（Logical-Connectives）"><a href="#逻辑连接词（Logical-Connectives）" class="headerlink" title="逻辑连接词（Logical Connectives）"></a>逻辑连接词（Logical Connectives）</h2><p>逻辑连接词是逻辑符号，用来连接命题符号，从而更复杂地推理世界。</p><h3 id="否定（Not-¬）"><a href="#否定（Not-¬）" class="headerlink" title="否定（Not, ¬）"></a>否定（Not, ¬）</h3><p>否定会反转命题的真值。例如若 P：“正在下雨”，则 ¬P：“没有下雨”。</p><p>真值表（truth tables）用于枚举所有可能的真值赋值，从而比较不同连接词下命题的真值。下面是第一个真值表例子：</p><h3 id="与（And-∧）"><a href="#与（And-∧）" class="headerlink" title="与（And, ∧）"></a>与（And, ∧）</h3><p>当两个命题 P 和 Q 用 ∧ 连接时，P ∧ Q 仅在 P 和 Q 都为真时为真。</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P ∧ Q</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><h3 id="或（Or-∨）"><a href="#或（Or-∨）" class="headerlink" title="或（Or, ∨）"></a>或（Or, ∨）</h3><p>P ∨ Q 只要任一参数为真即为真。也就是说，P ∨ Q 为真要求 P 或 Q 至少一个为真。</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P ∨ Q</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>true</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><p>值得一提的是，“或”有两种：<strong>包含式或（inclusive Or）</strong>与<strong>排他式或（exclusive Or）</strong>。<br>在排他式或中，如果 P ∧ Q 为真，则 P ∨ Q 为假：也就是要求只能一个为真，不能都为真。<br>包含式或在 P、Q 或 P ∧ Q 为真时都为真。这里的 Or（∨）默认指<strong>包含式或</strong>。</p><blockquote><p>旁注（课堂没提到）：</p><ul><li>一个例子可帮助理解包含式 vs 排他式：<ul><li>包含式：为了吃甜点，你必须“打扫房间<strong>或</strong>割草”。如果两个都做了，也依然能吃到饼干。</li><li>排他式：甜点你可以吃“曲奇<strong>或</strong>冰淇淋”。这时不能两个都吃。</li></ul></li><li>排他式或常缩写为 XOR，常用符号 ⊕。</li></ul></blockquote><h3 id="蕴含（Implication-→）"><a href="#蕴含（Implication-→）" class="headerlink" title="蕴含（Implication, →）"></a>蕴含（Implication, →）</h3><p>蕴含表示“如果 P，那么 Q”。例如：</p><ul><li>P：“正在下雨”</li><li>Q：“我在室内”<br>则 P → Q 表示：“如果下雨，那么我在室内。”<br>其中 P 称为<strong>前件（antecedent）</strong>，Q 称为<strong>后件（consequent）</strong>。</li></ul><p>当<strong>前件为真</strong>时，整个蕴含在<strong>后件为真</strong>时为真（下雨且在室内，则“如果下雨我在室内”是真的）。<br>当<strong>前件为真</strong>时，如果<strong>后件为假</strong>，则蕴含为假（下雨却在室外，“如果下雨我在室内”为假）。<br>然而当<strong>前件为假</strong>时，不论后件如何，蕴含都为真。这可能令人困惑：逻辑上，若 P 为假，则从 P → Q 中无法推出关于 Q 的任何信息。<br>在例子中：如果没下雨，那么蕴含并没有说明我是否在室内；我可能一直在室内，也可能一直在室外。<br>因此当前件为假时，我们称蕴含为<strong>平凡真（trivially true）</strong>。</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P → Q</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>true</td></tr><tr><td>false</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><h3 id="双条件（Biconditional-↔）"><a href="#双条件（Biconditional-↔）" class="headerlink" title="双条件（Biconditional, ↔）"></a>双条件（Biconditional, ↔）</h3><p>双条件是双向的蕴含，可读作“当且仅当”。<br>P ↔ Q 等价于 (P → Q) 与 (Q → P) 同时成立。</p><p>例如：</p><ul><li>P：“正在下雨”</li><li>Q：“我在室内”<br>P ↔ Q 表示：“如果下雨则我在室内”并且“如果我在室内则下雨”。<br>这比单向蕴含能推出更多信息：如果 P 为假，那么 Q 也为假；如果没下雨，则我也不在室内。</li></ul><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P ↔ Q</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>true</td></tr><tr><td>false</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><hr><h2 id="模型（Model）"><a href="#模型（Model）" class="headerlink" title="模型（Model）"></a>模型（Model）</h2><p>模型是对每个命题都赋予真值的一种赋值方式。再次强调，命题是可以为真或假的世界陈述；世界知识体现在这些命题的真值上。模型就是这种真值赋值，它描述了一个可能的世界。</p><p>例如：</p><ul><li>P：“正在下雨”</li><li>Q：“今天是星期二”<br>一种模型可以是：{P = True, Q = False}<br>这表示：下雨，但不是星期二。</li></ul><p>当然还有其他可能模型，例如 {P=True, Q=True} 表示既下雨又是星期二。<br>一般来说，n 个命题会有 2^n 种可能模型。这里 n=2，所以 2²=4 种。</p><hr><h2 id="知识库（Knowledge-Base-KB）"><a href="#知识库（Knowledge-Base-KB）" class="headerlink" title="知识库（Knowledge Base, KB）"></a>知识库（Knowledge Base, KB）</h2><p>知识库是一组句子（sentences），它们是知识型智能体已知为真的知识集合。<br>AI 以命题逻辑句子的形式获得这些关于世界的信息，并利用它们进行额外推理。</p><hr><h2 id="蕴含（Entailment-⊨）"><a href="#蕴含（Entailment-⊨）" class="headerlink" title="蕴含（Entailment, ⊨）"></a>蕴含（Entailment, ⊨）</h2><p>若 α ⊨ β（α 蕴含 β），则在任何 α 为真的世界里，β 也为真。</p><p>例如：</p><ul><li>α：“一月的某个星期二”</li><li>β：“是一月”<br>则 α ⊨ β。若真的是“一月的星期二”，必然是在一月。</li></ul><p>蕴含不同于蕴含连接词（implication）。  </p><ul><li><strong>Implication（→）</strong>是逻辑连接词，把两个命题连成一个复合命题。  </li><li><strong>Entailment（⊨）</strong>是关系：当 α 中所有信息为真时，β 也必为真。</li></ul><hr><h1 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a><a href="https://cs50.harvard.edu/ai/notes/1/#inference">Inference</a></h1><p>推理（Inference）是从旧句子推导出新句子的过程。</p><p>例如，在前面的哈利波特例子中，句子 4 和 5 是由 1、2、3 推导出来的。</p><p>从已有知识中推出新知识有多种方法。首先我们考虑 <strong>模型检测（Model Checking）</strong>算法。</p><h2 id="模型检测（Model-Checking）"><a href="#模型检测（Model-Checking）" class="headerlink" title="模型检测（Model Checking）"></a>模型检测（Model Checking）</h2><p>为了判断 KB ⊨ α（即回答：“我们能否仅依据 KB 推出 α 为真？”）：</p><ul><li>枚举所有可能模型</li><li>若在所有使 KB 为真的模型中，α 也为真，则 KB 蕴含 α（KB ⊨ α）</li></ul><p>考虑例子：</p><ul><li>P：今天是星期二  </li><li>Q：正在下雨  </li><li>R：Harry 会去跑步  </li><li>KB：(P ∧ ¬Q) → R（即：P 且不 Q 蕴含 R）  </li><li>KB 还包含：P（P 为真）、¬Q（Q 为假）  </li><li>Query：R（我们想知道 KB 是否蕴含 R）</li></ul><p>枚举所有模型（3 个命题 → 2^3=8 行）：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>R</th><th>KB</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td><td></td></tr><tr><td>false</td><td>false</td><td>true</td><td></td></tr><tr><td>false</td><td>true</td><td>false</td><td></td></tr><tr><td>false</td><td>true</td><td>true</td><td></td></tr><tr><td>true</td><td>false</td><td>false</td><td></td></tr><tr><td>true</td><td>false</td><td>true</td><td></td></tr><tr><td>true</td><td>true</td><td>false</td><td></td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><p>逐步筛掉与 KB 不一致的模型：</p><p>1）KB 中包含 P 为真 → 所有 P 为 false 的行都让 KB 为 false：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>R</th><th>KB</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>false</td><td>true</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td><td></td></tr><tr><td>true</td><td>false</td><td>true</td><td></td></tr><tr><td>true</td><td>true</td><td>false</td><td></td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><p>2）KB 中包含 ¬Q → 所有 Q 为 true 的行都让 KB 为 false：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>R</th><th>KB</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>false</td><td>true</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td><td></td></tr><tr><td>true</td><td>false</td><td>true</td><td></td></tr><tr><td>true</td><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td><td>false</td></tr></tbody></table></div><p>3）只剩两行：P=true 且 Q=false。<br>由于 KB 有 (P ∧ ¬Q) → R，所以在 P=true 且 Q=false 时，R 必须为真。<br>因此 R=false 那一行 KB 为 false，而 R=true 那一行 KB 为 true：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>R</th><th>KB</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>false</td><td>true</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td><td>false</td></tr><tr><td>true</td><td>false</td><td>true</td><td>true</td></tr><tr><td>true</td><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td><td>false</td></tr></tbody></table></div><p>最终只有一个模型使 KB 为真，而在该模型里 R 也为真。<br>所以 KB ⊨ R。</p><hr><p>接下来我们看如何用代码表示知识与逻辑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> logic <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 为每个命题创建一个符号（Symbol）</span><br>rain = Symbol(<span class="hljs-string">&quot;rain&quot;</span>)              <span class="hljs-comment"># 正在下雨</span><br>hagrid = Symbol(<span class="hljs-string">&quot;hagrid&quot;</span>)          <span class="hljs-comment"># Harry 去看了 Hagrid</span><br>dumbledore = Symbol(<span class="hljs-string">&quot;dumbledore&quot;</span>)  <span class="hljs-comment"># Harry 去看了 Dumbledore</span><br><br><span class="hljs-comment"># 将句子保存进 KB（knowledge）</span><br>knowledge = And(<br>    Implication(Not(rain), hagrid),        <span class="hljs-comment"># ¬rain → hagrid</span><br>    Or(hagrid, dumbledore),                <span class="hljs-comment"># hagrid ∨ dumbledore</span><br>    Not(And(hagrid, dumbledore)),          <span class="hljs-comment"># ¬(hagrid ∧ dumbledore)</span><br>    dumbledore                             <span class="hljs-comment"># dumbledore 为真（事实）</span><br>)<br></code></pre></td></tr></table></figure><p>要运行模型检测算法，需要：</p><ul><li><p>Knowledge Base（知识库）</p></li><li><p>Query（查询命题）</p></li><li><p>Symbols（所有原子命题符号列表）</p></li><li><p>Model（对符号的真值赋值）</p></li></ul><p>模型检测算法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_all</span>(<span class="hljs-params">knowledge, query, symbols, model</span>):<br><br>    <span class="hljs-comment"># 如果 model 已经对每个 symbol 赋值</span><br>    <span class="hljs-comment"># （这里的逻辑可能有点绕：symbols 初始是符号列表。函数递归，每次弹出一个 symbol 并据此生成模型。</span><br>    <span class="hljs-comment"># 当 symbols 为空，表示所有符号都已被赋值，因此我们完成了所有可能模型的生成。）</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> symbols:<br><br>        <span class="hljs-comment"># 如果 KB 在该 model 下为真，则 query 必须也为真</span><br>        <span class="hljs-keyword">if</span> knowledge.evaluate(model):<br>            <span class="hljs-keyword">return</span> query.evaluate(model)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br><br>        <span class="hljs-comment"># 选择一个尚未使用的符号</span><br>        remaining = symbols.copy()<br>        p = remaining.pop()<br><br>        <span class="hljs-comment"># 创建 p 为真的 model</span><br>        model_true = model.copy()<br>        model_true[p] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 创建 p 为假的 model</span><br>        model_false = model.copy()<br>        model_false[p] = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 在两种 model 下都必须成立（保证蕴含）</span><br>        <span class="hljs-keyword">return</span> (<br>            check_all(knowledge, query, remaining, model_true)<br>            <span class="hljs-keyword">and</span> check_all(knowledge, query, remaining, model_false)<br>        )<br></code></pre></td></tr></table></figure><p>注意：我们只关心 KB 为真的模型。若 KB 为假，则意味着这些模型不符合我们已知事实，因此对推理无关。</p><blockquote><p>课堂外例子：<br>令 P：Harry 是找球手（seeker），Q：Oliver 是守门员（keeper），R：Gryffindor 赢。<br>KB 指定：P、Q、(P ∧ Q) → R。<br>如果某个模型中 ¬P（Harry 不是找球手），那么我们不关心 R 是否为真，因为 KB 已经告诉我们 P 为真。<br>我们只关心与 KB 一致的模型。</p></blockquote><p>此外，<code>check_all</code> 是递归的：每次选一个符号，生成两个模型（真/假），继续递归，直到符号列表为空。<br>一旦为空（<code>if not symbols</code>），函数会检查 KB 是否在该模型下为真；若为真，则再检查 query 是否为真。</p><hr><h1 id="Knowledge-Engineering"><a href="#Knowledge-Engineering" class="headerlink" title="Knowledge Engineering"></a><a href="https://cs50.harvard.edu/ai/notes/1/#knowledge-engineering">Knowledge Engineering</a></h1><p>知识工程（Knowledge Engineering）是思考“如何用命题与逻辑表示现实问题”的过程。</p><p>我们用 Clue（妙探寻凶/Cluedo）游戏练习知识工程：</p><p>谋杀由 <strong>人物</strong>、<strong>工具</strong>、<strong>地点</strong> 三类中的各一个组成。每类随机抽一张放入信封，其余发给玩家。玩家通过不断获得线索推断信封里是什么。<br>在模型中，我们将与谋杀有关的项标为 True，否则标为 False。</p><p>假设：</p><ul><li><p>人物：Mustard, Plum, Scarlet</p></li><li><p>工具：knife, revolver, wrench</p></li><li><p>地点：ballroom, kitchen, library</p></li></ul><p>先加入游戏规则：每类至少一个为真：</p><ul><li><p>(Mustard ∨ Plum ∨ Scarlet)</p></li><li><p>(knife ∨ revolver ∨ wrench)</p></li><li><p>(ballroom ∨ kitchen ∨ library)</p></li></ul><p>游戏开始时，你看到一张人物、一张工具、一张地点，确定它们不在信封。<br>假设你拿到 Mustard、kitchen、revolver，则加入：</p><ul><li><p>¬Mustard</p></li><li><p>¬kitchen</p></li><li><p>¬revolver</p></li></ul><p>在游戏中，你可以提出猜测：某人物 + 某工具 + 某地点。<br>假设猜测 “Scarlet 用 wrench 在 library”，如果这个猜测是错的，则至少有一个不成立：</p><ul><li>(¬Scarlet ∨ ¬library ∨ ¬wrench)</li></ul><p>再假设有人给你看了 Plum 卡，则加入：</p><ul><li>¬Plum</li></ul><p>此时可推出凶手是 Scarlet，因为凶手必须在 Mustard/Plum/Scarlet 中，而前两者都已排除。</p><p>再加入一个知识：地点不是 ballroom：</p><ul><li>¬ballroom</li></ul><p>现在就能推出：Scarlet 在 library 用 knife 作案。<br>library 的推理：地点必须在 ballroom/kitchen/library 中，而 ballroom、kitchen 都被排除。<br>工具的推理：猜测 “Scarlet, library, wrench” 为假，且 Scarlet、library 已为真，因此 wrench 必为假；<br>工具必须在 knife/revolver/wrench 中且 revolver、wrench 都为假，因此 knife 为真。</p><p>将这些信息写入 Python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge = And(<br>    <span class="hljs-comment"># 游戏条件：每类至少一个为真</span><br>    Or(mustard, plum, scarlet),<br>    Or(ballroom, kitchen, library),<br>    Or(knife, revolver, wrench),<br><br>    <span class="hljs-comment"># 起手三张牌（不在信封）</span><br>    Not(mustard),<br>    Not(kitchen),<br>    Not(revolver),<br><br>    <span class="hljs-comment"># 有人猜 Scarlet + library + wrench，但猜错了</span><br>    Or(Not(scarlet), Not(library), Not(wrench)),<br><br>    <span class="hljs-comment"># 后续看到的牌与线索</span><br>    Not(plum),<br>    Not(ballroom)<br>)<br></code></pre></td></tr></table></figure><p>也可以看其他逻辑谜题。<br>例如：四个人（Gilderoy, Pomona, Minerva, Horace）要分配到四个学院（Gryffindor, Hufflepuff, Ravenclaw, Slytherin），每个学院恰好一个人。<br>用命题逻辑表示会非常繁琐：每一种“人-学院”的组合都要一个命题，如 MinervaGryffindor、MinervaHufflepuff 等。<br>还要表示“每个人至少属于一个学院”，需要写一个 Or 列出所有学院；<br>再表示“若属于某学院，则不属于其他学院”，需要写大量蕴含式。<br>这种低效在“一阶逻辑”部分会给出解决思路，但命题逻辑也能解，只是很啰嗦。</p><p>另一类可用命题逻辑解决的是 Mastermind（猜颜色位置）游戏。<br>玩家一设定颜色顺序，玩家二不断猜；每次反馈“有多少个颜色位置正确”。<br>例如四种颜色：</p><p>第一猜：<br><img src="https://cs50.harvard.edu/ai/notes/1/mastermind1.png" alt="Mastermind1"></p><p>反馈 “two”：两个位置正确，两个位置错误。<br>接着交换其中两个颜色位置再猜：</p><p><img src="https://cs50.harvard.edu/ai/notes/1/mastermind2.png" alt="Mastermind2"></p><p>反馈 “zero”：说明刚才交换的两个其实原来就在正确位置，因此未动的两个原来位置是错的。<br>再交换剩下两个：</p><p><img src="https://cs50.harvard.edu/ai/notes/1/mastermind3.png" alt="Mastermind3"></p><p>反馈 “four”：结束。</p><p>用命题逻辑表示需要 (颜色数)² 个原子命题：如 red0、red1… 表示颜色与位置。<br>接着要表示规则（每个位置只有一种颜色、颜色不重复）并加入 KB；<br>最后加入线索（第一猜两个对、第二猜零对），用模型检测就能求解。</p><hr><h1 id="Inference-Rules"><a href="#Inference-Rules" class="headerlink" title="Inference Rules"></a><a href="https://cs50.harvard.edu/ai/notes/1/#inference-rules">Inference Rules</a></h1><p>模型检测效率不高，因为要枚举所有模型。<br>推理规则（Inference Rules）允许我们不枚举所有模型就推出新知识。</p><p>推理规则通常画成一条横线：上面是前提（premise），下面是结论（conclusion）。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/modusponensexample.png" alt="Modus Ponens Example"></p><p>例子前提：</p><ul><li><p>如果下雨，则 Harry 在室内</p></li><li><p>下雨</p></li></ul><p>结论：</p><ul><li>Harry 在室内</li></ul><h2 id="Modus-Ponens（肯定前件）"><a href="#Modus-Ponens（肯定前件）" class="headerlink" title="Modus Ponens（肯定前件）"></a>Modus Ponens（肯定前件）</h2><p>如果知道 P → Q 且 P 为真，则 Q 为真。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/modusponens.png" alt="Modus Ponens"></p><h2 id="And-Elimination（合取消去）"><a href="#And-Elimination（合取消去）" class="headerlink" title="And Elimination（合取消去）"></a>And Elimination（合取消去）</h2><p>若 P ∧ Q 为真，则 P 为真（或 Q 为真）。<br>例如知道 Harry 同时是 Ron 和 Hermione 的朋友，则可推出 Harry 是 Hermione 的朋友。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/andelimination.png" alt="And Elimination"></p><h2 id="Double-Negation-Elimination（双重否定消去）"><a href="#Double-Negation-Elimination（双重否定消去）" class="headerlink" title="Double Negation Elimination（双重否定消去）"></a>Double Negation Elimination（双重否定消去）</h2><p>¬¬P 等价于 P。<br>例如 “并非（Harry 没通过考试）” → Harry 通过了考试。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/doublenegationelimination.png" alt="Double Negation Elimination"></p><h2 id="Implication-Elimination（蕴含消去）"><a href="#Implication-Elimination（蕴含消去）" class="headerlink" title="Implication Elimination（蕴含消去）"></a>Implication Elimination（蕴含消去）</h2><p>P → Q 等价于 ¬P ∨ Q。<br>例如 “如果下雨，Harry 在室内” 等价于 “不下雨 或 Harry 在室内”。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/implicationelimination.png" alt="Implication Elimination"></p><p>这可能有点绕。看真值表可知二者等价：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P → Q</th><th>¬P ∨ Q</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>true</td><td>true</td></tr><tr><td>false</td><td>true</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><h2 id="Biconditional-Elimination（双条件消去）"><a href="#Biconditional-Elimination（双条件消去）" class="headerlink" title="Biconditional Elimination（双条件消去）"></a>Biconditional Elimination（双条件消去）</h2><p>P ↔ Q 等价于 (P → Q) ∧ (Q → P)。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/biconditionalelimination.png" alt="Biconditional Elimination"></p><h2 id="De-Morgan’s-Law（德摩根定律）"><a href="#De-Morgan’s-Law（德摩根定律）" class="headerlink" title="De Morgan’s Law（德摩根定律）"></a>De Morgan’s Law（德摩根定律）</h2><p>把 And 与 Or 在否定下互换：</p><p>¬(P ∧ Q) ≡ ¬P ∨ ¬Q<br>¬(P ∨ Q) ≡ ¬P ∧ ¬Q</p><p><img src="https://cs50.harvard.edu/ai/notes/1/demorgans1.png" alt="De Morgan&#39;s 1"><br><img src="https://cs50.harvard.edu/ai/notes/1/demorgans2.png" alt="De Morgan&#39;s 2"></p><h2 id="Distributive-Property（分配律）"><a href="#Distributive-Property（分配律）" class="headerlink" title="Distributive Property（分配律）"></a>Distributive Property（分配律）</h2><p>将 And/Or 分配展开：</p><p><img src="https://cs50.harvard.edu/ai/notes/1/distributive1.png" alt="Distributive 1"><br><img src="https://cs50.harvard.edu/ai/notes/1/distributive2.png" alt="Distributive 2"></p><hr><h2 id="知识与搜索问题（Knowledge-and-Search-Problems）"><a href="#知识与搜索问题（Knowledge-and-Search-Problems）" class="headerlink" title="知识与搜索问题（Knowledge and Search Problems）"></a>知识与搜索问题（Knowledge and Search Problems）</h2><p>推理可以被视为一个搜索问题：</p><ul><li><p>初始状态：起始知识库</p></li><li><p>动作：推理规则</p></li><li><p>状态转移：应用推理规则后的新知识库</p></li><li><p>目标测试：想证明的语句是否已在 KB 中</p></li><li><p>路径代价：证明步数</p></li></ul><p>这说明搜索算法的普适性：推理也能视为“在证明空间里搜索”。</p><hr><h1 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a><a href="https://cs50.harvard.edu/ai/notes/1/#resolution">Resolution</a></h1><p>归结（Resolution）是一条强大的推理规则：若在一个 Or 子句中，一个文字为假，则另一个必须为真。</p><p>例如：</p><ul><li><p>Ron 在大厅 ∨ Hermione 在图书馆</p></li><li><p>¬(Ron 在大厅)<br>  则可推出：</p></li><li><p>Hermione 在图书馆</p></li></ul><p>形式化：</p><p><img src="https://cs50.harvard.edu/ai/notes/1/resolution1.png" alt="Resolution"></p><p>归结依赖<strong>互补文字（Complementary Literals）</strong>：同一个命题的正负形式，如 P 与 ¬P。</p><p>归结可推广：若还有</p><ul><li>¬(Ron 在大厅) ∨ Harry 在睡觉</li></ul><p>可归结出：</p><ul><li>Hermione 在图书馆 ∨ Harry 在睡觉</li></ul><p><img src="https://cs50.harvard.edu/ai/notes/1/resolution2.png" alt="Resolution"></p><hr><h2 id="子句（Clause）与-CNF（合取范式）"><a href="#子句（Clause）与-CNF（合取范式）" class="headerlink" title="子句（Clause）与 CNF（合取范式）"></a>子句（Clause）与 CNF（合取范式）</h2><ul><li><p><strong>文字（literal）</strong>：命题符号或其否定（P 或 ¬P）</p></li><li><p><strong>子句（clause）</strong>：文字的析取（Or），如 (P ∨ Q ∨ ¬R)</p></li><li><p><strong>CNF（Conjunctive Normal Form）</strong>：多个子句的合取（And），如：<br>  (A ∨ B ∨ C) ∧ (D ∨ ¬E) ∧ (F ∨ G)</p></li></ul><hr><h2 id="将命题转换为-CNF-的步骤"><a href="#将命题转换为-CNF-的步骤" class="headerlink" title="将命题转换为 CNF 的步骤"></a>将命题转换为 CNF 的步骤</h2><ol><li><p>消除双条件<br> (α ↔ β) → (α → β) ∧ (β → α)</p></li><li><p>消除蕴含<br> (α → β) → (¬α ∨ β)</p></li><li><p>将否定向内推进到只否定文字（用德摩根）<br> ¬(α ∧ β) → ¬α ∨ ¬β</p></li></ol><p>示例：把 (P ∨ Q) → R 转成 CNF：</p><ul><li><p>(P ∨ Q) → R</p></li><li><p>¬(P ∨ Q) ∨ R（消除蕴含）</p></li><li><p>(¬P ∧ ¬Q) ∨ R（德摩根）</p></li><li><p>(¬P ∨ R) ∧ (¬Q ∨ R)（分配律）</p></li></ul><hr><h2 id="因式分解（Factoring）与空子句"><a href="#因式分解（Factoring）与空子句" class="headerlink" title="因式分解（Factoring）与空子句"></a>因式分解（Factoring）与空子句</h2><p>归结过程中可能出现同一个文字重复，如推导出 (Q ∨ R ∨ S ∨ S)。<br><strong>Factoring</strong> 会去掉重复的 S，得到 (Q ∨ R ∨ S)。</p><p>当归结 P 与 ¬P 时，会得到<strong>空子句</strong> ()。空子句恒为假，表示矛盾（不可能同时 P 与 ¬P 为真）。</p><hr><h2 id="用归结判断蕴含（反证法）"><a href="#用归结判断蕴含（反证法）" class="headerlink" title="用归结判断蕴含（反证法）"></a>用归结判断蕴含（反证法）</h2><p>判断 KB ⊨ α：</p><ul><li><p>检查 (KB ∧ ¬α) 是否矛盾</p><ul><li><p>若矛盾，则 KB ⊨ α</p></li><li><p>否则不蕴含</p></li></ul></li></ul><p>更技术化的算法：</p><ol><li><p>将 (KB ∧ ¬α) 转为 CNF</p></li><li><p>不断用归结产生新子句</p></li><li><p>若产生空子句 ()，则得到矛盾，证明 KB ⊨ α</p></li><li><p>若无法得到矛盾且也无法产生新子句，则不蕴含</p></li></ol><p>示例：</p><p>要判断 (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) 是否蕴含 A？</p><ul><li><p>反证：假设 ¬A</p></li><li><p>得到 (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) ∧ (¬A)</p></li><li><p>由 ¬C，可知 (¬B ∨ C) 要为真只能 ¬B</p></li><li><p>有了 ¬B，(A ∨ B) 要为真只能 A</p></li><li><p>现在有 A 与 ¬A，归结得到空子句 () → 矛盾 → 蕴含成立</p></li></ul><hr><h1 id="First-Order-Logic"><a href="#First-Order-Logic" class="headerlink" title="First Order Logic"></a><a href="https://cs50.harvard.edu/ai/notes/1/#first-order-logic">First Order Logic</a></h1><p>一阶逻辑能比命题逻辑更简洁地表达复杂信息。</p><p>一阶逻辑包含两类符号：</p><ul><li><p><strong>常量符号（Constant Symbols）</strong>：表示对象（如人物、学院）</p></li><li><p><strong>谓词符号（Predicate Symbols）</strong>：像关系/函数，输入参数并返回真假</p></li></ul><p>例如：</p><ul><li><p>Person(Minerva)：Minerva 是人</p></li><li><p>House(Gryffindor)：Gryffindor 是学院</p></li><li><p>¬House(Minerva)：Minerva 不是学院</p></li><li><p>BelongsTo(Minerva, Gryffindor)：Minerva 属于 Gryffindor</p></li></ul><p>一阶逻辑能让“每个人一个符号、每个学院一个符号”，比命题逻辑为每个“人-学院组合”都建一个命题更简洁。</p><hr><h2 id="全称量化（Universal-Quantification-∀）"><a href="#全称量化（Universal-Quantification-∀）" class="headerlink" title="全称量化（Universal Quantification, ∀）"></a>全称量化（Universal Quantification, ∀）</h2><p>量化可以表示“不指明具体常量”的句子。<br>全称量化 ∀ 表示“对所有”。</p><p>例如：</p><p>∀x. BelongsTo(x, Gryffindor) → ¬BelongsTo(x, Hufflepuff)</p><p>表示：对任何 x，如果 x 属于 Gryffindor，则 x 不属于 Hufflepuff。</p><hr><h2 id="存在量化（Existential-Quantification-∃）"><a href="#存在量化（Existential-Quantification-∃）" class="headerlink" title="存在量化（Existential Quantification, ∃）"></a>存在量化（Existential Quantification, ∃）</h2><p>存在量化 ∃ 表示“至少存在一个”。</p><p>例如：</p><p>∃x. House(x) ∧ BelongsTo(Minerva, x)</p><p>表示：存在至少一个对象 x，它既是学院，且 Minerva 属于 x。<br>也就是：Minerva 属于某个学院。</p><hr><h2 id="同时使用-∀-与-∃"><a href="#同时使用-∀-与-∃" class="headerlink" title="同时使用 ∀ 与 ∃"></a>同时使用 ∀ 与 ∃</h2><p>例如：</p><p>∀x. Person(x) → (∃y. House(y) ∧ BelongsTo(x, y))</p><p>表示：对所有 x，如果 x 是人，则存在至少一个学院 y，使得 x 属于 y。<br>也就是说：每个人都属于某个学院。</p><hr>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>讲义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分思想不只能查找</title>
    <link href="/2026/01/03/Leetcode/%E4%BA%8C%E5%88%86/"/>
    <url>/2026/01/03/Leetcode/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="1-四种需求通用转换公式"><a href="#1-四种需求通用转换公式" class="headerlink" title="1. 四种需求通用转换公式"></a>1. 四种需求通用转换公式</h3><p>无论使用开区间还是闭区间写法，核心逻辑都是通过 <code>lowerBound</code> 来实现的。以下公式适用于所有情况：</p><div class="table-container"><table><thead><tr><th style="text-align:left">你的需求</th><th style="text-align:left">转化为 <code>lowerBound</code></th><th style="text-align:left">结果下标处理</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><strong>找 $\ge x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x)</code></td><td style="text-align:left">无</td><td style="text-align:left">标准定义</td></tr><tr><td style="text-align:left"><strong>找 $&gt; x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1)</code></td><td style="text-align:left">无</td><td style="text-align:left">整数性质：$&gt;x \Leftrightarrow \ge x+1$</td></tr><tr><td style="text-align:left"><strong>找 $&lt; x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x)</code></td><td style="text-align:left"><code>- 1</code></td><td style="text-align:left">$\ge x$ 的左边就是 $&lt; x$</td></tr><tr><td style="text-align:left"><strong>找 $\le x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1)</code></td><td style="text-align:left"><code>- 1</code></td><td style="text-align:left">$&gt; x$ 的左边就是 $\le x$</td></tr></tbody></table></div><hr><h3 id="2-开区间写法-Open-Interval"><a href="#2-开区间写法-Open-Interval" class="headerlink" title="2. 开区间写法 (Open Interval)"></a>2. 开区间写法 (Open Interval)</h3><p><strong>特点</strong>：逻辑最统一，无需考虑 <code>+1/-1</code> 细节，不易死循环。<br><strong>区间定义</strong>：<code>(-1, n)</code>。<code>left</code> 始终指向红色（不满足），<code>right</code> 始终指向蓝色（满足）。</p><h4 id="2-1-Java-开区间"><a href="#2-1-Java-开区间" class="headerlink" title="2.1 Java (开区间)"></a>2.1 Java (开区间)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 初始化：开区间 (left, right)</span><br>    <span class="hljs-comment">// left = -1 代表红色区域（&lt; target）</span><br>    <span class="hljs-comment">// right = n 代表蓝色区域（&gt;= target）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, right = nums.length;<br>    <br>    <span class="hljs-comment">// 循环不变量：left + 1 &lt; right (区间不为空)</span><br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// 核心判断：mid 在哪边？</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid; <span class="hljs-comment">// mid 满足条件(蓝色)，可能是答案，向左收缩</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// mid 不满足条件(红色)，答案在右边，向右收缩</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 循环结束时 left + 1 == right</span><br>    <span class="hljs-comment">// right 指向第一个满足 &gt;= target 的位置</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-C语言-开区间"><a href="#2-2-C语言-开区间" class="headerlink" title="2.2 C语言 (开区间)"></a>2.2 C语言 (开区间)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = numsSize;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid; <span class="hljs-comment">// 蓝色区域，更新右边界</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// 红色区域，更新左边界</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 返回蓝色区域的起点</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-闭区间写法-Closed-Interval-——-教科书经典"><a href="#3-闭区间写法-Closed-Interval-——-教科书经典" class="headerlink" title="3. 闭区间写法 (Closed Interval) —— 教科书经典"></a>3. 闭区间写法 (Closed Interval) —— 教科书经典</h3><p><strong>特点</strong>：最常见，面试中常用。<br><strong>区间定义</strong>：<code>[0, n-1]</code>。每次更新必须排除 <code>mid</code>。</p><h4 id="3-1-Java-闭区间"><a href="#3-1-Java-闭区间" class="headerlink" title="3.1 Java (闭区间)"></a>3.1 Java (闭区间)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 循环结束条件：left &gt; right</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 尝试查找更小的下标</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 必须查找更大的下标</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// left 指向第一个 &gt;= target 的位置</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-C语言-闭区间"><a href="#3-2-C语言-闭区间" class="headerlink" title="3.2 C语言 (闭区间)"></a>3.2 C语言 (闭区间)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = numsSize - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li><strong>开区间</strong>：初始化 <code>(-1, n)</code>，更新 <code>left=mid</code> / <code>right=mid</code>，返回 <code>right</code>。记忆口诀：<strong>check 成功更新谁，最后就返回谁</strong>（针对 <code>lowerBound</code> 求最小，check 成功更新 right，故返回 right）。</li><li><strong>闭区间</strong>：初始化 <code>[0, n-1]</code>，更新 <code>mid+1</code> / <code>mid-1</code>，返回 <code>left</code>。</li></ul><h3 id="5-找不到时的返回值"><a href="#5-找不到时的返回值" class="headerlink" title="5. 找不到时的返回值"></a>5. 找不到时的返回值</h3><p>无论是<strong>开区间</strong>还是<strong>闭区间</strong>，标准的 <code>lowerBound</code>（寻找第一个 $\ge target$ 的下标）算法在“找不到”时的表现是<strong>一致的</strong>：</p><ol><li><strong>如果数组中所有数都小于 <code>target</code></strong>（即目标值太大，越界）：返回 <strong>数组长度 <code>n</code></strong>。</li><li><strong>如果数组中所有数都大于等于 <code>target</code></strong>（即目标值比谁都小）：返回 <strong><code>0</code></strong>。</li><li><strong>如果目标值在数组范围内但不存在</strong>：返回它<strong>按顺序应该插入的位置</strong>（即第一个大于它的数的下标）。</li></ol><hr><h4 id="5-1-详细对比与解释"><a href="#5-1-详细对比与解释" class="headerlink" title="5.1 详细对比与解释"></a>5.1 详细对比与解释</h4><h5 id="5-1-1-开区间写法-Open-Interval"><a href="#5-1-1-开区间写法-Open-Interval" class="headerlink" title="5.1.1 开区间写法 (Open Interval)"></a>5.1.1 开区间写法 (Open Interval)</h5><ul><li><strong>初始化</strong>：<code>left = -1</code>, <code>right = n</code>。</li><li><strong>循环结束</strong>：<code>left + 1 == right</code>。</li><li><strong>返回值</strong>：<strong><code>right</code></strong>。</li><li><strong>“找不到”的情况</strong>：<ul><li><strong>Target 太大</strong>（所有数都 <code>&lt; target</code>）：<code>check(mid)</code> 永远为 <code>False</code>，<code>right</code> 从未被更新，始终保持初始值 <strong><code>n</code></strong>。</li><li><strong>Target 太小</strong>（所有数都 <code>≥ target</code>）：<code>check(mid)</code> 永远为 <code>True</code>，<code>right</code> 不断向左收缩，最终变为 <strong><code>0</code></strong>（此时 <code>left</code> 仍为 <code>-1</code>）。</li></ul></li></ul><h5 id="5-1-2-闭区间写法-Closed-Interval"><a href="#5-1-2-闭区间写法-Closed-Interval" class="headerlink" title="5.1.2 闭区间写法 (Closed Interval)"></a>5.1.2 闭区间写法 (Closed Interval)</h5><ul><li><strong>初始化</strong>：<code>left = 0</code>, <code>right = n - 1</code>。</li><li><strong>循环结束</strong>：<code>left &gt; right</code>。</li><li><strong>返回值</strong>：<strong><code>left</code></strong>。</li><li><strong>“找不到”的情况</strong>：<ul><li><strong>Target 太大</strong>：<code>nums[mid] &lt; target</code> 始终成立，<code>left</code> 不断右移（<code>mid + 1</code>），直到最后一次循环时 <code>left</code> 变为 <strong><code>n</code></strong>，循环结束。</li><li><strong>Target 太小</strong>：<code>nums[mid] &gt;= target</code> 始终成立，<code>right</code> 不断左移，<code>left</code> 保持初始值 <strong><code>0</code></strong> 不动。</li></ul></li></ul><hr><h4 id="5-2-特殊变种的“找不到”返回值"><a href="#5-2-特殊变种的“找不到”返回值" class="headerlink" title="5.2 特殊变种的“找不到”返回值"></a>5.2 特殊变种的“找不到”返回值</h4><p>根据资料，基于 <code>lowerBound</code> 衍生出的其他三种查找需求，其“找不到”的返回值如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">查找需求</th><th style="text-align:left">转化公式</th><th style="text-align:left"><strong>找不到时的返回值</strong></th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>$\ge x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x)</code></td><td style="text-align:left"><strong><code>n</code></strong></td><td style="text-align:left">所有数都 $&lt; x$</td></tr><tr><td style="text-align:left"><strong>$&gt; x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1)</code></td><td style="text-align:left"><strong><code>n</code></strong></td><td style="text-align:left">所有数都 $\le x$</td></tr><tr><td style="text-align:left"><strong>$&lt; x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x) - 1</code></td><td style="text-align:left"><strong><code>-1</code></strong></td><td style="text-align:left">所有数都 $\ge x$ (即 <code>lowerBound</code> 返回 0)</td></tr><tr><td style="text-align:left"><strong>$\le x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1) - 1</code></td><td style="text-align:left"><strong><code>-1</code></strong></td><td style="text-align:left">所有数都 $&gt; x$ (即 <code>lowerBound</code> 返回 0)</td></tr></tbody></table></div><h4 id="5-3-如何判断“精确查找（Equal）”失败？"><a href="#5-3-如何判断“精确查找（Equal）”失败？" class="headerlink" title="5.3 如何判断“精确查找（Equal）”失败？"></a>5.3 如何判断“精确查找（Equal）”失败？</h4><p>如果你需要的是“找到返回下标，<strong>找不到返回 -1</strong>”的逻辑（即标准的 <code>indexOf</code>），无论使用开区间还是闭区间，都需要在拿到返回值后增加一步判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设 idx 是 lowerBound 的返回值 (无论开闭区间)</span><br>idx = lower_bound(nums, target)<br><br><span class="hljs-comment"># 必须同时满足两个条件才算“找到了”：</span><br><span class="hljs-comment"># 1. idx 不越界 (idx &lt; n)</span><br><span class="hljs-comment"># 2. 该位置的值确实等于 target</span><br><span class="hljs-keyword">if</span> idx &lt; <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">and</span> nums[idx] == target:<br>    <span class="hljs-keyword">return</span> idx<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># 真正的“找不到”</span><br></code></pre></td></tr></table></figure><h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><h3 id="1-核心概念与思维模型"><a href="#1-核心概念与思维模型" class="headerlink" title="1. 核心概念与思维模型"></a>1. 核心概念与思维模型</h3><ul><li><strong>基本定义</strong>：“花费一个 $\log$ 的时间，增加了一个条件”。我们将求解最优解（求最小/最大）的问题，转化为在一个<strong>虚拟的有序数组</strong> <code>[check(min), ..., check(max)]</code> 中寻找分界点的问题。</li><li><strong>红蓝染色法</strong>：与数组二分一样，我们将解空间分为两部分：<ul><li><strong>红色</strong>：不满足题目要求的区域。</li><li><strong>蓝色</strong>：满足题目要求的区域。</li><li><strong>目标</strong>：寻找红蓝分界线。</li></ul></li></ul><hr><h3 id="2-两大核心类型"><a href="#2-两大核心类型" class="headerlink" title="2. 两大核心类型"></a>2. 两大核心类型</h3><p>根据题目要求寻找的是“最小值”还是“最大值”，解题模型分为两类。资料强烈推荐使用<strong>开区间</strong>写法，因为它逻辑最统一。</p><h4 id="2-1-类型一：求最小-Find-Minimum"><a href="#2-1-类型一：求最小-Find-Minimum" class="headerlink" title="2.1 类型一：求最小 (Find Minimum)"></a>2.1 类型一：求最小 (Find Minimum)</h4><ul><li><strong>适用场景</strong>：<ul><li>求满足条件的<strong>最小值</strong>（如：完成任务的最少时间、最小花费）。</li><li><strong>最小化最大值</strong>（如：分割数组的最大值最小是多少）。</li><li><strong>第 K 小</strong>（转化为：求最小的 $x$，使得 $\le x$ 的数至少有 $k$ 个）。</li></ul></li><li><strong>染色模型</strong>：左边 <code>False</code>（红色），<strong>右边 <code>True</code>（蓝色）</strong>。</li><li><strong>核心逻辑</strong>：我们要找<strong>蓝色区域的起点</strong>。</li><li><strong>开区间口诀</strong>：<code>check</code> 成功更新 <code>right</code>，最后返回 <code>right</code>。</li></ul><h4 id="2-2-类型二：求最大-Find-Maximum"><a href="#2-2-类型二：求最大-Find-Maximum" class="headerlink" title="2.2 类型二：求最大 (Find Maximum)"></a>2.2 类型二：求最大 (Find Maximum)</h4><ul><li><strong>适用场景</strong>：<ul><li>求满足条件的<strong>最大值</strong>（如：最大收益、H指数）。</li><li><strong>最大化最小值</strong>（如：两球之间的最大磁力、让所有人分到的最小值最大）。</li></ul></li><li><strong>染色模型</strong>：<strong>左边 <code>True</code>（蓝色）</strong>，右边 <code>False</code>（红色）。</li><li><strong>核心逻辑</strong>：我们要找<strong>蓝色区域的终点</strong>。</li><li><strong>开区间口诀</strong>：<code>check</code> 成功更新 <code>left</code>，最后返回 <code>left</code>。</li></ul><hr><h3 id="3-四种常见应用模式"><a href="#3-四种常见应用模式" class="headerlink" title="3. 四种常见应用模式"></a>3. 四种常见应用模式</h3><div class="table-container"><table><thead><tr><th style="text-align:left">模式名称</th><th style="text-align:left">本质归属</th><th style="text-align:left">典型题目描述</th><th style="text-align:left">核心 Check 思路</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基础最值</strong></td><td style="text-align:left">求最小/最大</td><td style="text-align:left">x 秒能否完成？</td><td style="text-align:left">模拟过程，判断是否可行</td></tr><tr><td style="text-align:left"><strong>最小化最大值</strong></td><td style="text-align:left"><strong>求最小</strong></td><td style="text-align:left">限制最大负荷，求这个负荷的最小值</td><td style="text-align:left">设阈值为 <code>mid</code>，用贪心判断能否将所有组的数值都压在 <code>mid</code> 以下</td></tr><tr><td style="text-align:left"><strong>最大化最小值</strong></td><td style="text-align:left"><strong>求最大</strong></td><td style="text-align:left">保证每人至少分到 x，求 x 的最大值</td><td style="text-align:left">设下界为 <code>mid</code>，用贪心判断能否选出足够多的元素满足间距/大小 $\ge mid$</td></tr><tr><td style="text-align:left"><strong>第 K 小/大</strong></td><td style="text-align:left"><strong>求最小</strong>/最大</td><td style="text-align:left">乘法表第 K 小、第 K 小数对距离</td><td style="text-align:left">设答案为 <code>x</code>，计算 $\le x$ 的元素个数是否 $\ge k$</td></tr></tbody></table></div><hr><h3 id="4-代码模板（开区间）"><a href="#4-代码模板（开区间）" class="headerlink" title="4. 代码模板（开区间）"></a>4. 代码模板（开区间）</h3><p><strong>开区间二分法</strong>因其逻辑统一（“check更新谁，最后就返回谁”）被强烈推荐。</p><h4 id="4-1-求最小-Find-Minimum-Lower-Bound"><a href="#4-1-求最小-Find-Minimum-Lower-Bound" class="headerlink" title="4.1 求最小 (Find Minimum) / Lower Bound"></a>4.1 求最小 (Find Minimum) / Lower Bound</h4><p><strong>适用场景</strong>：</p><ul><li>求满足条件的<strong>最小值</strong>（如：完成任务的最少时间）。</li><li><strong>最小化最大值</strong>。</li><li><strong>第 K 小</strong>。</li><li>红蓝染色：<strong>左红（False）右蓝（True）</strong>，目标是寻找蓝色区域的起点。</li></ul><p><strong>核心口诀</strong>：<code>check(mid)</code> 成功时更新 <code>right</code>，最后返回 <code>right</code>。</p><h5 id="4-1-1-Java-代码"><a href="#4-1-1-Java-代码" class="headerlink" title="4.1.1 Java 代码"></a>4.1.1 Java 代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 模板：计算满足 check(x) == true 的最小整数 x</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1. 定义解空间范围 (根据题目具体要求设定)</span><br>        <span class="hljs-comment">// left 指向红色区域(不满足)，right 指向蓝色区域(满足)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length; <span class="hljs-comment">// 或者根据题目范围，如 max(nums) 等</span><br>        <br>        <span class="hljs-comment">// 2. 循环不变量：left + 1 &lt; right</span><br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <br>            <span class="hljs-comment">// 3. 核心判定</span><br>            <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>                right = mid; <span class="hljs-comment">// 满足条件，尝试更小的（收缩右边界）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid;  <span class="hljs-comment">// 不满足，需要更大的（收缩左边界）</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 4. 返回 right (最小的满足值)</span><br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-comment">// 具体的判断逻辑</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-1-2-C语言-代码"><a href="#4-1-2-C语言-代码" class="headerlink" title="4.1.2 C语言 代码"></a>4.1.2 C语言 代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-comment">// 具体的判断逻辑</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 模板：计算满足 check(x) == true 的最小整数 x</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMin</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-comment">// 1. 定义解空间 (开区间)</span><br>    <span class="hljs-comment">// left 始终不满足，right 始终满足</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = numsSize; <br>    <br>    <span class="hljs-comment">// 2. 循环不变量</span><br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>            right = mid; <span class="hljs-comment">// 满足条件，记录并在左侧继续找</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// 不满足，去右侧找</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 返回 right</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-2-求最大-Find-Maximum"><a href="#4-2-求最大-Find-Maximum" class="headerlink" title="4.2 求最大 (Find Maximum)"></a>4.2 求最大 (Find Maximum)</h4><p><strong>适用场景</strong>：</p><ul><li>求满足条件的<strong>最大值</strong>（如：最大化收益）。</li><li><strong>最大化最小值</strong>（如：磁力球最大距离）。</li><li>红蓝染色：<strong>左蓝（True）右红（False）</strong>，目标是寻找蓝色区域的终点。</li></ul><p><strong>核心口诀</strong>：<code>check(mid)</code> 成功时更新 <code>left</code>，最后返回 <code>left</code>。</p><h5 id="4-2-1-Java-代码"><a href="#4-2-1-Java-代码" class="headerlink" title="4.2.1 Java 代码"></a>4.2.1 Java 代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 模板：计算满足 check(x) == true 的最大整数 x</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1. 定义解空间 (根据题目范围设定)</span><br>        <span class="hljs-comment">// left 指向蓝色区域(满足)，right 指向红色区域(不满足)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length; <br>        <br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <br>            <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>                left = mid;  <span class="hljs-comment">// 满足条件，尝试更大的（收缩左边界）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid; <span class="hljs-comment">// 不满足，需要更小的（收缩右边界）</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 4. 返回 left (最大的满足值)</span><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-2-C语言-代码"><a href="#4-2-2-C语言-代码" class="headerlink" title="4.2.2 C语言 代码"></a>4.2.2 C语言 代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 模板：计算满足 check(x) == true 的最大整数 x</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMax</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-comment">// 1. 定义解空间</span><br>    <span class="hljs-comment">// left 始终满足，right 始终不满足</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = numsSize;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>            left = mid;  <span class="hljs-comment">// 满足条件，记录答案并在右侧继续找更大值</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid; <span class="hljs-comment">// 不满足，去左侧找</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 返回 left</span><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h4><p>根据资料推荐的<strong>开区间</strong>写法：</p><ul><li><strong>求最小</strong>：<code>right</code> 维护满足条件的值，<code>check</code> 成功更新 <code>right</code>，返回 <code>right</code>。</li><li><strong>求最大</strong>：<code>left</code> 维护满足条件的值，<code>check</code> 成功更新 <code>left</code>，返回 <code>left</code>。</li></ul><h3 id="5-最小化最大值-Minimize-the-Maximum"><a href="#5-最小化最大值-Minimize-the-Maximum" class="headerlink" title="5. 最小化最大值 (Minimize the Maximum)"></a>5. 最小化最大值 (Minimize the Maximum)</h3><p>这类问题通常描述为：“在满足某种分组或分配限制下，让某个最大指标（如最大负荷、最大距离、最大花费）尽可能小”。</p><ul><li><strong>本质归属</strong>：<strong>二分答案求最小</strong>（Find Minimum）。</li><li><strong>思维模型</strong>：<strong>“压盖子”</strong>。<ul><li>二分的 <code>mid</code> 是一个<strong>上界</strong>（Upper Bound）。</li><li>我们试图用这个盖子去“压”住所有元素，看能否在限制条件（如分组成 $k$ 份）下把所有数值都压在 <code>mid</code> 之下。</li></ul></li><li><strong>Check 函数逻辑</strong>：<ul><li>通常使用 <strong>贪心 + 模拟</strong>。</li><li>判断：<strong>“如果最大值不能超过 <code>mid</code>，我最少需要多少组/多少时间？”</strong></li><li>如果需要的组数 $\le k$，说明 <code>mid</code> 给的预算太宽裕或者刚好，尝试<strong>更小</strong>的（收缩右边界 <code>right = mid</code>）。</li><li>如果需要的组数 $&gt; k$，说明 <code>mid</code> 太严苛了，压不住，必须<strong>更大</strong>（收缩左边界 <code>left = mid</code>）。</li></ul></li><li><strong>典型题目</strong>：分割数组的最大值、完成任务的最少时间、爱吃香蕉的珂珂。</li><li><strong>代码行为 (开区间)</strong>：<ul><li><code>check(mid)</code> 成功（True）时更新 <code>right = mid</code>。</li><li>最终返回 <strong><code>right</code></strong>。</li></ul></li></ul><hr><h3 id="6-最大化最小值-Maximize-the-Minimum"><a href="#6-最大化最小值-Maximize-the-Minimum" class="headerlink" title="6. 最大化最小值 (Maximize the Minimum)"></a>6. 最大化最小值 (Maximize the Minimum)</h3><p>这类问题通常描述为：“在选取 $k$ 个元素或进行某种分配时，让其中最小的指标（如最小间距、最小得分）尽可能大”。</p><ul><li><strong>本质归属</strong>：<strong>二分答案求最大</strong>（Find Maximum）。</li><li><strong>思维模型</strong>：<strong>“抬地板”</strong>。<ul><li>二分的 <code>mid</code> 是一个<strong>下界</strong>（Lower Bound）。</li><li>我们试图把标准“抬”高，看能否找到足够多的元素/方案，使得它们都<strong>至少</strong>达到 <code>mid</code> 的水平。</li></ul></li><li><strong>Check 函数逻辑</strong>：<ul><li>通常使用 <strong>贪心</strong>。</li><li>判断：<strong>“如果要求所有选中的元素都 $\ge mid$，我最多能选出多少个？”</strong></li><li>如果选出的个数 $\ge k$，说明 <code>mid</code> 这个标准是可行的，尝试<strong>更大</strong>的（收缩左边界 <code>left = mid</code>）。</li><li>如果选出的个数 $&lt; k$，说明 <code>mid</code> 定太高了，凑不齐，必须<strong>更小</strong>（收缩右边界 <code>right = mid</code>）。</li></ul></li><li><strong>典型题目</strong>：两球之间的磁力、木头切割、H指数。</li><li><strong>代码行为 (开区间)</strong>：<ul><li><code>check(mid)</code> 成功（True）时更新 <code>left = mid</code>。</li><li>最终返回 <strong><code>left</code></strong>。</li></ul></li></ul><hr><h3 id="7-对比总结表"><a href="#7-对比总结表" class="headerlink" title="7. 对比总结表"></a>7. 对比总结表</h3><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left"><strong>最小化最大值</strong> (Min-Max)</th><th style="text-align:left"><strong>最大化最小值</strong> (Max-Min)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>问题类型</strong></td><td style="text-align:left"><strong>求最小</strong> (Find Minimum)</td><td style="text-align:left"><strong>求最大</strong> (Find Maximum)</td></tr><tr><td style="text-align:left"><strong>物理含义</strong></td><td style="text-align:left">限制上限，越小越好</td><td style="text-align:left">保证下限，越大越好</td></tr><tr><td style="text-align:left"><strong>Check方向</strong></td><td style="text-align:left">$\le mid$ 是否可行？</td><td style="text-align:left">$\ge mid$ 是否可行？</td></tr><tr><td style="text-align:left"><strong>更新逻辑</strong></td><td style="text-align:left">Check成功 $\to$ <code>right = mid</code> (试更小)</td><td style="text-align:left">Check成功 $\to$ <code>left = mid</code> (试更大)</td></tr><tr><td style="text-align:left"><strong>开区间返回</strong></td><td style="text-align:left"><strong><code>right</code></strong></td><td style="text-align:left"><strong><code>left</code></strong></td></tr><tr><td style="text-align:left"><strong>闭区间返回</strong></td><td style="text-align:left"><strong><code>left</code></strong></td><td style="text-align:left"><strong><code>right</code></strong></td></tr></tbody></table></div><h3 id="8-代码模板建议-开区间"><a href="#8-代码模板建议-开区间" class="headerlink" title="8. 代码模板建议 (开区间)"></a>8. 代码模板建议 (开区间)</h3><p>根据资料推荐，使用<strong>开区间</strong>写法可以避免复杂的边界判断。</p><p><strong>最小化最大值（求最小）：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心：Check成功更新 right，返回 right</span><br><span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (check(mid)) right = mid; <span class="hljs-comment">// 满足条件，试探更小的</span><br>    <span class="hljs-keyword">else</span> left = mid;<br>&#125;<br><span class="hljs-keyword">return</span> right;<br></code></pre></td></tr></table></figure></p><p><strong>最大化最小值（求最大）：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心：Check成功更新 left，返回 left</span><br><span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (check(mid)) left = mid;  <span class="hljs-comment">// 满足条件，试探更大的</span><br>    <span class="hljs-keyword">else</span> right = mid;<br>&#125;<br><span class="hljs-keyword">return</span> left;<br></code></pre></td></tr></table></figure></p><p><strong>记忆口诀</strong>：</p><ul><li>求最小（压盖子）：返回右边的 <code>right</code>。</li><li>求最大（抬地板）：返回左边的 <code>left</code>。</li></ul><h3 id="9-第-K-小-大"><a href="#9-第-K-小-大" class="headerlink" title="9. 第 K 小/大"></a>9. 第 K 小/大</h3><h4 id="9-1-核心转换逻辑"><a href="#9-1-核心转换逻辑" class="headerlink" title="9.1 核心转换逻辑"></a>9.1 核心转换逻辑</h4><h5 id="9-1-1-第-K-小-Kth-Smallest"><a href="#9-1-1-第-K-小-Kth-Smallest" class="headerlink" title="9.1.1 第 K 小 (Kth Smallest)"></a>9.1.1 第 K 小 (Kth Smallest)</h5><ul><li><strong>定义</strong>：在一个（可能虚拟的）有序序列中，第 K 小的数是 $x$。</li><li><strong>转化公式</strong>：等价于求 <strong>最小</strong> 的 $x$，满足 <strong>$\le x$ 的数至少有 $k$ 个</strong>。</li><li><strong>归属类型</strong>：<strong>求最小</strong>（Find Minimum）。</li><li><strong>单调性</strong>：$x$ 越大，$\le x$ 的数的个数越多（单调递增）。我们要找的是刚刚达到 $k$ 个的那个临界点。</li></ul><h5 id="9-1-2-第-K-大-Kth-Largest"><a href="#9-1-2-第-K-大-Kth-Largest" class="headerlink" title="9.1.2 第 K 大 (Kth Largest)"></a>9.1.2 第 K 大 (Kth Largest)</h5><ul><li><strong>定义</strong>：第 K 大的数是 $x$。</li><li><strong>转化公式</strong>：等价于求 <strong>最大</strong> 的 $x$，满足 <strong>$\ge x$ 的数至少有 $k$ 个</strong>。</li><li><strong>归属类型</strong>：<strong>求最大</strong>（Find Maximum）。</li><li><strong>实际技巧</strong>：虽然可以直接按“求最大”做，但工程和竞赛中常将其转换为 <strong>第 $N - K + 1$ 小</strong> 的问题，从而统一使用“求最小”的模板。</li></ul><hr><h4 id="9-2-代码模板（开区间写法）"><a href="#9-2-代码模板（开区间写法）" class="headerlink" title="9.2 代码模板（开区间写法）"></a>9.2 代码模板（开区间写法）</h4><h5 id="9-2-1-第-K-小模板（推荐）"><a href="#9-2-1-第-K-小模板（推荐）" class="headerlink" title="9.2.1 第 K 小模板（推荐）"></a>9.2.1 第 K 小模板（推荐）</h5><p>这是最常用的形式。例如：乘法表中第 K 小的数、第 K 小的数对距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标：求最小的 x，使得 count(&lt;= x) &gt;= k</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minVal, <span class="hljs-type">int</span> maxVal)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> minVal - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxVal + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// Check逻辑：计算 &lt;= mid 的元素个数是否达到了 k</span><br>        <span class="hljs-keyword">if</span> (countLessOrEqual(mid) &gt;= k) &#123;<br>            right = mid; <span class="hljs-comment">// 够了，甚至多了 -&gt; 尝试更小的（收缩右边界）</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// 不够 -&gt; 必须更大（收缩左边界）</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// Check成功更新的是 right，故返回 right</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9-2-2-第-K-大模板（直接法）"><a href="#9-2-2-第-K-大模板（直接法）" class="headerlink" title="9.2.2 第 K 大模板（直接法）"></a>9.2.2 第 K 大模板（直接法）</h5><p>如果不进行转换，直接求第 K 大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标：求最大的 x，使得 count(&gt;= x) &gt;= k</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minVal, <span class="hljs-type">int</span> maxVal)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> minVal - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxVal + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// Check逻辑：计算 &gt;= mid 的元素个数是否达到了 k</span><br>        <span class="hljs-keyword">if</span> (countGreaterOrEqual(mid) &gt;= k) &#123;<br>            left = mid;  <span class="hljs-comment">// 够了 -&gt; 尝试更大的（收缩左边界）</span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            right = mid; <span class="hljs-comment">// 不够 -&gt; 必须更小（收缩右边界）</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// Check成功更新的是 left，故返回 left</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h3><p><strong>“第 K 小”本质上是二分答案求最小</strong>。<br>只需记住：我们二分一个数值 <code>mid</code>，计算“小于等于 <code>mid</code> 的数有多少个”。</p><ul><li>如果个数 $\ge k$，说明 <code>mid</code> 可能是答案，甚至答案比 <code>mid</code> 还小（<strong>Right = mid</strong>）。</li><li>如果个数 $&lt; k$，说明 <code>mid</code> 太小了，不够排到第 $k$ 位（<strong>Left = mid</strong>）。</li><li>最后返回 <strong>Right</strong>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DS</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java怎么实现Stirng不变的</title>
    <link href="/2026/01/03/JavaSE/Java%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81String%E4%B8%8D%E5%8F%98%E7%9A%84/"/>
    <url>/2026/01/03/JavaSE/Java%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81String%E4%B8%8D%E5%8F%98%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>这是一个<strong>问到 Java 设计“核心骨架”的问题</strong>。<br>我先给你一句<strong>结论级答案</strong>，然后我们像拆发动机一样，把每一层都拆开。</p><blockquote><p><strong><code>String</code> 的不可变性不是靠一句 <code>final</code>，<br>而是靠一整套“多层封锁 + JVM 协同”的设计体系共同保证的。</strong></p></blockquote><p>下面我们分 <strong>5 道防线</strong> 来看。</p><hr><h2 id="第一层防线：String-类本身是-final"><a href="#第一层防线：String-类本身是-final" class="headerlink" title="第一层防线：String 类本身是 final"></a>第一层防线：<code>String</code> 类本身是 <code>final</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="这意味着什么？"><a href="#这意味着什么？" class="headerlink" title="这意味着什么？"></a>这意味着什么？</h3><ul><li>❌ 不能被继承</li><li>❌ 不能通过子类添加“破坏性方法”</li><li>❌ 不能 override 任何行为</li></ul><h3 id="为什么这是第一道防线？"><a href="#为什么这是第一道防线？" class="headerlink" title="为什么这是第一道防线？"></a>为什么这是第一道防线？</h3><p>假如 <code>String</code> <strong>可以被继承</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilString</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 改内部 char[]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么：</p><ul><li>JVM</li><li>HashMap</li><li>ClassLoader</li><li>安全管理器</li></ul><p>都会被<strong>彻底破坏</strong></p><p>📌 <strong>第一层作用</strong>：<br>👉 <strong>防止通过继承破坏不可变性</strong></p><hr><h2 id="第二层防线：内部状态是-private-final"><a href="#第二层防线：内部状态是-private-final" class="headerlink" title="第二层防线：内部状态是 private final"></a>第二层防线：内部状态是 <code>private final</code></h2><h3 id="早期-JDK（≤8）："><a href="#早期-JDK（≤8）：" class="headerlink" title="早期 JDK（≤8）："></a>早期 JDK（≤8）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] value;<br></code></pre></td></tr></table></figure><h3 id="JDK-9-（压缩字符串）："><a href="#JDK-9-（压缩字符串）：" class="headerlink" title="JDK 9+（压缩字符串）："></a>JDK 9+（压缩字符串）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] value;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> coder; <span class="hljs-comment">// LATIN1 / UTF16</span><br></code></pre></td></tr></table></figure><h3 id="这两点非常关键："><a href="#这两点非常关键：" class="headerlink" title="这两点非常关键："></a>这两点非常关键：</h3><ol><li><p><strong><code>final</code></strong></p><ul><li>引用不能被替换</li></ul></li><li><p><strong><code>private</code></strong></p><ul><li>外界完全无法访问</li></ul></li></ol><p>📌 注意：<br><code>final</code> 只保证“引用不变”，<br><strong>真正防修改的是 <code>private</code> + 不暴露引用</strong>。</p><hr><h2 id="第三层防线：没有任何“修改自身”的方法"><a href="#第三层防线：没有任何“修改自身”的方法" class="headerlink" title="第三层防线：没有任何“修改自身”的方法"></a>第三层防线：没有任何“修改自身”的方法</h2><p>你仔细想一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="String-提供的方法是什么？"><a href="#String-提供的方法是什么？" class="headerlink" title="String 提供的方法是什么？"></a>String 提供的方法是什么？</h3><ul><li><code>substring</code></li><li><code>replace</code></li><li><code>toUpperCase</code></li><li><code>concat</code></li></ul><p><strong>它们全部：</strong></p><blockquote><p>❌ 不修改原对象<br>✅ 返回一个新 <code>String</code></p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">s.toUpperCase();<br></code></pre></td></tr></table></figure><p>实际等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(...);<br></code></pre></td></tr></table></figure><p>📌 <strong>这是不可变设计的“行为层保证”</strong>。</p><hr><h2 id="第四层防线：构造阶段的“防御性拷贝”"><a href="#第四层防线：构造阶段的“防御性拷贝”" class="headerlink" title="第四层防线：构造阶段的“防御性拷贝”"></a>第四层防线：构造阶段的“防御性拷贝”</h2><h3 id="你以为这样能破坏-String？"><a href="#你以为这样能破坏-String？" class="headerlink" title="你以为这样能破坏 String？"></a>你以为这样能破坏 String？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] arr = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr);<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;<br>System.out.println(s);<br></code></pre></td></tr></table></figure><h3 id="实际输出："><a href="#实际输出：" class="headerlink" title="实际输出："></a>实际输出：</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abc</span><br></code></pre></td></tr></table></figure><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>因为 <code>String</code> 构造器里做了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.value = Arrays.copyOf(arr, arr.length);<br></code></pre></td></tr></table></figure><p>📌 <strong>String 永远不信任外部传入的数据</strong></p><blockquote><p>这是“不可变类”的黄金法则之一。</p></blockquote><hr><h2 id="第五层防线（终极）：JVM-amp-语言层级的“特权协作”"><a href="#第五层防线（终极）：JVM-amp-语言层级的“特权协作”" class="headerlink" title="第五层防线（终极）：JVM &amp; 语言层级的“特权协作”"></a>第五层防线（终极）：JVM &amp; 语言层级的“特权协作”</h2><p>这是很多人<strong>不知道但最关键的一层</strong>。</p><hr><h3 id="1️⃣-字符串常量池（String-Pool）"><a href="#1️⃣-字符串常量池（String-Pool）" class="headerlink" title="1️⃣ 字符串常量池（String Pool）"></a>1️⃣ 字符串常量池（String Pool）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>a</code> 和 <code>b</code> 指向 <strong>同一个对象</strong></li><li><p>如果 String 可变：</p><ul><li>改一个，全世界跟着改</li></ul></li></ul><p>👉 所以 <strong>String 必须不可变</strong></p><hr><h3 id="2️⃣-hashCode-缓存"><a href="#2️⃣-hashCode-缓存" class="headerlink" title="2️⃣ hashCode 缓存"></a>2️⃣ <code>hashCode</code> 缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash;<br></code></pre></td></tr></table></figure><ul><li><code>hashCode()</code> 只算一次</li><li>之后直接缓存</li></ul><p>如果 String 可变：</p><ul><li>hash 失效</li><li>HashMap 直接崩溃</li></ul><hr><h3 id="3️⃣-ClassLoader-安全模型依赖-String"><a href="#3️⃣-ClassLoader-安全模型依赖-String" class="headerlink" title="3️⃣ ClassLoader / 安全模型依赖 String"></a>3️⃣ ClassLoader / 安全模型依赖 String</h3><ul><li>类名</li><li>方法名</li><li>权限名</li><li>文件路径</li></ul><p>📌 <strong>如果 String 可变，Java 的安全模型不成立</strong></p><hr><h2 id="一句话拆穿所有误解（非常重要）"><a href="#一句话拆穿所有误解（非常重要）" class="headerlink" title="一句话拆穿所有误解（非常重要）"></a>一句话拆穿所有误解（非常重要）</h2><blockquote><p><strong>String 的不可变性不是“防你”，<br>而是“防整个 Java 世界被你不小心炸掉”。</strong></p></blockquote><hr><h2 id="用一个“完整类比”帮你彻底定型"><a href="#用一个“完整类比”帮你彻底定型" class="headerlink" title="用一个“完整类比”帮你彻底定型"></a>用一个“完整类比”帮你彻底定型</h2><p>把 <code>String</code> 想成：</p><blockquote><p><strong>法律里的“身份证号码”</strong></p></blockquote><ul><li>不能改</li><li>可以复制</li><li>可以传递</li><li>可以比较</li><li>但绝不允许“修改原值”</li></ul><p>而：</p><ul><li><code>StringBuilder</code> = 草稿纸</li><li><code>char[]</code> = 可随意涂改的纸</li></ul><hr><h2 id="最容易被忽略的一点（高手标志）"><a href="#最容易被忽略的一点（高手标志）" class="headerlink" title="最容易被忽略的一点（高手标志）"></a>最容易被忽略的一点（高手标志）</h2><h3 id="为什么-String-的-value-数组不是暴露的？"><a href="#为什么-String-的-value-数组不是暴露的？" class="headerlink" title="为什么 String 的 value 数组不是暴露的？"></a>为什么 <code>String</code> 的 <code>value</code> 数组不是暴露的？</h3><p>如果有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] getValue();<br></code></pre></td></tr></table></figure><p>哪怕是 <code>final</code>，<strong>整个设计立刻崩塌</strong>。</p><p>📌 所以不可变性的真正核心是：</p><blockquote><p><strong>不暴露任何可变内部状态的引用</strong></p></blockquote><hr><h2 id="终极总结（请记住）"><a href="#终极总结（请记住）" class="headerlink" title="终极总结（请记住）"></a>终极总结（请记住）</h2><p><code>String</code> 的不可变性 =</p><ol><li>类是 <code>final</code></li><li>内部状态 <code>private final</code></li><li>不提供修改自身的方法</li><li>构造期防御性拷贝</li><li>JVM / 常量池 / hash / 安全模型共同依赖</li></ol><blockquote><p><strong>它是 Java 中“不可变设计”的教科书级范例。</strong></p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50 AI project0 Tic-Tac-Toe</title>
    <link href="/2026/01/01/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50X%20project0%20TicTacToc/"/>
    <url>/2026/01/01/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50X%20project0%20TicTacToc/</url>
    
    <content type="html"><![CDATA[<h1 id="项目-0-Tic-Tac-Toe-井字棋"><a href="#项目-0-Tic-Tac-Toe-井字棋" class="headerlink" title="项目 0: Tic-Tac-Toe (井字棋)"></a>项目 0: Tic-Tac-Toe (井字棋)</h1><p>使用 Minimax 算法实现一个能够以最优策略玩井字棋的 AI。</p><p><img src="https://cs50.harvard.edu/ai/projects/0/tictactoe/images/game.png" alt="Tic-Tac-Toe 游戏界面"></p><h2 id="截止时间"><a href="#截止时间" class="headerlink" title="[截止时间]"></a>[截止时间]</h2><p><a href="https://time.cs50.io/20260630T235900Z">2026 年 7 月 1 日，星期三，北京时间 07:59</a></p><h2 id="如何寻求帮助"><a href="#如何寻求帮助" class="headerlink" title="[如何寻求帮助]"></a>[如何寻求帮助]</h2><ol><li>通过 <a href="https://cs50.edx.org/ed">Ed</a> 平台提问。</li><li>在 CS50 的任何<a href="https://cs50.harvard.edu/ai/communities/">社区</a>中交流。</li></ol><hr><h2 id="入门指南"><a href="#入门指南" class="headerlink" title="[入门指南]"></a>[入门指南]</h2><ul><li>从 <a href="https://cdn.cs50.net/ai/2023/x/projects/0/tictactoe.zip">此处</a> 下载分发代码并解压。</li><li>进入项目目录后，运行以下命令安装所需的 Python 库（<code>pygame</code>）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install -r requirements.txt<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="项目理解"><a href="#项目理解" class="headerlink" title="[项目理解]"></a>[项目理解]</h2><p>该项目有两个主要文件：<code>runner.py</code> 和 <code>tictactoe.py</code>。</p><ul><li><code>runner.py</code>：已由课程方实现，包含运行图形化界面所需的所有代码。</li><li><code>tictactoe.py</code>：包含游戏的所有逻辑以及 AI 做出最优决策的逻辑。完成该文件中的所有函数后，运行 <code>python runner.py</code> 即可与你的 AI 对弈。</li></ul><h3 id="初始数据"><a href="#初始数据" class="headerlink" title="初始数据"></a>初始数据</h3><p>在 <code>tictactoe.py</code> 中，我们定义了三个变量：<code>X</code>、<code>O</code> 和 <code>EMPTY</code> 来表示棋盘上的状态。棋盘被表示为一个包含三个列表的列表（即 3x3 矩阵）。</p><hr><h2 id="任务要求-Specification"><a href="#任务要求-Specification" class="headerlink" title="[任务要求 (Specification)]"></a>[任务要求 (Specification)]</h2><p>你需要完成 <code>player</code>、<code>actions</code>、<code>result</code> <code>winner</code>、<code>terminal</code>、<code>utility</code> 和 <code>minimax</code> 函数的实现。</p><ul><li><strong><code>player(board)</code></strong>：返回当前轮到哪位玩家（<code>X</code> 或 <code>O</code>）。<ul><li>初始状态下由 <code>X</code> 先手。</li></ul></li><li><strong><code>actions(board)</code></strong>：返回当前棋盘上所有可能的动作。<ul><li>动作应表示为元组 <code>(i, j)</code>，其中 <code>i</code> 是行，<code>j</code> 是列（范围均在 0-2 之间）。</li></ul></li><li><strong><code>result(board, action)</code></strong>：返回一个新棋盘状态，而不修改原棋盘。<ul><li>如果动作无效，应 <a href="https://docs.python.org/3/tutorial/errors.html#raising-exceptions">抛出异常</a>。</li><li><strong>重要</strong>：Minimax 需要考虑许多不同的状态，因此必须在不改变原始数据的情况下生成新棋盘。建议使用 <code>copy.deepcopy()</code>。</li></ul></li><li><strong><code>winner(board)</code></strong>：如果有赢家，返回 <code>X</code> 或 <code>O</code>；否则返回 <code>None</code>。<ul><li>获胜条件：在水平、垂直或对角线上连成三子。</li></ul></li><li><strong><code>terminal(board)</code></strong>：返回布尔值，判断游戏是否结束（有人获胜或棋盘填满）。</li><li><strong><code>utility(board)</code></strong>：返回终端棋盘的效用值。<ul><li><code>X</code> 获胜返回 <code>1</code>；<code>O</code> 获胜返回 <code>-1</code>；平局返回 <code>0</code>。</li></ul></li><li><strong><code>minimax(board)</code></strong>：返回当前玩家的最优动作 <code>(i, j)</code>。<ul><li>如果棋盘已结束，返回 <code>None</code>。</li></ul></li></ul><hr><h2 id="提示-Hints"><a href="#提示-Hints" class="headerlink" title="[提示 (Hints)]"></a>[提示 (Hints)]</h2><ul><li>如果你想在不同的文件中测试函数，可以使用 <code>from tictactoe import initial_state</code>。</li><li>你可以添加辅助函数，只要不与现有变量名冲突。</li><li><strong>Alpha-beta 剪枝</strong>（Alpha-beta pruning）是可选的，但它会让你的 AI 运行效率大幅提高！</li></ul><hr><h2 id="测试与提交"><a href="#测试与提交" class="headerlink" title="[测试与提交]"></a>[测试与提交]</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>使用 <code>check50</code> 检查正确性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">check50 ai50/projects/2024/x/tictactoe<br></code></pre></td></tr></table></figure></p><p>使用 <code>style50</code> 检查代码风格。</p><h3 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h3><ol><li>在 <a href="https://submit.cs50.io/invites/d03c31aef1984c29b5e7b268c3a87b7b">submit.cs50.io</a> 授权并加入课程。</li><li>使用 <code>submit50</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">submit50 ai50/projects/2024/x/tictactoe<br></code></pre></td></tr></table></figure></li></ol><hr><p><strong>注意</strong>：由于井字棋在双方均采取最优策略时必然会平局，因此当你完成代码后，你应该<strong>永远无法战胜</strong>你的 AI（但如果你失误了，它会打败你）。</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><strong>状态表示与追踪</strong>：<ul><li>利用 <code>player</code> 函数动态计算棋盘上 <code>X</code> 和 <code>O</code> 的数量差，从而确定当前回合。由于 X 先手且每次只能下一子，只需判断 <code>count(X) == count(O)</code> 即可确定轮到 X。</li></ul></li><li><strong>对抗搜索 (Minimax)</strong>：<ul><li><strong>递归回溯</strong>：通过 <code>max_value</code> 和 <code>min_value</code> 互相调用，模拟出所有可能的对弈分支。</li><li><strong>效用分配</strong>：游戏结束时，胜利、失败和平局分别被量化为 <code>1</code>, <code>-1</code>, <code>0</code>。X 作为 Max 玩家追求分值最大化，O 作为 Min 玩家追求分值最小化。</li></ul></li><li><strong>性能优化 (Alpha-Beta Pruning)</strong>：<ul><li>引入 <code>alpha</code>（Max 玩家保证能得到的最小值）和 <code>beta</code>（Min 玩家保证能允许的最大值）。</li><li>当 <code>v &gt;= beta</code> 或 <code>v &lt;= alpha</code> 时即刻停止搜索该分支，因为理性的对手绝不会允许局面进入这些分支，从而大幅减少计算量。</li></ul></li></ul><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Tic Tac Toe Player</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> math<br><br>X = <span class="hljs-string">&quot;X&quot;</span><br>O = <span class="hljs-string">&quot;O&quot;</span><br>EMPTY = <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">initial_state</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns starting state of the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> [[EMPTY, EMPTY, EMPTY],<br>            [EMPTY, EMPTY, EMPTY],<br>            [EMPTY, EMPTY, EMPTY]]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">player</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns player who has the next turn on a board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 计算当前棋盘上 X 和 O 的数量，决定下一位行动的玩家。</span><br>    <span class="hljs-comment"># 规则：若 X 和 O 的数量相等，则 X 先行；否则为 O。</span><br>    x_count = <span class="hljs-number">0</span><br>    o_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> board:<br>        <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row:<br>            <span class="hljs-keyword">if</span> cell == X:<br>                x_count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> cell == O:<br>                o_count += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 若 X 的数量不多于 O，说明轮到 X；否则轮到 O</span><br>    <span class="hljs-keyword">if</span> x_count &lt;= o_count:<br>        <span class="hljs-keyword">return</span> X<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> O<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">actions</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns set of all possible actions (i, j) available on the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 返回一个包含所有空位置的集合，集合元素为 (行, 列) 二元组。</span><br>    possible = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>            <span class="hljs-keyword">if</span> board[i][j] == EMPTY:<br>                possible.add((i, j))<br>    <span class="hljs-keyword">return</span> possible<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">result</span>(<span class="hljs-params">board, action</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the board that results from making move (i, j) on the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 返回一个新的棋盘（不修改原 board），表示在 action 位置下当前玩家的一步。</span><br>    <span class="hljs-comment"># 验证 action 格式并检查目标格是否为空。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-built_in">isinstance</span>(action, <span class="hljs-built_in">tuple</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(action) == <span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Action must be a tuple (i, j)&quot;</span>)<br><br>    i, j = action<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span> &lt;= i &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= j &lt; <span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Action indices out of bounds&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> board[i][j] != EMPTY:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Action must be on an empty cell&quot;</span>)<br><br>    <span class="hljs-comment"># 深拷贝棋盘以避免修改原对象</span><br>    new_board = [row.copy() <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> board]<br><br>    <span class="hljs-comment"># 将当前玩家的符号放到指定位置</span><br>    new_board[i][j] = player(board)<br>    <span class="hljs-keyword">return</span> new_board<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">winner</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the winner of the game, if there is one.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 检查行三连</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">if</span> board[i][<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[i][<span class="hljs-number">0</span>] == board[i][<span class="hljs-number">1</span>] == board[i][<span class="hljs-number">2</span>]:<br>            <span class="hljs-keyword">return</span> board[i][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 检查列三连</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][j] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[<span class="hljs-number">0</span>][j] == board[<span class="hljs-number">1</span>][j] == board[<span class="hljs-number">2</span>][j]:<br>            <span class="hljs-keyword">return</span> board[<span class="hljs-number">0</span>][j]<br><br>    <span class="hljs-comment"># 检查主对角线</span><br>    <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]:<br>        <span class="hljs-keyword">return</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 检查副对角线</span><br>    <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] == board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == board[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]:<br>        <span class="hljs-keyword">return</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]<br><br>    <span class="hljs-comment"># 若无胜者则返回 None</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">terminal</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns True if game is over, False otherwise.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 游戏结束的两种情况：存在胜者，或棋盘已满（无 EMPTY）。</span><br>    <span class="hljs-keyword">if</span> winner(board) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-comment"># 检查是否还有空位</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> board:<br>        <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row:<br>            <span class="hljs-keyword">if</span> cell == EMPTY:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 无空位且无胜者 -&gt; 平局，也视为游戏结束</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">utility</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns 1 if X has won the game, -1 if O has won, 0 otherwise.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用 winner() 判断胜者并返回对应效用值</span><br>    win = winner(board)<br>    <span class="hljs-keyword">if</span> win == X:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> win == O:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minimax</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the optimal action for the current player on the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 若棋局已结束，无可用动作，返回 None</span><br>    <span class="hljs-keyword">if</span> terminal(board):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 使用 Alpha-Beta 剪枝的递归实现。alpha 表示当前已知的最大下界，beta 表示最小上界。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">max_value</span>(<span class="hljs-params">state, alpha, beta</span>):<br>        <span class="hljs-keyword">if</span> terminal(state):<br>            <span class="hljs-keyword">return</span> utility(state)<br>        v = -math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(state):<br>            v = <span class="hljs-built_in">max</span>(v, min_value(result(state, action), alpha, beta))<br>            <span class="hljs-comment"># 如果当前值已经不小于 beta，后续分支不会被选中，剪枝</span><br>            <span class="hljs-keyword">if</span> v &gt;= beta:<br>                <span class="hljs-keyword">return</span> v<br>            alpha = <span class="hljs-built_in">max</span>(alpha, v)<br>        <span class="hljs-keyword">return</span> v<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">min_value</span>(<span class="hljs-params">state, alpha, beta</span>):<br>        <span class="hljs-keyword">if</span> terminal(state):<br>            <span class="hljs-keyword">return</span> utility(state)<br>        v = math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(state):<br>            v = <span class="hljs-built_in">min</span>(v, max_value(result(state, action), alpha, beta))<br>            <span class="hljs-comment"># 如果当前值已经不大于 alpha，后续分支不会被选中，剪枝</span><br>            <span class="hljs-keyword">if</span> v &lt;= alpha:<br>                <span class="hljs-keyword">return</span> v<br>            beta = <span class="hljs-built_in">min</span>(beta, v)<br>        <span class="hljs-keyword">return</span> v<br><br>    current = player(board)<br>    best_action = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 根节点初始化 alpha/beta</span><br>    alpha = -math.inf<br>    beta = math.inf<br><br>    <span class="hljs-keyword">if</span> current == X:<br>        best_val = -math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(board):<br>            value = min_value(result(board, action), alpha, beta)<br>            <span class="hljs-keyword">if</span> value &gt; best_val:<br>                best_val = value<br>                best_action = action<br>            alpha = <span class="hljs-built_in">max</span>(alpha, best_val)<br>            <span class="hljs-comment"># 找到必胜走法可提前结束</span><br>            <span class="hljs-keyword">if</span> best_val == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        best_val = math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(board):<br>            value = max_value(result(board, action), alpha, beta)<br>            <span class="hljs-keyword">if</span> value &lt; best_val:<br>                best_val = value<br>                best_action = action<br>            beta = <span class="hljs-built_in">min</span>(beta, best_val)<br>            <span class="hljs-keyword">if</span> best_val == -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">return</span> best_action<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50 AI project0 Degrees</title>
    <link href="/2026/01/01/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50X%20project0%20Degrees/"/>
    <url>/2026/01/01/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50X%20project0%20Degrees/</url>
    
    <content type="html"><![CDATA[<h1 id="项目-0-Degrees-六度分隔"><a href="#项目-0-Degrees-六度分隔" class="headerlink" title="项目 0: Degrees (六度分隔)"></a>项目 0: Degrees (六度分隔)</h1><p>编写一个程序，通过选择连接演员的电影序列，确定两个演员之间有多少“层”关系（即六度分隔理论）。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">$ python degrees.py large<br>Loading data...<br>Data loaded.<br><span class="hljs-section">Name: Emma Watson</span><br><span class="hljs-section">Name: Jennifer Lawrence</span><br>3 degrees of separation.<br><span class="hljs-section">1: Emma Watson and Brendan Gleeson starred in Harry Potter and the Order of the Phoenix</span><br><span class="hljs-section">2: Brendan Gleeson and Michael Fassbender starred in Trespass Against Us</span><br><span class="hljs-section">3: Michael Fassbender and Jennifer Lawrence starred in X-Men: First Class</span><br></code></pre></td></tr></table></figure><h2 id="截止时间"><a href="#截止时间" class="headerlink" title="[截止时间]"></a>[截止时间]</h2><p><a href="https://time.cs50.io/20260630T235900Z">2026 年 7 月 1 日，星期三，北京时间 07:59</a></p><h2 id="如何寻求帮助"><a href="#如何寻求帮助" class="headerlink" title="[如何寻求帮助]"></a>[如何寻求帮助]</h2><ol><li>通过 <a href="https://cs50.edx.org/ed">Ed</a> 平台提问。</li><li>在 CS50 的任何<a href="https://cs50.harvard.edu/ai/communities/">社区</a>中交流。</li></ol><hr><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="[背景介绍]"></a>[背景介绍]</h2><p>根据“<a href="https://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon">凯文·贝肯的六度分隔</a>”游戏，好莱坞电影业中的任何人都可以通过最多六个步骤连接到凯文·贝肯，其中每一步都由两位演员共同出演的一部电影组成。</p><p>在这个问题中，我们的目标是找到任意两个演员之间的<strong>最短路径</strong>。</p><p>通过使用<strong>广度优先搜索 (BFS)</strong>，我们可以找到从一个演员到另一个演员的最短路径：</p><ul><li><strong>状态 (States)</strong>：人（演员）。</li><li><strong>动作 (Actions)</strong>：电影（将我们从一个演员带到另一个演员）。</li><li><strong>初始状态与目标状态</strong>：我们要连接的两位演员。</li></ul><hr><h2 id="入门指南"><a href="#入门指南" class="headerlink" title="[入门指南]"></a>[入门指南]</h2><ul><li>从 <a href="https://cdn.cs50.net/ai/2023/x/projects/0/degrees.zip">此处</a> 下载分发代码并解压。</li></ul><hr><h2 id="理解代码"><a href="#理解代码" class="headerlink" title="[理解代码]"></a>[理解代码]</h2><p>分发代码包含两组 CSV 数据文件：<code>large</code>（大型）和 <code>small</code>（小型）。</p><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><ul><li><code>people.csv</code>：包含 <code>id</code>、<code>name</code> 和 <code>birth</code>（出生年份）。</li><li><code>movies.csv</code>：包含 <code>id</code>、<code>title</code> 和 <code>year</code>。</li><li><code>stars.csv</code>：关联演员和电影（<code>person_id</code> 与 <code>movie_id</code> 的对应关系）。</li></ul><h3 id="degrees-py"><a href="#degrees-py" class="headerlink" title="degrees.py"></a><code>degrees.py</code></h3><ul><li><code>names</code> 字典：将姓名映射到 <code>id</code> 集合（处理重名）。</li><li><code>people</code> 字典：映射 <code>id</code> 到演员详细信息。</li><li><code>movies</code> 字典：映射 <code>id</code> 到电影详细信息。</li><li><code>main</code> 函数：加载数据并调用 <code>shortest_path</code>。</li></ul><hr><h2 id="任务要求-Specification"><a href="#任务要求-Specification" class="headerlink" title="[任务要求 (Specification)]"></a>[任务要求 (Specification)]</h2><p>你需要实现 <code>shortest_path</code> 函数，使其返回从 <code>source</code> ID 到 <code>target</code> ID 的最短路径。</p><ul><li><strong>返回值</strong>：函数应返回一个列表，其中每个元素是一个 <code>(movie_id, person_id)</code> 元组。<ul><li>例如：<code>[(1, 2), (3, 4)]</code> 表示源演员通过电影 1 与演员 2 合作，演员 2 通过电影 3 与目标演员 4 合作。</li></ul></li><li><strong>多路径</strong>：如果存在多个等长的最短路径，返回其中任何一个即可。</li><li><strong>无路径</strong>：如果两人之间不连通，返回 <code>None</code>。</li><li><strong>辅助函数</strong>：你可以调用 <code>neighbors_for_person(person_id)</code>，它返回与该演员合作过的所有 <code>(movie_id, person_id)</code> 对。</li></ul><hr><h2 id="提示-Hints"><a href="#提示-Hints" class="headerlink" title="[提示 (Hints)]"></a>[提示 (Hints)]</h2><ul><li><strong>性能优化</strong>：在标准搜索中，算法在节点弹出边缘（Frontier）时检查目标。为了提高效率，你可以在<strong>节点加入边缘时</strong>就检查是否到达目标。</li><li><strong>借鉴代码</strong>：参考并修改课堂示例。<code>util.py</code> 中提供了 <code>Node</code>、<code>StackFrontier</code> 和 <code>QueueFrontier</code> 的实现。</li></ul><hr><h2 id="测试与提交"><a href="#测试与提交" class="headerlink" title="[测试与提交]"></a>[测试与提交]</h2><p>使用 <code>check50</code> 检查正确性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">check50 ai50/projects/2024/x/degrees<br></code></pre></td></tr></table></figure></p><h3 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h3><ol><li>在 <a href="https://submit.cs50.io/invites/d03c31aef1984c29b5e7b268c3a87b7b">submit.cs50.io</a> 授权并加入课程。</li><li>使用 <code>submit50</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">submit50 ai50/projects/2024/x/degrees<br></code></pre></td></tr></table></figure></li></ol><hr><p><strong>数据来源</strong>：信息由 <a href="https://www.imdb.com/">IMDb</a> 提供，经许可使用。</p><h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><p>用队列使用BFS，第一次遇到target时，返回路径。</p><blockquote><p>值得注意的是，Node使用的parent记录上一个结点的值，和一般的图的BFS使用一个path数组边走边记录路径不同。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">shortest_path</span>(<span class="hljs-params">source, target</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the shortest list of (movie_id, person_id) pairs</span><br><span class="hljs-string">    that connect the source to the target.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    If no possible path, returns None.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 使用广度优先搜索（BFS）和 QueueFrontier，保证按边数返回最短路径。</span><br><br>    <span class="hljs-comment"># 特殊情况：起点等于终点，返回空路径（没有边）。</span><br>    <span class="hljs-keyword">if</span> source == target:<br>        <span class="hljs-keyword">return</span> []<br><br>    <span class="hljs-comment"># 初始化 frontier，将起始节点加入队列</span><br>    start = Node(state=source, parent=<span class="hljs-literal">None</span>, action=<span class="hljs-literal">None</span>)<br>    frontier = QueueFrontier()<br>    frontier.add(start)<br><br>    <span class="hljs-comment"># explored 用于记录已访问的 person_id，避免重复扩展</span><br>    explored = <span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-comment"># 主循环：直到 frontier 为空</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> frontier.empty():<br>        node = frontier.remove()<br><br>        <span class="hljs-comment"># 如果当前节点是目标节点，则回溯构造路径并返回</span><br>        <span class="hljs-keyword">if</span> node.state == target:<br>            path = []<br>            <span class="hljs-comment"># 从目标回溯到起点，收集 (movie_id, person_id)</span><br>            <span class="hljs-keyword">while</span> node.parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                path.append((node.action, node.state))<br>                node = node.parent<br>            path.reverse()<br>            <span class="hljs-keyword">return</span> path<br><br>        <span class="hljs-comment"># 标记当前节点为已探索</span><br>        explored.add(node.state)<br><br>        <span class="hljs-comment"># 展开邻居：neighbors_for_person 返回 (movie_id, person_id)</span><br>        <span class="hljs-keyword">for</span> movie_id, person_id <span class="hljs-keyword">in</span> neighbors_for_person(node.state):<br>            <span class="hljs-comment"># 如果该人未被探索且不在 frontier 中，则创建子节点并加入 frontier</span><br>            <span class="hljs-keyword">if</span> person_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> explored <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> frontier.contains_state(person_id):<br>                child = Node(state=person_id, parent=node, action=movie_id)<br>                frontier.add(child)<br><br>    <span class="hljs-comment"># 遍历完仍未找到路径，返回 None 表示不连通</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WLS2网络配置</title>
    <link href="/2025/12/31/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/WLS2%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/12/31/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/WLS2%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="WSL2-网络代理一键配置指南"><a href="#WSL2-网络代理一键配置指南" class="headerlink" title="WSL2 网络代理一键配置指南"></a>WSL2 网络代理一键配置指南</h1><h2 id="1-背景与原理"><a href="#1-背景与原理" class="headerlink" title="1. 背景与原理"></a>1. 背景与原理</h2><p>WSL2 运行在 Hyper-V 虚拟机中，拥有独立的 IP 地址。因此，WSL2 不能直接通过 <code>127.0.0.1</code> 访问宿主机（Windows）上的代理软件。本配置通过自动抓取宿主机虚拟网卡 IP，实现代理的一键开关。</p><h2 id="2-前置准备"><a href="#2-前置准备" class="headerlink" title="2. 前置准备"></a>2. 前置准备</h2><p>在开始配置前，请确保 Windows 端的代理软件已完成以下设置：</p><ol><li><strong>允许局域网连接 (Allow LAN)</strong>：必须勾选，否则 Windows 会拒绝来自 WSL2 的连接。</li><li><strong>确认端口</strong>：确认你的代理软件监听端口（如 <code>10808</code> 或 <code>7890</code>）。</li></ol><hr><h2 id="3-配置步骤"><a href="#3-配置步骤" class="headerlink" title="3. 配置步骤"></a>3. 配置步骤</h2><h3 id="A-修改-Bash-配置文件"><a href="#A-修改-Bash-配置文件" class="headerlink" title="A. 修改 Bash 配置文件"></a>A. 修改 Bash 配置文件</h3><p>在 WSL 终端中运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano ~/.bashrc<br></code></pre></td></tr></table></figure></p><h3 id="B-写入配置脚本"><a href="#B-写入配置脚本" class="headerlink" title="B. 写入配置脚本"></a>B. 写入配置脚本</h3><p>将以下代码粘贴到文件末尾。注意将 <code>10808</code> 修改为你实际的代理端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ---------- WSL2 Proxy Helper ----------</span><br><span class="hljs-comment"># 建议端口与 Windows 代理软件保持一致</span><br><span class="hljs-built_in">export</span> PROXY_PORT=<span class="hljs-string">&quot;10808&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">proxy_on</span></span>() &#123;<br>    <span class="hljs-comment"># 1. 自动获取宿主机 IP (resolv.conf 中的 nameserver)</span><br>    <span class="hljs-built_in">export</span> host_ip=$(grep -m 1 nameserver /etc/resolv.conf | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 2. 设置环境变量 (HTTP/HTTPS/SOCKS5)</span><br>    <span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    <span class="hljs-built_in">export</span> ALL_PROXY=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    <br>    <span class="hljs-comment"># 3. 同步配置 Git 代理</span><br>    git config --global http.proxy <span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    git config --global https.proxy <span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br><br>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32m[√] Proxy Enabled\033[0m&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Host IP: <span class="hljs-variable">$&#123;host_ip&#125;</span>&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Port: <span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">proxy_off</span></span>() &#123;<br>    <span class="hljs-comment"># 1. 取消环境变量</span><br>    <span class="hljs-built_in">unset</span> http_proxy<br>    <span class="hljs-built_in">unset</span> https_proxy<br>    <span class="hljs-built_in">unset</span> ALL_PROXY<br>    <br>    <span class="hljs-comment"># 2. 取消 Git 代理</span><br>    git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>    git config --global --<span class="hljs-built_in">unset</span> https.proxy<br><br>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31m[×] Proxy Disabled\033[0m&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">proxy_test</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Testing connection to Google...&quot;</span><br>    curl -I https://www.google.com<br>&#125;<br><span class="hljs-comment"># --------------------------------------</span><br></code></pre></td></tr></table></figure><h3 id="C-使配置生效"><a href="#C-使配置生效" class="headerlink" title="C. 使配置生效"></a>C. 使配置生效</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><hr><h2 id="4-使用指南"><a href="#4-使用指南" class="headerlink" title="4. 使用指南"></a>4. 使用指南</h2><ul><li><strong>开启代理</strong>：输入 <code>proxy_on</code>。适用于 <code>apt update</code>、<code>git clone</code>、<code>pip install</code> 等。</li><li><strong>关闭代理</strong>：输入 <code>proxy_off</code>。</li><li><strong>检查状态</strong>：输入 <code>proxy_test</code>。</li></ul><hr><h2 id="5-常见问题排查"><a href="#5-常见问题排查" class="headerlink" title="5. 常见问题排查"></a>5. 常见问题排查</h2><h3 id="Q-proxy-on-后依然连接超时-Timeout-？"><a href="#Q-proxy-on-后依然连接超时-Timeout-？" class="headerlink" title="Q: proxy_on 后依然连接超时 (Timeout)？"></a>Q: proxy_on 后依然连接超时 (Timeout)？</h3><ol><li><strong>检查 Windows 防火墙</strong>：以管理员身份在 Windows PowerShell 运行以下命令，允许来自 WSL 的流量：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">New-NetFirewallRule</span> <span class="hljs-literal">-DisplayName</span> <span class="hljs-string">&quot;WSL&quot;</span> <span class="hljs-literal">-Direction</span> Inbound <span class="hljs-literal">-InterfaceAlias</span> <span class="hljs-string">&quot;vEthernet (WSL)&quot;</span> <span class="hljs-literal">-Action</span> Allow<br></code></pre></td></tr></table></figure></li><li><strong>检查代理软件</strong>：确保开启了 “Allow LAN”。</li></ol><h3 id="Q-为什么-ping-google-com-不通？"><a href="#Q-为什么-ping-google-com-不通？" class="headerlink" title="Q: 为什么 ping google.com 不通？"></a>Q: 为什么 ping google.com 不通？</h3><p><code>ping</code> 使用的是 <strong>ICMP 协议</strong>，而大多数应用层代理只转发 <strong>TCP/UDP</strong>。请以 <code>curl -I https://www.google.com</code> 的结果为准。</p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WLS2</tag>
      
      <tag>CS50，网络配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WLS2和Python配置</title>
    <link href="/2025/12/31/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/WSL2%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/12/31/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/WSL2%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>CS50中check作业和提交作业的check50和submit50需要在Linux环境下运行，因此配置下WLS。</p><h2 id="1-WSL2-架构与磁盘管理"><a href="#1-WSL2-架构与磁盘管理" class="headerlink" title="1. WSL2 架构与磁盘管理"></a>1. WSL2 架构与磁盘管理</h2><h3 id="1-1-核心安装与升级"><a href="#1-1-核心安装与升级" class="headerlink" title="1.1 核心安装与升级"></a>1.1 核心安装与升级</h3><ul><li><strong>一键安装</strong>：<code>wsl --install</code>（默认安装 Ubuntu）。</li><li><strong>查看版本</strong>：<code>wsl -l -v</code>。确保版本号显示为 <code>2</code>。</li></ul><h3 id="1-2-F-盘迁移与权限“避坑”指南"><a href="#1-2-F-盘迁移与权限“避坑”指南" class="headerlink" title="1.2 F 盘迁移与权限“避坑”指南"></a>1.2 F 盘迁移与权限“避坑”指南</h3><p>为了保护 C 盘空间，我们将 Ubuntu 移动到了 <code>F:\WSL\Ubuntu</code>。</p><ul><li><strong>错误复现</strong>：报错 <code>E_ACCESSDENIED</code> (拒绝访问)。</li><li><strong>深度排查</strong>：WSL2 的 <code>.vhdx</code> 虚拟磁盘文件本质上是一个实时挂载的磁盘。</li><li><strong>解决方案</strong>：<br>由于你将系统文件放在了非系统盘，有时权限没有正确继承，导致 WSL 服务（以特定系统账户运行）无法读取。</li></ul><ol><li><p>右键点击 <code>F:\WSL</code>（或 <code>Ubuntu</code> 文件夹），选择 <strong>属性</strong>。</p></li><li><p>切换到 <strong>安全</strong> 选项卡。</p></li><li><p>点击 <strong>编辑</strong> -&gt; <strong>添加</strong>。</p></li><li><p>在对象名称框中输入 <code>Everyone</code>（或者你的电脑用户名），点击确定。</p></li><li><p>在权限列表中，勾选 <strong>完全控制</strong>。</p></li><li><p>点击确定应用。</p></li></ol><hr><h2 id="2-Linux-系统配置与优化"><a href="#2-Linux-系统配置与优化" class="headerlink" title="2. Linux 系统配置与优化"></a>2. Linux 系统配置与优化</h2><h3 id="2-1-软件源刷新-解决“找不到包”报错"><a href="#2-1-软件源刷新-解决“找不到包”报错" class="headerlink" title="2.1 软件源刷新 (解决“找不到包”报错)"></a>2.1 软件源刷新 (解决“找不到包”报错)</h3><ul><li><strong>现象</strong>：执行 <code>sudo apt install python3-venv</code> 提示 <code>no installation candidate</code>。</li><li><strong>原理</strong>：Ubuntu 刚装好时，本地的软件包索引是空的，它不知道去哪里下载。</li><li><strong>操作</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br></code></pre></td></tr></table></figure>  <em>这步操作会从服务器拉取最新的软件清单。</em></li></ul><h3 id="2-2-彻底静音处理"><a href="#2-2-彻底静音处理" class="headerlink" title="2.2 彻底静音处理"></a>2.2 彻底静音处理</h3><ul><li><strong>痛点</strong>：按 Tab 或 Backspace 时，系统发出刺耳的蜂鸣音。<h3 id="3-关闭-Windows-Terminal-的全局提示音"><a href="#3-关闭-Windows-Terminal-的全局提示音" class="headerlink" title="3. 关闭 Windows Terminal 的全局提示音"></a>3. 关闭 Windows Terminal 的全局提示音</h3></li></ul><p>如果你使用的是 <strong>Windows Terminal</strong>（就是你截图里那个带有标签页的黑色窗口），它本身也有一个设置：</p><ol><li><p>点击窗口顶部的 <strong>向下小箭头</strong>，选择 <strong>设置 (Settings)</strong>。</p></li><li><p>在左侧菜单点击 <strong>默认值 (Defaults)</strong>。</p></li><li><p>在右侧找到 <strong>高级 (Advanced)</strong>。</p></li><li><p>找到 <strong>钟声通知样式 (Bell notification style)</strong>，将其设置为 <strong>无 (None)</strong>。</p></li><li><p>点击右下角的 <strong>保存</strong>。</p></li></ol><hr><h2 id="3-Python-虚拟环境-Virtual-Environment-深度实战"><a href="#3-Python-虚拟环境-Virtual-Environment-深度实战" class="headerlink" title="3. Python 虚拟环境 (Virtual Environment) 深度实战"></a>3. Python 虚拟环境 (Virtual Environment) 深度实战</h2><p>对于 CS50 AI 的 <code>degrees</code> 项目，必须使用 <code>venv</code> 来隔离环境。</p><h3 id="3-1-环境安装"><a href="#3-1-环境安装" class="headerlink" title="3.1 环境安装"></a>3.1 环境安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 安装 pip 包管理器和 venv 模块</span><br><span class="hljs-built_in">sudo</span> apt install python3-pip python3-venv -y<br></code></pre></td></tr></table></figure><h3 id="3-2-虚拟环境“三部曲”"><a href="#3-2-虚拟环境“三部曲”" class="headerlink" title="3.2 虚拟环境“三部曲”"></a>3.2 虚拟环境“三部曲”</h3><ol><li><strong>创建环境</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在项目目录下创建一个名为 venv 的“小房间”</span><br>python3 -m venv venv<br></code></pre></td></tr></table></figure></li><li><strong>激活环境</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这一步会修改当前终端的 PATH 变量</span><br><span class="hljs-built_in">source</span> venv/bin/activate<br></code></pre></td></tr></table></figure><em>激活后，命令行首部会出现 <code>(venv)</code> 标识。</em></li><li><p><strong>隔离原理对比</strong>：</p><ul><li><strong>未激活</strong>：系统默认调用 <code>/usr/bin/python3</code>。</li><li><strong>激活后</strong>：终端会拦截指令，优先使用 <code>~/cs50ai/project0/degrees/venv/bin/python3</code>。</li></ul></li></ol><h3 id="3-3-运行-CS50-AI-项目"><a href="#3-3-运行-CS50-AI-项目" class="headerlink" title="3.3 运行 CS50 AI 项目"></a>3.3 运行 CS50 AI 项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入作业目录</span><br><span class="hljs-built_in">cd</span> ~/cs50ai/project0/degrees<br><br><span class="hljs-comment"># 运行程序并带上 large 数据集参数</span><br>python3 degrees.py large<br></code></pre></td></tr></table></figure><hr><h2 id="4-后端开发常用“互通”命令"><a href="#4-后端开发常用“互通”命令" class="headerlink" title="4. 后端开发常用“互通”命令"></a>4. 后端开发常用“互通”命令</h2><p>作为准 Java 后端开发，你会频繁用到这些跨界操作：</p><div class="table-container"><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">命令</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left"><strong>文件管理</strong></td><td style="text-align:left"><code>explorer.exe .</code></td><td style="text-align:left">弹窗 Windows 文件夹显示 Linux 当前路径</td></tr><tr><td style="text-align:left"><strong>代码编辑</strong></td><td style="text-align:left"><code>code .</code></td><td style="text-align:left">启动 VS Code 并利用 WSL 插件进行开发</td></tr><tr><td style="text-align:left"><strong>系统监控</strong></td><td style="text-align:left"><code>htop</code></td><td style="text-align:left">Linux 风格的动态资源监视器</td></tr><tr><td style="text-align:left"><strong>解压作业</strong></td><td style="text-align:left"><code>unzip degrees.zip</code></td><td style="text-align:left">需先安装 <code>sudo apt install unzip</code></td></tr></tbody></table></div><hr>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WLS2</tag>
      
      <tag>CS50</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="/2025/12/29/JavaSE/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2025/12/29/JavaSE/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/IDEA快捷键/2025-12-29-13-14-07.png" alt=""></p><h2 id="一、-精准检索：在代码海洋中定位"><a href="#一、-精准检索：在代码海洋中定位" class="headerlink" title="一、 精准检索：在代码海洋中定位"></a>一、 精准检索：在代码海洋中定位</h2><h3 id="1-内容搜索"><a href="#1-内容搜索" class="headerlink" title="1. 内容搜索"></a>1. 内容搜索</h3><ul><li><strong>当前文件查找 (<code>Ctrl + F</code>)</strong>：在当前打开的文件中搜索关键字。</li><li><strong>全局内容查找 (<code>Ctrl + Shift + F</code>)</strong>：在整个项目中搜索特定字符串，支持路径过滤。</li><li><strong>当前文件替换 (<code>Ctrl + R</code>)</strong>：快速替换当前类中的特定字符。</li><li><strong>全局内容替换 (<code>Ctrl + Shift + R</code>)</strong>：批量修改整个项目的字符串或配置。</li></ul><h3 id="2-对象搜索-最常用"><a href="#2-对象搜索-最常用" class="headerlink" title="2. 对象搜索 (最常用)"></a>2. 对象搜索 (最常用)</h3><ul><li><strong>查找类名 (<code>Ctrl + N</code>)</strong>：输入类名快速打开 Java 文件，支持模糊匹配。</li><li><strong>查找文件名 (<code>Ctrl + Shift + N</code>)</strong>：不仅是 Java 类，还可以快速找 XML、Properties、JSON 等配置文件。</li><li><strong>跳转指定行 (<code>Ctrl + G</code>)</strong>：当报错堆栈提示行号时，这是最快的定位方式。</li></ul><hr><h2 id="二、-优雅导航：在逻辑森林中穿行"><a href="#二、-优雅导航：在逻辑森林中穿行" class="headerlink" title="二、 优雅导航：在逻辑森林中穿行"></a>二、 优雅导航：在逻辑森林中穿行</h2><h3 id="1-结构与跳转"><a href="#1-结构与跳转" class="headerlink" title="1. 结构与跳转"></a>1. 结构与跳转</h3><ul><li><strong>最近打开文件 (<code>Ctrl + E</code>)</strong>：展示最近编辑过的文件列表，是文件切换的“第一核心键”。</li><li><strong>跳转到前/后方法 (<code>Alt + Up/Down</code>)</strong>：在类的方法之间快速跳跃，无需滚动滑轮。</li><li><strong>查看类结构 (<code>Ctrl + F12</code>)</strong>：弹窗展示当前类的所有方法和成员变量，支持直接输入搜索。</li></ul><h3 id="2-深度溯源"><a href="#2-深度溯源" class="headerlink" title="2. 深度溯源"></a>2. 深度溯源</h3><ul><li><strong>跳转到定义 (<code>Ctrl + B</code> 或 <code>Ctrl + Click</code>)</strong>：查看变量、类或方法的源代码。</li><li><strong>跳转到实现类 (<code>Ctrl + Alt + B</code>)</strong>：<strong>超级好用！</strong> 面对接口时，直接跳过接口定义，进到具体的业务实现类中。</li><li><strong>回退/前进浏览记录 (<code>Ctrl + Alt + Left/Right</code>)</strong>：就像浏览器的前进后退，快速回到刚才看代码的地方。</li></ul><hr><h2 id="三、-智能辅助：让-IDEA-为你“代工”"><a href="#三、-智能辅助：让-IDEA-为你“代工”" class="headerlink" title="三、 智能辅助：让 IDEA 为你“代工”"></a>三、 智能辅助：让 IDEA 为你“代工”</h2><h3 id="1-自动生成"><a href="#1-自动生成" class="headerlink" title="1. 自动生成"></a>1. 自动生成</h3><ul><li><strong>万能意图键 (<code>Alt + Enter</code>)</strong>：代码报错了？想导包？想创建实现类？按它就对了。</li><li><strong>代码格式化 (<code>Ctrl + Alt + L</code>)</strong>：保持代码整洁的最高效手段，建议每次写完方法都按一下。</li><li><strong>智能代码补全 (<code>Ctrl + Shift + Space</code>)</strong>：比普通补全更聪明，会根据类型推断你最可能需要的变量或方法。</li><li><strong>语句自动完成 (<code>Ctrl + Shift + Enter</code>)</strong>：自动补齐括号、大括号并在行末加分号。</li></ul><h3 id="2-编码细节"><a href="#2-编码细节" class="headerlink" title="2. 编码细节"></a>2. 编码细节</h3><ul><li><strong>参数信息提示 (<code>Ctrl + P</code>)</strong>：在调用方法时，忘记要传什么参数？按一下即刻显示参数列表。</li><li><strong>快速注释</strong>：<ul><li><code>Ctrl + /</code>：行注释。</li><li><code>Ctrl + Shift + /</code>：块注释。</li></ul></li><li><strong>包裹代码 (<code>Ctrl + Alt + T</code>)</strong>：快速把一段逻辑包进 <code>if</code>、<code>try-catch</code> 或 <code>synchronized</code> 块中。</li></ul><hr><h2 id="四、-代码重构：像外科医生一样精准"><a href="#四、-代码重构：像外科医生一样精准" class="headerlink" title="四、 代码重构：像外科医生一样精准"></a>四、 代码重构：像外科医生一样精准</h2><h3 id="1-元素重命名"><a href="#1-元素重命名" class="headerlink" title="1. 元素重命名"></a>1. 元素重命名</h3><ul><li><strong>重命名 (<code>Shift + F6</code>)</strong>：修改变量、方法或类名，它会自动帮你把项目中所有引用的地方同步更新。</li></ul><h3 id="2-提取神器-大幅提升代码可读性"><a href="#2-提取神器-大幅提升代码可读性" class="headerlink" title="2. 提取神器 (大幅提升代码可读性)"></a>2. 提取神器 (大幅提升代码可读性)</h3><ul><li><strong>提取变量 (<code>Ctrl + Alt + V</code>)</strong>：将冗长的表达式结果自动声明为局部变量。</li><li><strong>提取方法 (<code>Ctrl + Alt + M</code>)</strong>：选中一段复杂的逻辑，将其“抽离”成一个独立的方法。</li><li><strong>提取常量 (<code>Ctrl + Alt + C</code>)</strong>：将魔法值（如硬编码的字符串）提取为类常量。</li><li><strong>提取参数 (<code>Ctrl + Alt + P</code>)</strong>：将局部变量转变为方法参数，方便逻辑复用。</li></ul><hr><h2 id="五、-编辑小技巧"><a href="#五、-编辑小技巧" class="headerlink" title="五、 编辑小技巧"></a>五、 编辑小技巧</h2><ul><li><strong>复制当前行 (<code>Ctrl + D</code>)</strong>：将光标所在行直接复制到下一行。</li><li><strong>删除当前行 (<code>Ctrl + Y</code> 或 <code>Ctrl + X</code>)</strong>：快速清理无用代码。</li><li><strong>代码行交换顺序 (<code>Ctrl + Shift + Up/Down</code>)</strong>：无需剪切粘贴，直接上下平移代码行。</li><li><strong>扩大/回退选择 (<code>Ctrl + W</code> / <code>Ctrl + Shift + W</code>)</strong>：以词/块为单位逐步扩大选中范围，配合重构功能堪称绝配。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>快捷键</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50AI note0</title>
    <link href="/2025/12/26/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50%20AI%20note%200/"/>
    <url>/2025/12/26/%E5%AD%A6%E9%99%A2%E6%B4%BE/CS50%20AI%20note%200/</url>
    
    <content type="html"><![CDATA[<h2 id="第-0-讲"><a href="#第-0-讲" class="headerlink" title="第 0 讲"></a><a href="https://cs50.harvard.edu/ai/notes/0/#lecture-0">第 0 讲</a></h2><h2 id="人工智能-Artificial-Intelligence"><a href="#人工智能-Artificial-Intelligence" class="headerlink" title="人工智能 (Artificial Intelligence)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#artificial-intelligence">人工智能 (Artificial Intelligence)</a></h2><p>人工智能 (AI) 涵盖了一系列让计算机表现出类似拥有“感知”行为的技术。例如，AI 被用于识别社交媒体照片中的人脸、在国际象棋中击败世界冠军，以及在你与手机上的 Siri 或 Alexa 对话时处理你的语音。</p><p>在本课程中，我们将探讨使 AI 成为可能的一些核心思想：</p><ol><li><p><strong>搜索 (Search)</strong></p><p>寻找问题的解决方案，例如导航应用程序寻找从起点到终点的最佳路线，或者在玩游戏时计算下一步该怎么走。</p></li><li><p><strong>知识 (Knowledge)</strong></p><p>表示信息并从中进行推理。</p></li><li><p><strong>不确定性 (Uncertainty)</strong></p><p>利用概率论处理不确定事件。</p></li><li><p><strong>优化 (Optimization)</strong></p><p>不仅要找到解决问题的正确方法，还要找到更好——甚至最好——的解决方法。</p></li><li><p><strong>学习 (Learning)</strong></p><p>通过访问数据和经验来提高性能。例如，你的电子邮件系统能够根据过去的经验区分垃圾邮件和非垃圾邮件。</p></li><li><p><strong>神经网络 (Neural Networks)</strong></p><p>一种受人脑启发的程序结构，能够有效地执行任务。</p></li><li><p><strong>语言 (Language)</strong></p><p>处理自然语言，即人类产生和理解的语言。</p></li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：这门课程的结构非常经典，不仅仅关注现在流行的“深度学习”，而是涵盖了 AI 的基础逻辑（如符号主义、概率推理等）。“搜索”是 AI 的基石，本质上是在无数种可能中找到达成目标的路径。</p></blockquote><h2 id="搜索-Search"><a href="#搜索-Search" class="headerlink" title="搜索 (Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#search">搜索 (Search)</a></h2><p>搜索问题涉及一个<strong>智能体 (Agent)</strong>，它被赋予一个<strong>初始状态</strong>和一个<strong>目标状态</strong>，它的任务是返回如何从前者到达后者的解决方案。导航应用就是典型的搜索过程，智能体（程序的思考部分）接收你当前的位置和想要去的目的地作为输入，并基于搜索算法返回建议的路径。当然，还有许多其他形式的搜索问题，如拼图或迷宫。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/15puzzle.png" alt="15 puzzle"></p><p>找到 15 数字推盘游戏的解法需要使用搜索算法。</p><ul><li><p><strong>智能体 (Agent)</strong></p><p>一个能够感知环境并对环境采取行动的实体。例如在导航应用中，智能体代表一辆需要决定采取哪些行动才能到达目的地的汽车。</p></li><li><p><strong>状态 (State)</strong></p><p>智能体在其环境中的一种配置。例如，在 <a href="https://en.wikipedia.org/wiki/15_puzzle">15 数字推盘</a>中，一个状态就是板上数字排列的任意一种方式。</p><ul><li><strong>初始状态 (Initial State)</strong><br>搜索算法开始的状态。在导航应用中，就是当前位置。</li></ul></li><li><p><strong>动作 (Actions)</strong></p><p>在一个状态下可以做出的选择。更准确地说，动作可以定义为一个函数。接收状态 <code>s</code> 作为输入，<code>Actions(s)</code> 返回在状态 <code>s</code> 下可执行的动作集合作为输出。例如，在 <em>15 数字推盘</em>中，给定状态的动作就是你滑动方块的方式（如果空位在中间则有 4 种，如果在边上则有 3 种，在角落则有 2 种）。</p></li><li><p><strong>转移模型 (Transition Model)</strong></p><p>描述在任何状态下执行任何适用动作后会产生什么状态。更准确地说，转移模型可以定义为一个函数。接收状态 <code>s</code> 和动作 <code>a</code> 作为输入，<code>Results(s, a)</code> 返回在状态 <code>s</code> 下执行动作 <code>a</code> 后产生的新状态。例如，给定 <em>15 数字推盘</em>的某种配置（状态 <code>s</code>），向任何方向移动一个方块（动作 <code>a</code>）都会带来拼图的新配置（新状态）。</p></li><li><p><strong>状态空间 (State Space)</strong></p><p>从初始状态通过任意动作序列可到达的所有状态的集合。例如，在 15 数字推盘中，状态空间由所有从初始状态可到达的 16!/2 种棋盘配置组成。状态空间可以可视化为一个有向图，状态表示为节点，动作表示为节点之间的箭头。</p></li></ul><p><img src="https://cs50.harvard.edu/ai/notes/0/statespace.png" alt="State Space"></p><ul><li><p><strong>目标测试 (Goal Test)</strong></p><p>确定给定状态是否为目标状态的条件。例如，在导航应用中，目标测试是检查智能体（汽车的代表）的当前位置是否在目的地。如果是——问题解决。如果不是——我们继续搜索。</p></li><li><p><strong>路径代价 (Path Cost)</strong></p><p>与给定路径相关的数值成本。例如，导航应用不仅带你到达目标；它会在最小化路径代价的同时这样做，即为你找到到达目标状态的最快方式。</p></li></ul><blockquote><p><strong>🔍 [译者注释]</strong>：理解这些术语至关重要。</p><ul><li><strong>状态 (State)</strong> 是“我们在哪里”。</li><li><strong>动作 (Action)</strong> 是“我们能做什么”。</li><li><strong>转移模型 (Transition)</strong> 是“做了之后会发生什么”。</li><li><strong>状态空间 (State Space)</strong> 是“所有可能情况的地图”。搜索算法本质上就是在这个巨大的“地图”中寻找一条路线。</li></ul></blockquote><h2 id="解决搜索问题"><a href="#解决搜索问题" class="headerlink" title="解决搜索问题"></a><a href="https://cs50.harvard.edu/ai/notes/0/#solving-search-problems">解决搜索问题</a></h2><ul><li><p><strong>解 (Solution)</strong></p><p>从初始状态导致目标状态的一系列动作。</p><ul><li><strong>最优解 (Optimal Solution)</strong><br>在所有解中具有最低路径代价的解。</li></ul></li></ul><p>在搜索过程中，数据通常存储在 <strong><em>节点 (Node)</em></strong> 中，这是一种包含以下数据的数据结构：</p><ul><li>一个 <em>状态 (state)</em></li><li>它的 <em>父节点 (parent node)</em>，即生成当前节点的那个节点</li><li>从父节点的状态应用到当前节点的 <em>动作 (action)</em></li><li>从初始状态到此节点的 <em>路径代价 (path cost)</em></li></ul><p><em>节点</em> 包含的信息使它们对搜索算法非常有用。它们包含一个 <em>状态</em>，可以使用 <em>目标测试</em> 来检查它是否是最终状态。如果是，该节点的 <em>路径代价</em> 可以与其他节点的 <em>路径代价</em> 进行比较，从而允许选择 <em>最优解</em>。一旦选择了节点，由于存储了 <em>父节点</em> 和导致从 <em>父节点</em> 到当前节点的 <em>动作</em>，就可以从 <em>初始状态</em> 一步步回溯到该节点，这个动作序列就是 <em>解</em>。</p><p>然而，<em>节点</em> 只是数据结构——它们不进行搜索，它们只是持有信息。为了实际进行搜索，我们使用 <strong>前沿 (frontier)</strong>（或称边界），这是一种“管理” <em>节点</em> 的机制。<em>前沿</em> 开始时包含一个初始状态和一个空的已探索项集合，然后重复以下操作直到找到解：</p><p><strong>重复 (Repeat):</strong></p><ol><li>如果前沿 (frontier) 为空，<ul><li><em>停止。</em> 问题无解。</li></ul></li><li>从前沿中移除一个节点。这是将被考虑的节点。</li><li><p>如果该节点包含目标状态，</p><ul><li>返回解。<em>停止</em>。</li></ul><p>否则 (Else)，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">* 扩展该节点（找到从该节点可以到达的所有新节点），并将结果节点添加到前沿中。<br>* 将当前节点添加到已探索集合 (explored set) 中。<br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li><strong>节点 vs 状态</strong>：这是一个常见的混淆点。<strong>状态</strong>是物理世界的配置（例如“我在 A 城市”）。<strong>节点</strong>是算法记录的账本（例如“我在 A 城市，我是从 B 城市过来的，目前花了 100 块钱”）。同一个状态（A 城市）可能对应多个节点（你可以从 B 来，也可以从 C 来）。</li><li><strong>前沿 (Frontier)</strong>：可以把它想象成一个“待办事项列表”。算法不断从这个列表中取出任务（节点）来处理，并把新发现的任务加进去。</li></ul></blockquote><h3 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索 (Depth-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#depth-first-search">深度优先搜索 (Depth-First Search)</a></h3><p>在前面关于 <em>前沿</em> 的描述中，有一件事没有提到。在伪代码的第 2 步，应该移除哪个节点？这个选择对解的质量以及找到解的速度有影响。有多种方法来决定应该首先考虑哪些节点，其中两种可以用 <strong>栈 (stack)</strong>（用于 <em>深度优先</em> 搜索）和 <strong>队列 (queue)</strong>（用于 <em>广度优先</em> 搜索）的数据结构来表示（<a href="https://www.google.com/search?q=dfs+vs+bfs+gif">这是一个可爱的卡通演示</a>）。</p><p>我们从 <em>深度优先</em> 搜索 (<em>DFS</em>) 方法开始。</p><p><em>深度优先</em> 搜索算法在尝试另一个方向之前会耗尽每一个方向。在这种情况下，前沿作为 <em>栈</em> 数据结构进行管理。你需要记住的口号是“<strong>后进先出 (Last-In First-Out)</strong>”。在节点被添加到前沿后，第一个被移除并考虑的节点是最后被添加的那一个。这导致搜索算法会在第一个阻碍它的方向上尽可能深地搜索，而将所有其他方向留待稍后处理。</p><p>（课程外的例子：假设你在找钥匙。在 <em>深度优先</em> 搜索方法中，如果你选择从裤子开始找，你会先检查每一个口袋，清空每个口袋并仔细检查内容物。只有当你完全检查完裤子的每一个口袋后，你才会停止在裤子里搜索并开始在其他地方搜索。）</p><ul><li><strong>优点</strong>:<ul><li>在最好的情况下，这个算法是最快的。如果它“运气好”并且总是（偶然地）选择通往解的正确路径，那么 <em>深度优先</em> 搜索花费的时间最少。</li></ul></li><li><strong>缺点</strong>:<ul><li>找到的解可能不是最优的。</li><li>在最坏的情况下，这个算法会在找到解之前探索每一条可能的路径，因此在到达解之前花费最长的时间。</li></ul></li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义从前沿移除节点并返回它的函数。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 如果前沿为空，则终止搜索，因为这意味着没有解。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;empty frontier&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 保存列表中的最后一项（即最新添加的节点）</span><br>        node = <span class="hljs-variable language_">self</span>.frontier[-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 保存列表中除了最后一个节点之外的所有项（即移除最后一个节点）</span><br>        <span class="hljs-variable language_">self</span>.frontier = <span class="hljs-variable language_">self</span>.frontier[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure><h3 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索 (Breadth-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#breadth-first-search">广度优先搜索 (Breadth-First Search)</a></h3><p><em>深度优先</em> 搜索的对立面是 <em>广度优先</em> 搜索 (<em>BFS</em>)。</p><p><em>广度优先</em> 搜索算法将同时沿着多个方向前进，在每个可能的方向上迈出一步，然后在每个方向上迈出第二步。在这种情况下，前沿作为 <em>队列</em> 数据结构进行管理。你需要记住的口号是“<strong>先进先出 (First-In First-Out)</strong>”。在这种情况下，所有新节点排队等候，根据添加的顺序来考虑节点（先到先得！）。这导致搜索算法在任何一个方向采取第二步之前，先在每个可能的方向上采取一步。</p><p>（课程外的例子：假设你在找钥匙。在这种情况下，如果你从裤子开始，你会看一眼右口袋。之后，你不会接着看左口袋，而是会看一眼抽屉。然后是桌子上。依此类推，在你通过所有想到的位置各看一眼之后。只有当你遍历了所有位置后，你才会回到裤子并搜索下一个口袋。）</p><ul><li><strong>优点</strong>:<ul><li>该算法<strong>保证</strong>找到最优解。</li></ul></li><li><strong>缺点</strong>:<ul><li>该算法几乎肯定比最小运行时间要长。</li><li>在最坏的情况下，该算法需要最长的时间运行。</li></ul></li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义从前沿移除节点并返回它的函数。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 如果前沿为空，则终止搜索，因为这意味着没有解。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;empty frontier&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 保存列表中的最老项（即第一个被添加的项）</span><br>        node = <span class="hljs-variable language_">self</span>.frontier[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 保存列表中除了第一项之外的所有项（即移除第一个节点）</span><br>        <span class="hljs-variable language_">self</span>.frontier = <span class="hljs-variable language_">self</span>.frontier[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li><strong>DFS (深度优先)</strong> 就像走迷宫时“一条路走到黑”，撞墙了再退回来。如果你运气好选对了路，很快就能到；运气不好，可能会绕很远。<strong>它不保证找到最近的路。</strong></li><li><strong>BFS (广度优先)</strong> 就像水波纹扩散，一圈一圈向外找。因为它是按距离（步数）一层层找的，所以它<strong>一定能找到步数最少的解</strong>（最优解），但通常比较耗费内存。</li></ul></blockquote><h3 id="贪婪最佳优先搜索-Greedy-Best-First-Search"><a href="#贪婪最佳优先搜索-Greedy-Best-First-Search" class="headerlink" title="贪婪最佳优先搜索 (Greedy Best-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#greedy-best-first-search">贪婪最佳优先搜索 (Greedy Best-First Search)</a></h3><p>广度优先和深度优先都是 <strong>无信息 (uninformed)</strong> 搜索算法。也就是说，这些算法除了通过自身探索获得的信息外，不利用任何关于问题的知识。然而，通常情况下，关于问题的一些知识实际上是可用的。例如，当人类迷宫解决者进入一个路口时，人类可以看到哪条路通向解的大致方向，哪条路不是。AI 也可以做同样的事情。一种考虑额外知识以试图提高其性能的算法称为 <strong>有信息 (informed)</strong> 搜索算法。</p><p><strong>贪婪最佳优先</strong> 搜索扩展那个由 <strong>启发式函数 (heuristic function)</strong> <em>h(n)</em> 确定为最接近目标的节点。顾名思义，该函数估计下一个节点距离目标有多近，但它可能会出错。<em>贪婪最佳优先</em> 算法的效率取决于启发式函数的好坏。例如，在迷宫中，算法可以使用一个依赖于可能节点与迷宫终点之间的 <strong>曼哈顿距离 (Manhattan distance)</strong> 的启发式函数。<em>曼哈顿距离</em> 忽略墙壁，计算从一个位置到达目标位置需要向上、向下或向两侧走多少步。这是一个基于当前位置和目标位置的 (x, y) 坐标可以得出的简单估算。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/manhattandistance.png" alt="Manhattan Distance"></p><p>曼哈顿距离</p><p>然而，必须强调的是，与任何启发式方法一样，它可能会出错并导致算法走上一条比其他路径更慢的路径。有可能 <em>无信息</em> 搜索算法会更快地提供更好的解，但它这样做的可能性比 <em>有信息</em> 算法要小。</p><blockquote><p><strong>🔍 [译者注释]</strong>：为什么叫“贪婪”？因为它只看眼前哪个节点离目标最近（由 $h(n)$ 决定），而不考虑它是怎么到达那个节点的（忽略了已经走过的成本）。这就像为了去某个地方，总是选择直线距离最近的路口，哪怕那条路其实很堵或者要绕远路。</p></blockquote><h3 id="A-搜索-A-Search"><a href="#A-搜索-A-Search" class="headerlink" title="A* 搜索 (A* Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#a-search">A* 搜索 (A* Search)</a></h3><p>作为 <em>贪婪最佳优先</em> 算法的发展，<em>A* 搜索</em> 不仅考虑 <em>h(n)</em>（从当前位置到目标的估计成本），还考虑 <em>g(n)</em>（直到当前位置所累积的成本）。通过结合这两个值，算法有一种更准确的方法来确定解的成本并动态优化其选择。算法跟踪 (<em>至今路径成本</em> + <em>到目标的估计成本</em>)，一旦它超过某个先前选项的估计成本，算法就会放弃当前路径并回到先前的选项，从而防止自己沿着 <em>h(n)</em> 错误地标记为最佳的一条长且低效的路径走下去。</p><p>同样，由于该算法也依赖于启发式，它的好坏取决于它所采用的启发式。在某些情况下，它可能比 <em>贪婪最佳优先</em> 搜索甚至 <em>无信息</em> 算法效率低。为了使 <em>A* 搜索</em> 成为最优的，启发式函数 <em>h(n)</em> 必须是：</p><ol><li><em>可采纳的 (Admissible)</em>，即通过不高估真实成本（即永远不大于实际成本）。</li><li><em>一致的 (Consistent)</em>，这意味着新节点到目标的估计路径成本加上从前一个节点转移到它的成本，大于或等于前一个节点到目标的估计路径成本。用方程形式表示，如果对于每个节点 <em>n</em> 和步长成本为 <em>c</em> 的后继节点 <em>n’</em>，都有 <em>h(n) ≤ h(n’) + c</em>，则 <em>h(n)</em> 是一致的。</li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：A* 是目前最流行的寻路算法。</p><ul><li>公式：$f(n) = g(n) + h(n)$。<ul><li>$g(n)$：我已经走了多远（实际成本）。</li><li>$h(n)$：我估计还要走多远（启发式）。</li></ul></li><li><strong>可采纳性 (Admissible)</strong>：意味着你的估计必须是“乐观”的。如果你估计还需要走 10 步，但实际需要 5 步，那就不行；但如果你估计 10 步，实际需要 20 步，那是可以的。只要不高估，A* 就能保证找到最优解。</li></ul></blockquote><h3 id="对抗搜索-Adversarial-Search"><a href="#对抗搜索-Adversarial-Search" class="headerlink" title="对抗搜索 (Adversarial Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#adversarial-search">对抗搜索 (Adversarial Search)</a></h3><p>此前，我们讨论的算法需要找到问题的答案，而在 <strong>对抗搜索</strong> 中，算法面临着试图实现相反目标的对手。通常，使用对抗搜索的 AI 会出现在游戏中，例如井字棋 (Tic-Tac-Toe)。</p><h4 id="极小化极大算法-Minimax"><a href="#极小化极大算法-Minimax" class="headerlink" title="极小化极大算法 (Minimax)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#minimax">极小化极大算法 (Minimax)</a></h4><p>作为对抗搜索中的一种算法，<strong>Minimax</strong> 将胜利条件表示为一方 (-1) 和另一方 (+1)。进一步的行动将由这些条件驱动，最小化方试图获得最低分，最大化方试图获得最高分。</p><p><strong>表示井字棋 AI</strong>:</p><ul><li><em>S₀</em>: 初始状态（在我们的例子中，空的 3X3 棋盘）</li><li><em>Players(s)</em>: 给定状态 <em>s</em>，返回轮到哪个玩家（X 或 O）的函数。</li><li><em>Actions(s)</em>: 给定状态 <em>s</em>，返回该状态下所有合法移动（棋盘上哪些位置是空的）的函数。</li><li><em>Result(s, a)</em>: 给定状态 <em>s</em> 和动作 <em>a</em>，返回新状态的函数。这是在状态 <em>s</em> 上执行动作 <em>a</em>（在游戏中走一步）后产生的棋盘。</li><li><em>Terminal(s)</em>: 给定状态 <em>s</em>，检查这是否是游戏的最后一步（即是否有人赢了或平局）的函数。如果游戏结束返回 <em>True</em>，否则返回 <em>False</em>。</li><li><em>Utility(s)</em>: 给定终端状态 <em>s</em>，返回状态的效用值的函数：-1、0 或 1。</li></ul><p><strong>算法如何工作</strong>:</p><p>该算法递归地模拟从当前状态开始直到达到终端状态的所有可能发生的游戏。每个终端状态被赋值为 (-1)、0 或 (+1)。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/minimax_tictactoe.png" alt="Minimax in Tic Tac Toe"></p><p>井字棋中的 Minimax 算法</p><p>根据状态知道轮到谁，算法可以知道当前玩家在进行最佳操作时，会选择导致值更低还是更高的状态的动作。这样，在最小化和最大化之间交替，算法为每个可能动作导致的状态创建值。举个更具体的例子，我们可以想象最大化玩家在每一轮都会问：“如果我采取这个行动，将会产生一个新状态。如果最小化玩家玩得最好，那个玩家会采取什么行动来带来最低的值？”然而，要回答这个问题，最大化玩家必须问：“要知道最小化玩家会做什么，我需要在最小化玩家的脑海中模拟相同的过程：最小化玩家会试图问：‘如果我采取这个行动，最大化玩家可以采取什么行动来带来最高的值？’”这是一个递归过程，可能很难理解；看下面的伪代码会有所帮助。最终，通过这个递归推理过程，最大化玩家为当前状态下所有可能动作可能导致的状态生成值。拥有这些值后，最大化玩家选择最高的一个。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/minimax_theoretical.png" alt="Minimax Algorithm"></p><p>最大化者考虑未来状态的可能值。</p><p>用伪代码表示，Minimax 算法的工作方式如下：</p><ul><li>给定状态 <em>s</em><ul><li>最大化玩家在 <em>Actions(s)</em> 中选择动作 <em>a</em>，该动作产生 <em>Min-Value(Result(s, a))</em> 的最高值。</li><li>最小化玩家在 <em>Actions(s)</em> 中选择动作 <em>a</em>，该动作产生 <em>Max-Value(Result(s, a))</em> 的最低值。</li></ul></li><li>函数 <em>Max-Value(state)</em><ul><li><em>v = -∞</em></li><li>如果 <em>Terminal(state)</em>:<br>返回 <em>Utility(state)</em></li><li>对于 <em>Actions(state)</em> 中的 <em>action</em>:<br><em>v = Max(v, Min-Value(Result(state, action)))</em><br>返回 <em>v</em></li></ul></li><li>函数 <em>Min-Value(state)</em>:<ul><li><em>v = ∞</em></li><li>如果 <em>Terminal(state)</em>:<br>返回 <em>Utility(state)</em></li><li>对于 <em>Actions(state)</em> 中的 <em>action</em>:<br><em>v = Min(v, Max-Value(Result(state, action)))</em><br>返回 <em>v</em></li></ul></li></ul><blockquote><p><strong>🔍 [译者注释]</strong>：Minimax 的核心逻辑是“换位思考”。</p><ul><li><strong>Max (我)</strong>：我想赢（得分 +1）。</li><li><strong>Min (对手)</strong>：想让我输（得分 -1）。</li><li>在做决定时，我会假设对手极其聪明。如果我走 A 步，对手可能会走 X、Y 或 Z。我会看 X、Y、Z 中哪个对我<strong>最不利</strong>（因为对手会选那个）。然后我在所有可能的 A、B、C 步中，选择那个“最坏情况中最好的”结果。</li></ul></blockquote><h4 id="Alpha-Beta-剪枝-Alpha-Beta-Pruning"><a href="#Alpha-Beta-剪枝-Alpha-Beta-Pruning" class="headerlink" title="Alpha-Beta 剪枝 (Alpha-Beta Pruning)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#alpha-beta-pruning">Alpha-Beta 剪枝 (Alpha-Beta Pruning)</a></h4><p>作为优化 <em>Minimax</em> 的一种方法，<strong>Alpha-Beta 剪枝</strong> 跳过一些明显不利的递归计算。在确定了一个动作的值之后，如果有初步证据表明随后的动作可能让对手获得比已经确定的动作更好的分数，那么就没有必要进一步调查这个动作了，因为它肯定比先前确定的那个更不有利。</p><p>这用一个例子最容易展示：一个最大化玩家知道，在下一步，最小化玩家将试图获得最低分。假设最大化玩家有三个可能的动作，第一个动作的值为 4。然后玩家开始生成下一个动作的值。为此，玩家生成如果当前玩家采取此动作后最小化玩家动作的值，知道最小化者会选择最低的那个。然而，在完成最小化玩家所有可能动作的计算之前，玩家看到其中一个选项的值为 3。这意味着没有理由继续探索最小化玩家的其他可能动作了。尚未估值的动作的值是多少并不重要，无论是 10 还是 (-10)。如果值为 10，最小化者会选择最低的选项 3，这已经比预先确定的 4 差了。如果尚未估值的动作结果是 (-10)，最小化者将选择这个选项 (-10)，这对最大化者来说更加不利。因此，此时计算最小化者的其他可能动作对最大化者来说是无关紧要的，因为最大化玩家已经有了一个明确更好的选择，其值为 4。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/alphabeta.png" alt="Alpha Beta Pruning"></p><blockquote><p><strong>🔍 [译者注释]</strong>：想象你在挑苹果，你想挑个最大的。</p><ul><li>第一筐里最小的苹果是 5 两重（所以这筐至少能给你 5 两）。</li><li>你开始看第二筐，拿起来第一个苹果是 3 两。</li><li><strong>剪枝</strong>：你不需要再看第二筐剩下的苹果了。因为你是最大化者（想要最大的），而这一步是对手（最小化者）在选。对手既然能在第二筐找到 3 两的，那他绝对不会让你在这一筐得到超过 3 两的结果。既然 3 两已经比第一筐的 5 两差了，第二筐就被你放弃了。</li></ul></blockquote><h4 id="深度受限-Minimax-Depth-Limited-Minimax"><a href="#深度受限-Minimax-Depth-Limited-Minimax" class="headerlink" title="深度受限 Minimax (Depth-Limited Minimax)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#depth-limited-minimax">深度受限 Minimax (Depth-Limited Minimax)</a></h4><p>井字棋共有 255,168 种可能的游戏过程，而国际象棋有 10²⁹⁰⁰⁰ 种可能的游戏。目前所介绍的 Minimax 算法需要生成从某一点到终端条件的所有假设游戏。虽然现代计算机计算所有井字棋游戏并不构成挑战，但对国际象棋这样做目前是不可能的。</p><p><strong>深度受限 Minimax</strong> 仅考虑预定义数量的步数后就停止，而不必到达终端状态。然而，这不允许为每个动作获得精确的值，因为尚未到达假设游戏的结尾。为了解决这个问题，<em>深度受限 Minimax</em> 依赖于一个 <strong>评估函数 (evaluation function)</strong>，该函数估计从给定状态开始的游戏的预期效用，换句话说，为状态赋值。例如，在国际象棋游戏中，效用函数将接收棋盘的当前配置作为输入，尝试评估其预期效用（基于每个玩家拥有的棋子及其在棋盘上的位置），然后返回一个正值或负值，表示该棋盘对一个玩家相对于另一个玩家的有利程度。这些值可用于决定正确的动作，评估函数越好，依赖它的 Minimax 算法就越好。</p><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li>这就是现实中下棋软件（如早期的“深蓝”）的工作原理。它算不了无限远，只能算往后 10 步或 20 步。</li><li><strong>评估函数</strong> 是关键：当我看不到结局时，我必须凭经验判断现在的局势是好是坏。例如：“我有皇后，对方没有，所以我这局势+9分”。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>讲义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序算法</title>
    <link href="/2025/12/25/DS/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2025/12/25/DS/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="🧩-归并排序（Merge-Sort）：分而治之的艺术"><a href="#🧩-归并排序（Merge-Sort）：分而治之的艺术" class="headerlink" title="🧩 归并排序（Merge Sort）：分而治之的艺术"></a>🧩 归并排序（Merge Sort）：分而治之的艺术</h1><p>归并排序的核心思想是：<strong>先拆分，后合并</strong>。<br>它将一个大数组不断二分，直到每个小数组只有一个元素（此时每个小数组都是有序的），然后将这些有序的小数组两两合并，最终得到完整的有序数组。<br><img src="/img/归并排序/2025-12-29-13-14-29.png" alt=""></p><h2 id="1-核心原理：两个阶段"><a href="#1-核心原理：两个阶段" class="headerlink" title="1. 核心原理：两个阶段"></a>1. 核心原理：两个阶段</h2><ol><li><strong>分（Divide）</strong>：找到数组的中点，把数组一分为二。递归地对左右两半进行同样的操作，直到数组长度为 1。</li><li><strong>治/合（Merge）</strong>：这是最关键的一步。将两个<strong>已经排好序</strong>的子数组合并成一个新的有序数组。</li></ol><h3 id="💡-生动比喻"><a href="#💡-生动比喻" class="headerlink" title="💡 生动比喻"></a>💡 生动比喻</h3><p>想象你要整理一副乱序的扑克牌：</p><ul><li><strong>分</strong>：你把牌堆不断对半切开，直到每个人手里都只拿<strong>一张牌</strong>（一张牌自然是有序的）。</li><li><strong>合</strong>：两个拿牌的人比较谁手里的牌小，谁先放在桌上。接着四个人的两组牌再进行比较合并……最终整副牌就排好了。</li></ul><hr><h2 id="2-核心语法与实现（Java）"><a href="#2-核心语法与实现（Java）" class="headerlink" title="2. 核心语法与实现（Java）"></a>2. 核心语法与实现（Java）</h2><p>归并排序通常使用<strong>递归</strong>来实现。我们需要一个辅助函数来执行“合并”操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前：&quot;</span> + Arrays.toString(arr));<br>        <br>        mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;排序后：&quot;</span> + Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-comment">// 递归拆分函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">// 找到中间索引，防止溢出的写法</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">// 递归拆分左半部分</span><br>            mergeSort(arr, left, mid);<br>            <span class="hljs-comment">// 递归拆分右半部分</span><br>            mergeSort(arr, mid + <span class="hljs-number">1</span>, right);<br><br>            <span class="hljs-comment">// 合并左右两部分</span><br>            merge(arr, left, mid, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 核心合并函数：将两个有序区间 [left, mid] 和 [mid+1, right] 合并</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建临时数组存放合并结果</span><br>        <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left;      <span class="hljs-comment">// 左子数组的起点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 右子数组的起点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;         <span class="hljs-comment">// 临时数组的索引</span><br><br>        <span class="hljs-comment">// 2. 比较两个子数组，谁小就谁进 temp</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) &#123;<br>                temp[k++] = arr[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp[k++] = arr[j++];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 将左边剩余元素放入 temp（如果有）</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            temp[k++] = arr[i++];<br>        &#125;<br><br>        <span class="hljs-comment">// 4. 将右边剩余元素放入 temp（如果有）</span><br>        <span class="hljs-keyword">while</span> (j &lt;= right) &#123;<br>            temp[k++] = arr[j++];<br>        &#125;<br><br>        <span class="hljs-comment">// 5. 把排好序的 temp 复制回原数组 arr</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; p &lt; temp.length; p++) &#123;<br>            arr[left + p] = temp[p];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3. 性能分析"></a>3. 性能分析</h2><ul><li><strong>时间复杂度</strong>：始终是 $O(n \log n)$。不管原数组是乱序还是已经排好序，它的表现都非常稳定。</li><li><strong>空间复杂度</strong>：$O(n)$。因为合并过程中需要一个和原数组一样大的临时数组。</li><li><strong>稳定性</strong>：<strong>稳定</strong>排序。在合并逻辑中，如果 <code>arr[i] == arr[j]</code>，我们先放左边的 <code>arr[i]</code>，保证了相同元素的相对顺序不变。</li></ul><hr><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ol><li><strong>大规模数据排序</strong>：当内存装不下所有数据时，归并排序的思想可以用于<strong>外部排序</strong>（从磁盘读入部分数据排序后再合并）。</li><li><strong>求逆序对</strong>：这是归并排序的一个典型算法变种题。</li><li><strong>链表排序</strong>：在 LeetCode 中，排序链表的最佳选择通常是归并排序，因为链表不需要连续的内存空间。</li></ol><hr><h2 id="⚠️-讲师提醒：新手易错点"><a href="#⚠️-讲师提醒：新手易错点" class="headerlink" title="⚠️ 讲师提醒：新手易错点"></a>⚠️ 讲师提醒：新手易错点</h2><ol><li><strong>递归终止条件</strong>：一定要写 <code>if (left &lt; right)</code>，否则会进入死循环（栈溢出）。</li><li><strong>中点计算</strong>：使用 <code>mid = left + (right - left) / 2</code> 能够有效避免 <code>(left + right)</code> 导致的整数溢出风险。</li><li><strong>区间闭合</strong>：合并时注意 <code>while (i &lt;= mid)</code> 的等于号，漏掉会导致数组元素丢失。</li></ol>]]></content>
    
    
    <categories>
      
      <category>DS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数组常用API</title>
    <link href="/2025/12/24/JavaSE/Java%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8API/"/>
    <url>/2025/12/24/JavaSE/Java%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h1 id="🚀-Java-进阶：数组常用-API-与经典操作实战"><a href="#🚀-Java-进阶：数组常用-API-与经典操作实战" class="headerlink" title="🚀 Java 进阶：数组常用 API 与经典操作实战"></a>🚀 Java 进阶：数组常用 API 与经典操作实战</h1><blockquote><p><strong>导读</strong>：<br>这一节我们将解锁 Java 数组的“瑞士军刀”——<code>java.util.Arrays</code> 类，它可以让你一行代码搞定排序、查找和打印。<br>同时，我们也会深入底层，手写几个经典的数组算法（如反转、扩容），这是理解数据结构逻辑的关键。</p></blockquote><hr><h2 id="第一部分：Java-数组的“瑞士军刀”-常用-API"><a href="#第一部分：Java-数组的“瑞士军刀”-常用-API" class="headerlink" title="第一部分：Java 数组的“瑞士军刀” (常用 API)"></a>第一部分：Java 数组的“瑞士军刀” (常用 API)</h2><p>Java 官方为了不让我们重复造轮子，提供了一个强大的工具类 <code>java.util.Arrays</code>。使用前请记得 <code>import java.util.Arrays;</code>。</p><h3 id="1-🔍-查看与打印：toString-amp-deepToString"><a href="#1-🔍-查看与打印：toString-amp-deepToString" class="headerlink" title="1. 🔍 查看与打印：toString() &amp; deepToString()"></a>1. 🔍 查看与打印：<code>toString()</code> &amp; <code>deepToString()</code></h3><p>直接打印数组变量只能看到内存地址，必须用这个方法才能看到“真面目”。</p><ul><li><strong>场景</strong>：调试代码，查看数组里的内容。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(Arrays.toString(arr)); <br><span class="hljs-comment">// 输出: [1, 2, 3]</span><br><br><span class="hljs-type">int</span>[][] matrix = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;;<br><span class="hljs-comment">// 注意：多维数组要用 deepToString，否则里面的数组还是显示地址</span><br>System.out.println(Arrays.deepToString(matrix)); <br><span class="hljs-comment">// 输出: [[1, 2], [3, 4]]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-🔢-排序：sort"><a href="#2-🔢-排序：sort" class="headerlink" title="2. 🔢 排序：sort()"></a>2. 🔢 排序：<code>sort()</code></h3><p>将数组元素按照从小到大（升序）排列。底层使用了双轴快速排序等高效算法。</p><ul><li><strong>场景</strong>：排行榜、数据整理。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] scores = &#123;<span class="hljs-number">88</span>, <span class="hljs-number">50</span>, <span class="hljs-number">99</span>, <span class="hljs-number">70</span>&#125;;<br>Arrays.sort(scores);<br>System.out.println(Arrays.toString(scores)); <br><span class="hljs-comment">// 输出: [50, 70, 88, 99] (自动变成有序了)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-🔎-查找：binarySearch-二分查找"><a href="#3-🔎-查找：binarySearch-二分查找" class="headerlink" title="3. 🔎 查找：binarySearch() (二分查找)"></a>3. 🔎 查找：<code>binarySearch()</code> (二分查找)</h3><p>在一个<strong>有序</strong>的数组中快速查找某个元素的位置。</p><ul><li><strong>⚠️ 注意</strong>：使用此方法前，<strong>必须先排序</strong>！如果数组是乱序的，结果不可预测。</li><li><p><strong>返回值</strong>：如果找到，返回索引；如果找不到，返回负数。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;; <span class="hljs-comment">// 必须是有序的</span><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums, <span class="hljs-number">30</span>);<br>System.out.println(<span class="hljs-string">&quot;30的下标是：&quot;</span> + index); <span class="hljs-comment">// 输出: 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">errorIndex</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums, <span class="hljs-number">25</span>);<br>System.out.println(<span class="hljs-string">&quot;找不存在的数：&quot;</span> + errorIndex); <span class="hljs-comment">// 输出负数 (例如 -3)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-👯-比较：equals"><a href="#4-👯-比较：equals" class="headerlink" title="4. 👯 比较：equals()"></a>4. 👯 比较：<code>equals()</code></h3><p>判断两个数组的<strong>内容</strong>是否完全一致（长度相同，且对应位置元素相同）。</p><ul><li><p><strong>注意</strong>：直接用 <code>==</code> 比较的是两个数组的内存地址，通常都是 <code>false</code>。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] arr2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>System.out.println(arr1 == arr2);       <span class="hljs-comment">// false (它是两个不同的对象)</span><br>System.out.println(Arrays.equals(arr1, arr2)); <span class="hljs-comment">// true (内容一样)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5-🛠-填充：fill"><a href="#5-🛠-填充：fill" class="headerlink" title="5. 🛠 填充：fill()"></a>5. 🛠 填充：<code>fill()</code></h3><p>快速把数组的所有位置（或指定范围）都填成同一个值。</p><ul><li><strong>场景</strong>：初始化游戏地图、重置数据。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>Arrays.fill(box, <span class="hljs-number">666</span>); <span class="hljs-comment">// 把整个数组都填满 666</span><br><span class="hljs-comment">// 输出: [666, 666, 666, 666, 666]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6-📋-复制与截取：copyOf-amp-copyOfRange"><a href="#6-📋-复制与截取：copyOf-amp-copyOfRange" class="headerlink" title="6. 📋 复制与截取：copyOf() &amp; copyOfRange()"></a>6. 📋 复制与截取：<code>copyOf()</code> &amp; <code>copyOfRange()</code></h3><ul><li><code>copyOf(原数组, 新长度)</code>：从头开始复制，可用于扩容或截断。</li><li><p><code>copyOfRange(原数组, start, end)</code>：复制中间某一段（含头不含尾）。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><br><span class="hljs-comment">// 复制前3个</span><br><span class="hljs-type">int</span>[] newArr = Arrays.copyOf(src, <span class="hljs-number">3</span>); <br><span class="hljs-comment">// 结果: [10, 20, 30]</span><br><br><span class="hljs-comment">// 扩容复制 (后面补默认值)</span><br><span class="hljs-type">int</span>[] bigArr = Arrays.copyOf(src, <span class="hljs-number">7</span>);<br><span class="hljs-comment">// 结果: [10, 20, 30, 40, 50, 0, 0]</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="⚡-补充：一个高效的底层-API"><a href="#⚡-补充：一个高效的底层-API" class="headerlink" title="⚡ 补充：一个高效的底层 API"></a>⚡ 补充：一个高效的底层 API</h2><p>在阅读 Java 源码时，你会经常看到 <code>System.arraycopy</code>。它是最底层的数组复制方法，性能极高（直接操作内存），但参数比较多，容易写错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法：</span><br><span class="hljs-comment">// System.arraycopy(原数组, 原数组起始位置, 目标数组, 目标数组起始位置, 复制多少个);</span><br><br><span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span>[] dest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">// 把 src 的后两个元素 (3,4) 复制到 dest 的开头</span><br>System.arraycopy(src, <span class="hljs-number">2</span>, dest, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br><br>System.out.println(Arrays.toString(dest)); <br><span class="hljs-comment">// 输出: [3, 4, 0, 0]</span><br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>日常开发</strong>：首选 <code>java.util.Arrays</code> 类，代码简洁，可读性高。</li><li><strong>性能敏感/底层开发</strong>：使用 <code>System.arraycopy</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JavaSE</tag>
      
      <tag>语法知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java生成随机数</title>
    <link href="/2025/12/24/JavaSE/Java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <url>/2025/12/24/JavaSE/Java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="🎲-Java-核心：生成随机数的-4-种姿势"><a href="#🎲-Java-核心：生成随机数的-4-种姿势" class="headerlink" title="🎲 Java 核心：生成随机数的 4 种姿势"></a>🎲 Java 核心：生成随机数的 4 种姿势</h1><blockquote><p><strong>导读</strong>：<br>并不是所有的随机数都是“真随机”。<br>在 Java 中，你需要根据你的应用场景（是写个小Demo，还是写银行支付系统）来选择不同的随机数生成器。</p></blockquote><hr><h2 id="1-简易入门：Math-random"><a href="#1-简易入门：Math-random" class="headerlink" title="1. 简易入门：Math.random()"></a>1. 简易入门：Math.random()</h2><h3 id="📖-概念定义"><a href="#📖-概念定义" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是 Java 最基础的工具类 <code>Math</code> 提供的一个静态方法。它不需要 <code>new</code> 对象，直接调用即可。</p><h3 id="⚙️-核心规则"><a href="#⚙️-核心规则" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>返回值</strong>：它固定返回一个 <code>0.0</code> (包含) 到 <code>1.0</code> (不包含) 之间的 <code>double</code> 小数。</li><li><strong>底层</strong>：其实它底层也是调用了 <code>java.util.Random</code>，只是做了一层简单的封装。</li></ul><h3 id="💻-代码示例"><a href="#💻-代码示例" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathRandomDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 基础用法：生成 0.0 ~ 1.0 之间的小数</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Math.random();<br>        System.out.println(<span class="hljs-string">&quot;随机小数: &quot;</span> + d);<br><br>        <span class="hljs-comment">// 2. 进阶用法：生成 [0, 100) 之间的整数</span><br>        <span class="hljs-comment">// 逻辑：先把 0.x 放大100倍，再强制转成 int 去掉小数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>);<br>        System.out.println(<span class="hljs-string">&quot;0到99的整数: &quot;</span> + num);<br><br>        <span class="hljs-comment">// 3. 必背公式：生成 [min, max] 之间的整数 (包含两端)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">// 公式：(int)(Math.random() * (最大值 - 最小值 + 1)) + 最小值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rangeNum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * (max - min + <span class="hljs-number">1</span>)) + min;<br>        System.out.println(<span class="hljs-string">&quot;50到100的整数: &quot;</span> + rangeNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景"><a href="#🚀-应用场景" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li>快速测试、简单的脚本。</li><li><strong>缺点</strong>：写区间公式太麻烦，容易算错。</li></ul><hr><h2 id="2-标准通用：java-util-Random"><a href="#2-标准通用：java-util-Random" class="headerlink" title="2. 标准通用：java.util.Random"></a>2. 标准通用：java.util.Random</h2><h3 id="📖-概念定义-1"><a href="#📖-概念定义-1" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是 Java 面向对象标准的随机数生成器。你需要先创建一个“骰子”对象，然后摇它。</p><h3 id="⚙️-核心规则-1"><a href="#⚙️-核心规则-1" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>灵活性</strong>：可以直接生成 <code>int</code>, <code>boolean</code>, <code>float</code> 等多种类型，不需要像 <code>Math.random</code> 那样手动转换。</li><li><strong>种子 (Seed)</strong>：如果你在 new 的时候传入一个固定的数字（种子），那么每次运行生成的随机数序列是<strong>一模一样</strong>的（常用于复现 Bug）。</li></ul><h3 id="💻-代码示例-1"><a href="#💻-代码示例-1" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UtilRandomDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建随机数对象 (不带种子，默认以当前时间为种子)</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>        <span class="hljs-comment">// 2. 生成各种类型的随机数</span><br>        System.out.println(<span class="hljs-string">&quot;随机布尔值: &quot;</span> + r.nextBoolean()); <span class="hljs-comment">// true 或 false</span><br>        System.out.println(<span class="hljs-string">&quot;随机Double: &quot;</span> + r.nextDouble()); <span class="hljs-comment">// 0.0 ~ 1.0</span><br><br>        <span class="hljs-comment">// 3. 最好用的方法：nextInt(bound)</span><br>        <span class="hljs-comment">// 生成 [0, 10) 之间的整数 (不包含10)</span><br>        <span class="hljs-comment">// 也就是 0 ~ 9</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>); <br>        System.out.println(<span class="hljs-string">&quot;0到9的整数: &quot;</span> + i);<br>        <br>        <span class="hljs-comment">// ------------------------------------</span><br>        <span class="hljs-comment">// 特殊情况：带种子的随机 (伪随机的真相)</span><br>        <span class="hljs-comment">// 只要种子一样，生成的随机数顺序永远一样</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">rFixed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">100</span>); <br>        System.out.println(<span class="hljs-string">&quot;固定随机数1: &quot;</span> + rFixed.nextInt(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 每次运行都是同一个数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-1"><a href="#🚀-应用场景-1" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li>大多数业务开发、游戏逻辑、模拟数据。</li></ul><hr><h2 id="3-高性能并发：ThreadLocalRandom-Java-7"><a href="#3-高性能并发：ThreadLocalRandom-Java-7" class="headerlink" title="3. 高性能并发：ThreadLocalRandom (Java 7+)"></a>3. 高性能并发：ThreadLocalRandom (Java 7+)</h2><h3 id="📖-概念定义-2"><a href="#📖-概念定义-2" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是为了解决多线程问题而生的工具。</p><h3 id="💡-通俗理解"><a href="#💡-通俗理解" class="headerlink" title="💡 通俗理解"></a>💡 通俗理解</h3><p><code>java.util.Random</code> 是线程安全的，但在多线程高并发时（比如 1000 个人同时去抢一个骰子），会产生<strong>竞争</strong>，导致性能下降。<br><code>ThreadLocalRandom</code> 相当于<strong>给每个线程发了一个专用的骰子</strong>，互不干扰，速度极快。</p><h3 id="💻-代码示例-2"><a href="#💻-代码示例-2" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TLRDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 注意：不能 new，要用 current() 获取当前线程的实例</span><br>        <span class="hljs-type">ThreadLocalRandom</span> <span class="hljs-variable">tlr</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current();<br><br>        <span class="hljs-comment">// 用法和 Random 几乎一样，但性能更高</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> tlr.nextInt(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 直接支持生成 [10, 20) 的范围，超方便！</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;10到19的整数: &quot;</span> + val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-2"><a href="#🚀-应用场景-2" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li><strong>高并发系统</strong>、多线程环境。</li><li>在 JDK 7 之后，<strong>强烈推荐</strong>在多线程能替代 <code>Random</code> 的地方都用这个。</li></ul><hr><h2 id="4-银行级安全：java-security-SecureRandom"><a href="#4-银行级安全：java-security-SecureRandom" class="headerlink" title="4. 银行级安全：java.security.SecureRandom"></a>4. 银行级安全：java.security.SecureRandom</h2><h3 id="📖-概念定义-3"><a href="#📖-概念定义-3" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>真·随机数生成器。前面的 <code>Random</code> 实际上是根据算法算出来的（伪随机），如果黑客知道了算法和种子，就能预测下一个数。<br><code>SecureRandom</code> 利用操作系统的随机源（如鼠标移动、键盘敲击、CPU热噪声等）来生成随机数。</p><h3 id="⚙️-核心规则-2"><a href="#⚙️-核心规则-2" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>不可预测性</strong>：极其难以被破解。</li><li><strong>性能</strong>：比普通的 Random 慢很多（因为生成过程很复杂）。</li></ul><h3 id="💻-代码示例-3"><a href="#💻-代码示例-3" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">sr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>        <br>        <span class="hljs-comment">// 用法和 Random 一样</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">passwordPart</span> <span class="hljs-operator">=</span> sr.nextInt(<span class="hljs-number">10000</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;安全随机数: &quot;</span> + passwordPart);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-3"><a href="#🚀-应用场景-3" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li><strong>生成密码、Token、Session ID、加密密钥</strong>。</li><li>凡是涉及到<strong>钱</strong>和<strong>安全</strong>的地方，严禁使用 <code>Math.random</code> 或 <code>Random</code>，必须用 <code>SecureRandom</code>。</li></ul><hr><h2 id="📝-总结：我该用哪个？"><a href="#📝-总结：我该用哪个？" class="headerlink" title="📝 总结：我该用哪个？"></a>📝 总结：我该用哪个？</h2><div class="table-container"><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">推荐方式</th><th style="text-align:left">理由</th></tr></thead><tbody><tr><td style="text-align:left"><strong>写个小Demo / 教学</strong></td><td style="text-align:left"><code>Math.random()</code></td><td style="text-align:left">代码最短，不用导包。</td></tr><tr><td style="text-align:left"><strong>一般业务 / 单线程</strong></td><td style="text-align:left"><code>java.util.Random</code></td><td style="text-align:left">API 丰富，符合直觉。</td></tr><tr><td style="text-align:left"><strong>高并发 / 多线程</strong></td><td style="text-align:left"><code>ThreadLocalRandom</code></td><td style="text-align:left"><strong>性能王者</strong>，不堵车。</td></tr><tr><td style="text-align:left"><strong>生成密码 / 涉及钱</strong></td><td style="text-align:left"><code>SecureRandom</code></td><td style="text-align:left"><strong>安全王者</strong>，黑客猜不到。</td></tr></tbody></table></div><h3 id="💡-讲师提示"><a href="#💡-讲师提示" class="headerlink" title="💡 讲师提示"></a>💡 讲师提示</h3><p>作为新手，你现阶段主要掌握 <strong><code>java.util.Random</code></strong> 就足够应对 90% 的学习场景了。但记住，等到以后做Web项目生成验证码时，一定要想起来用 <code>SecureRandom</code> 哦！</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JavaSE</tag>
      
      <tag>语法知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java为什么不用const</title>
    <link href="/2025/12/23/JavaSE/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8const/"/>
    <url>/2025/12/23/JavaSE/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8const/</url>
    
    <content type="html"><![CDATA[<p>在学习 Java 时，很多从 C++ 或 C# 转过来的小伙伴都会下意识地去找 <code>const</code>。但在 Java 中，情况有点特殊。</p><hr><h2 id="1-const：有名无实的“保留字”"><a href="#1-const：有名无实的“保留字”" class="headerlink" title="1. const：有名无实的“保留字”"></a>1. <code>const</code>：有名无实的“保留字”</h2><p><strong>概念定义</strong>：在 Java 中，<code>const</code> 被称为<strong>保留字（Reserved Word）</strong>，而不是<strong>关键字（Keyword）</strong>。</p><ul><li><strong>现状</strong>：它在 Java 源码中存在，但没有任何语法功能。</li><li><strong>规则</strong>：你不能用 <code>const</code> 来定义常量，同时你也<strong>不能</strong>用 <code>const</code> 作为你的变量名。</li><li><strong>为什么保留它？</strong>：主要是为了防止程序员在写 Java 时误用了 C++ 的习惯，或者为了将来可能的版本升级预留位置。</li></ul><hr><h2 id="2-真正的常量主角：final"><a href="#2-真正的常量主角：final" class="headerlink" title="2. 真正的常量主角：final"></a>2. 真正的常量主角：<code>final</code></h2><p><strong>概念定义</strong>：在 Java 中，如果你想定义一个“一旦赋值就不能改变”的量，必须使用关键字 <strong><code>final</code></strong>。</p><h3 id="核心规则："><a href="#核心规则：" class="headerlink" title="核心规则："></a>核心规则：</h3><ol><li><strong>不可变性</strong>：被 <code>final</code> 修饰的变量，只能被赋值一次，之后再尝试修改会直接报错。</li><li><strong>命名规范</strong>：Java 中的常量通常要求<strong>全部大写</strong>，多个单词之间用下划线 <code>_</code> 分隔（例如：<code>MAX_SPEED</code>）。</li><li><strong>修饰位置</strong>：<code>final</code> 既可以修饰局部变量，也可以修饰类成员变量。</li></ol><hr><h2 id="3-代码示例：如何正确定义常量"><a href="#3-代码示例：如何正确定义常量" class="headerlink" title="3. 代码示例：如何正确定义常量"></a>3. 代码示例：如何正确定义常量</h2><p>在实际开发中，我们通常结合 <code>static</code> 和 <code>final</code> 来定义一个全局常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstantDemo</span> &#123;<br>    <span class="hljs-comment">// 1. 类级别的全局常量（最常见用法）</span><br>    <span class="hljs-comment">// static 让它属于类，final 保证它不可变</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926535</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_LOGIN_ATTEMPTS</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 2. 局部常量</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <br>        <span class="hljs-comment">// age = 21; // ❌ 编译报错：无法为最终变量 age 分配值</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;圆周率是：&quot;</span> + PI);<br>        System.out.println(<span class="hljs-string">&quot;我的年龄是：&quot;</span> + age);<br>        <br>        <span class="hljs-comment">// 3. 错误示范（如果你非要用 const）</span><br>        <span class="hljs-comment">// int const = 10; // ❌ 编译报错：const 是保留字，不能用作标识符</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-final-与-const-的对比-Java-vs-其他语言"><a href="#4-final-与-const-的对比-Java-vs-其他语言" class="headerlink" title="4. final 与 const 的对比 (Java vs 其他语言)"></a>4. <code>final</code> 与 <code>const</code> 的对比 (Java vs 其他语言)</h2><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Java 的 <code>final</code></th><th style="text-align:left">C++/C# 的 <code>const</code></th></tr></thead><tbody><tr><td style="text-align:left"><strong>定义常量</strong></td><td style="text-align:left">✅ 完美支持</td><td style="text-align:left">✅ 完美支持</td></tr><tr><td style="text-align:left"><strong>运行期赋值</strong></td><td style="text-align:left">✅ 支持（可以在运行时计算值再锁定）</td><td style="text-align:left">❌ 通常要求编译期确定值</td></tr><tr><td style="text-align:left"><strong>修饰类/方法</strong></td><td style="text-align:left">✅ 可以（防止类被继承或方法被重写）</td><td style="text-align:left">❌ 通常只修饰变量</td></tr></tbody></table></div><h1 id="进阶笔记：Java-final-vs-C-C-const-的三大本质区别"><a href="#进阶笔记：Java-final-vs-C-C-const-的三大本质区别" class="headerlink" title="进阶笔记：Java final vs C++/C# const 的三大本质区别"></a>进阶笔记：Java <code>final</code> vs C++/C# <code>const</code> 的三大本质区别</h1><p>很多编程语言都有 <code>const</code>，但在 Java 中，<code>final</code> 承担了更多的职责。你提到的“运行期赋值”和“修饰类/方法”正是它的灵魂所在。</p><hr><h3 id="4-1-运行期赋值：不仅仅是“死板”的常量"><a href="#4-1-运行期赋值：不仅仅是“死板”的常量" class="headerlink" title="4.1. 运行期赋值：不仅仅是“死板”的常量"></a>4.1. 运行期赋值：不仅仅是“死板”的常量</h3><p>在 C# 等语言中，<code>const</code> 要求在<strong>编译时</strong>就确定值（比如 <code>3.14</code>）。但 Java 的 <code>final</code> 允许你在<strong>运行时</strong>再决定它的值，一旦定下来，就不再更改。</p><p><strong>比喻</strong>：<code>const</code> 是“出厂即刻字”，而 <code>final</code> 是“发货前才填写的终身快递单”。</p><p><strong>代码示例</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalRuntimeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 运行期赋值：每次运行，value 的值可能都不一样</span><br>        <span class="hljs-comment">// 但在同一个生命周期内，value 一旦被赋值就不能再改</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;本次运行确定的常量值：&quot;</span> + value);<br>        <br>        <span class="hljs-comment">// value = 200; // ❌ 依然会报错，因为它已经是 final 了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><strong>应用场景</strong>：比如根据用户的输入、数据库的查询结果、或者是当前系统的年份来初始化一个“只读变量”。</p><hr><h3 id="2-架构防线：修饰类与方法"><a href="#2-架构防线：修饰类与方法" class="headerlink" title="2. 架构防线：修饰类与方法"></a>2. 架构防线：修饰类与方法</h3><p>这是 <code>const</code> 完全无法触及的领域。在 Java 中，<code>final</code> 被用来保护代码的<strong>继承结构</strong>。</p><h4 id="A-修饰方法-Prevent-Overriding"><a href="#A-修饰方法-Prevent-Overriding" class="headerlink" title="A. 修饰方法 (Prevent Overriding)"></a>A. 修饰方法 (Prevent Overriding)</h4><p><strong>规则</strong>：父类的方法被 <code>final</code> 修饰后，子类<strong>不能重写</strong>它。<br><strong>意义</strong>：锁定核心逻辑，防止子类“乱改”导致逻辑崩溃。</p><h4 id="B-修饰类-Prevent-Inheritance"><a href="#B-修饰类-Prevent-Inheritance" class="headerlink" title="B. 修饰类 (Prevent Inheritance)"></a>B. 修饰类 (Prevent Inheritance)</h4><p><strong>规则</strong>：类被 <code>final</code> 修饰后，<strong>不能被继承</strong>。<br><strong>意义</strong>：比如 <code>String</code> 类就是 <code>final</code> 的。如果人人都能继承并修改 <code>String</code> 的行为，整个 Java 世界就乱套了。</p><p><strong>代码示例</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是一个 final 类，不能有“儿子”</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecuritySystem</span> &#123;<br>    <br>    <span class="hljs-comment">// 这是一个 final 方法，子类即便能继承（如果类不是 final），也不能修改</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verifyIdentity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行极其严格的身份核验逻辑，禁止修改！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class HackSystem extends SecuritySystem &#123; &#125; // ❌ 报错：无法从最终类继承</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="3-深度对比表：为什么-final-比-const-更强大？"><a href="#3-深度对比表：为什么-final-比-const-更强大？" class="headerlink" title="3. 深度对比表：为什么 final 比 const 更强大？"></a>3. 深度对比表：为什么 <code>final</code> 比 <code>const</code> 更强大？</h3><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Java <code>final</code></th><th style="text-align:left">典型 <code>const</code> (如 C#)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>赋值时机</strong></td><td style="text-align:left"><strong>编译期 或 运行期</strong></td><td style="text-align:left">通常只能是 <strong>编译期</strong></td></tr><tr><td style="text-align:left"><strong>修饰变量</strong></td><td style="text-align:left">✅ 锁定引用/值</td><td style="text-align:left">✅ 锁定值</td></tr><tr><td style="text-align:left"><strong>修饰类</strong></td><td style="text-align:left">✅ 禁止继承</td><td style="text-align:left">❌ 不支持 (C# 用 <code>sealed</code>)</td></tr><tr><td style="text-align:left"><strong>修饰方法</strong></td><td style="text-align:left">✅ 禁止重写</td><td style="text-align:left">❌ 不支持</td></tr><tr><td style="text-align:left"><strong>对象控制</strong></td><td style="text-align:left">只能锁定“盒子”不换，不能锁“内容”</td><td style="text-align:left">深度锁定（C++ 的 const 语义更强）</td></tr></tbody></table></div><hr><h3 id="4-重点避坑：引用不变-vs-内容不变"><a href="#4-重点避坑：引用不变-vs-内容不变" class="headerlink" title="4. 重点避坑：引用不变 vs 内容不变"></a>4. 重点避坑：引用不变 vs 内容不变</h3><p>这是新手最容易掉坑的地方：<strong><code>final</code> 修饰对象时，只是锁定了“地址”，没锁定“属性”。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>user.setName(<span class="hljs-string">&quot;Jerry&quot;</span>); <span class="hljs-comment">// ✅ 允许！内容可以变</span><br><span class="hljs-comment">// user = new User(&quot;Jack&quot;); // ❌ 报错！不能把 user 指向新对象</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>javatomd 总结</strong>：</p><h2 id="C-等语言追求的是“数据的绝对不可变”（Const-correctness），而-Java-的-final-追求的是-“引用的稳定性”-和-“架构的安全性”。"><a href="#C-等语言追求的是“数据的绝对不可变”（Const-correctness），而-Java-的-final-追求的是-“引用的稳定性”-和-“架构的安全性”。" class="headerlink" title="C++ 等语言追求的是“数据的绝对不可变”（Const-correctness），而 Java 的 final 追求的是 “引用的稳定性” 和 “架构的安全性”。"></a>C++ 等语言追求的是“数据的绝对不可变”（Const-correctness），而 Java 的 <code>final</code> 追求的是 <strong>“引用的稳定性”</strong> 和 <strong>“架构的安全性”</strong>。</h2></blockquote><h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><ul><li><strong>固定配置</strong>：如数据库连接地址、API 的基础 URL。</li><li><strong>数学常数</strong>：如 $\pi$、自然对数 $e$ 等。</li><li><strong>业务逻辑限制</strong>：如订单的最大重试次数、用户的最小注册年龄。</li></ul><blockquote><p><strong>javatomd 总结</strong>：<br>记住一句话：<strong>在 Java 里想定义常量，请把 <code>final</code> 请出来，让 <code>const</code> 继续在角落里吃灰吧！</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo每次一定要“三件套”吗？</title>
    <link href="/2025/12/22/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%AF%8F%E6%AC%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E2%80%9C%E4%B8%89%E4%BB%B6%E5%A5%97%E2%80%9D%E5%90%97%EF%BC%9F/"/>
    <url>/2025/12/22/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%AF%8F%E6%AC%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E2%80%9C%E4%B8%89%E4%BB%B6%E5%A5%97%E2%80%9D%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>很多新手在开始使用 Hexo 时，习惯性地每次修改都执行 <code>hexo clean</code>, <code>hexo g</code>, <code>hexo s</code>。但在实际开发和写作中，这样做非常浪费时间。以下是根据不同场景推荐的最佳工作流，帮你把时间花在写作上，而不是等待编译。</p><h2 id="1-场景一：日常写文章-修改内容（最常见）"><a href="#1-场景一：日常写文章-修改内容（最常见）" class="headerlink" title="1. 场景一：日常写文章 / 修改内容（最常见）"></a>1. 场景一：日常写文章 / 修改内容（最常见）</h2><p><strong>场景描述</strong>：你在 <code>source/_posts</code> 下新建了一个 <code>.md</code>，或者修改了已有的文章内容、错别字。</p><ul><li><strong>是否需要三连？</strong>：<strong>完全不需要。</strong></li><li><strong>最佳操作</strong>：<ol><li>保持终端里的 <code>hexo s</code> 运行着不要关闭。</li><li>在编辑器里直接修改并保存 <code>.md</code> 文件。</li><li><strong>直接刷新浏览器页面</strong>。</li></ol></li><li><strong>原理</strong>：<code>hexo s</code> 带有“局部监听”功能，它会自动检测 <code>source</code> 文件夹的变化并实时渲染，速度极快。</li></ul><h2 id="2-场景二：修改了配置文件"><a href="#2-场景二：修改了配置文件" class="headerlink" title="2. 场景二：修改了配置文件"></a>2. 场景二：修改了配置文件</h2><p><strong>场景描述</strong>：你修改了根目录的 <code>_config.yml</code> 或主题的 <code>_config.fluid.yml</code>（例如改了网站标题、换了封面图路径）。</p><ul><li><strong>是否需要三连？</strong>：<strong>建议重启并 Clean。</strong></li><li><strong>最佳操作</strong>：<ol><li>在终端按下 <code>Ctrl + C</code> 关闭当前预览服务。</li><li>执行 <code>hexo clean</code>（确保清除旧的配置缓存）。</li><li>执行 <code>hexo s</code> 重新启动。</li></ol></li><li><strong>原理</strong>：配置文件只在服务器启动的一瞬间被读取，热重载通常无法捕捉到这些全局参数的变化。</li></ul><h2 id="3-场景三：删除了文件或移动了文件夹"><a href="#3-场景三：删除了文件或移动了文件夹" class="headerlink" title="3. 场景三：删除了文件或移动了文件夹"></a>3. 场景三：删除了文件或移动了文件夹</h2><p><strong>场景描述</strong>：你删除了某篇旧文章，或者把 <code>source/img</code> 里的图片重命名了。</p><ul><li><strong>是否需要三连？</strong>：<strong>必须执行。</strong></li><li><strong>原因</strong>：如果不执行 <code>clean</code>，<code>public</code>（生成的静态文件夹）里还会残留以前生成的旧文件。这会导致预览时出现已经删掉的文章依然存在，或者图片出现 404 的情况。</li></ul><h2 id="4-场景四：发布到正式环境（如-GitHub-Pages）"><a href="#4-场景四：发布到正式环境（如-GitHub-Pages）" class="headerlink" title="4. 场景四：发布到正式环境（如 GitHub Pages）"></a>4. 场景四：发布到正式环境（如 GitHub Pages）</h2><p><strong>场景描述</strong>：你在本地预览一切完美，准备部署上线。</p><ul><li><strong>最佳操作</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo d  <span class="hljs-comment"># 部署命令</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="⚡-提高效率的小技巧"><a href="#⚡-提高效率的小技巧" class="headerlink" title="⚡ 提高效率的小技巧"></a>⚡ 提高效率的小技巧</h2><h3 id="1-复合命令"><a href="#1-复合命令" class="headerlink" title="1. 复合命令"></a>1. 复合命令</h3><p>你可以用 <code>&amp;&amp;</code> 符号把命令连起来，输入一次回车，电脑会自动按顺序执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改了配置想重启预览</span><br>hexo clean &amp;&amp; hexo s<br><br><span class="hljs-comment"># 准备一键部署</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure></p><h3 id="2-什么时候才必须用-clean？"><a href="#2-什么时候才必须用-clean？" class="headerlink" title="2. 什么时候才必须用 clean？"></a>2. 什么时候才必须用 <code>clean</code>？</h3><ul><li><p>修改了主题的源码（如 CSS 或 JS 文件）。</p></li><li><p>发现网页显示莫名其妙。</p></li><li><p>在准备提交发布（<code>hexo d</code>）之前。</p></li></ul><hr><p><strong>总结</strong>：<strong>写文只需 <code>Ctrl + S</code> + 刷新；改配置才需要 <code>Clean</code> 重启。</strong> </p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>教程</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 主题更换Fluid</title>
    <link href="/2025/12/22/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2Fluid%E4%B8%BB%E9%A2%98/"/>
    <url>/2025/12/22/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%8D%A2Fluid%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天对 Hexo 博客进行了“大整容”，将默认主题更换为了 <strong>Fluid</strong>。过程中由于安装方式和文件路径问题踩了不少坑，现将完整的更换流程与解决方案总结如下。</p><h2 id="1-主题更换流程"><a href="#1-主题更换流程" class="headerlink" title="1 主题更换流程"></a>1 主题更换流程</h2><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">主题官网</a></p><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 安装主题</h3><p>按照官网教程，Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><br>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><h3 id="1-2-配置文件初始化"><a href="#1-2-配置文件初始化" class="headerlink" title="1.2. 配置文件初始化"></a>1.2. 配置文件初始化</h3><p>由于 <code>themes</code> 文件夹为空，需要在博客根目录下手动创建 <strong><code>_config.fluid.yml</code></strong>。<br><strong>关键点</strong>：可以前往 Fluid 官方 GitHub 仓库复制完整的<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">配置模板内容</a>并粘贴进 <strong><code>_config.fluid.yml</code></strong>。</p><h2 id="2-标题修改"><a href="#2-标题修改" class="headerlink" title="2. 标题修改"></a>2. 标题修改</h2><p>标题分为三个层级：浏览器标签页标题、导航栏文字、封面大标题。</p><h3 id="2-1-浏览器标签页标题-Browser-Tab-Title"><a href="#2-1-浏览器标签页标题-Browser-Tab-Title" class="headerlink" title="2.1 浏览器标签页标题 (Browser Tab Title)"></a>2.1 浏览器标签页标题 (Browser Tab Title)</h3><p>这是显示在浏览器最顶端标签上的文字。</p><ul><li><strong>修改文件</strong>：根目录下的 <code>_config.yml</code> (全局配置)。</li><li><strong>操作</strong>：修改 <code>title</code> 字段。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># _config.yml</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">大雪深埋</span>  <span class="hljs-comment"># 这里的修改会直接改变浏览器标签页显示的内容</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="3-首页封面-Banner-修改"><a href="#3-首页封面-Banner-修改" class="headerlink" title="3. 首页封面 (Banner) 修改"></a>3. 首页封面 (Banner) 修改</h2><h3 id="3-1-封面背景图修改-banner-img"><a href="#3-1-封面背景图修改-banner-img" class="headerlink" title="3.1 封面背景图修改 (banner_img)"></a>3.1 封面背景图修改 (banner_img)</h3><p>这是最容易踩坑的地方，涉及路径和存放位置。</p><ul><li><strong>正确存放</strong>：将图片放入 <code>source/img/</code>（例如 <code>guts.png</code>）。</li><li><strong>路径配置</strong>：在 <code>_config.fluid.yml</code> 中搜索 <code>banner_img</code>。</li><li><strong>注意事项</strong>：必须使用<strong>正斜杠 <code>/</code></strong>。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># _config.fluid.yml</span><br><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/guts.png</span>  <span class="hljs-comment"># 路径必须从 /img 开始</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-问题——封面图消失"><a href="#4-问题——封面图消失" class="headerlink" title="4.问题——封面图消失"></a>4.问题——封面图消失</h2><p>在配置 <code>banner_img</code> 封面图时遇到了图片在预览时消失的问题，总结原因如下：</p><ul><li><strong>存放路径错误</strong>：图片不能直接放在 <code>public</code> 文件夹中，因为每次执行 <code>hexo clean</code> 时，该文件夹都会被清空。</li><li><strong>正确位置</strong>：必须将图片存放在 <strong><code>source/img/</code></strong> 文件夹下，由 Hexo 编译后自动同步到 public 目录。</li><li><strong>路径语法限制</strong>：在配置文件中，路径必须使用<strong>正斜杠 <code>/</code></strong>（例如 <code>/img/guts.png</code>），不能使用 Windows 风格的反斜杠 <code>\</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo和GitHub搭建博客全记录</title>
    <link href="/2025/12/21/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/12/21/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>确保你的电脑环境已经安装了以下软件：</p><ul><li><strong>Node.js</strong>: 建议安装 LTS 版本。</li><li><strong>Git</strong>: 用于将代码推送到 GitHub。</li></ul><h2 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h2><p>在终端依次输入以下命令进行初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全局安装脚手架</span><br>npm install -g hexo-cli<br><br><span class="hljs-comment"># 初始化项目文件夹</span><br>hexo init myblog<br><span class="hljs-built_in">cd</span> myblog<br><br><span class="hljs-comment"># 安装依赖</span><br>npm install<br></code></pre></td></tr></table></figure><h2 id="3-联动-GitHub-关键步骤"><a href="#3-联动-GitHub-关键步骤" class="headerlink" title="3. 联动 GitHub (关键步骤)"></a>3. 联动 GitHub (关键步骤)</h2><p>在本地搭建好 Hexo 后，需要通过以下配置将其发布到 GitHub。</p><h3 id="3-1-创建-GitHub-仓库"><a href="#3-1-创建-GitHub-仓库" class="headerlink" title="3.1 创建 GitHub 仓库"></a>3.1 创建 GitHub 仓库</h3><ol><li><p>登录 GitHub，新建一个仓库（New repository）。</p></li><li><p><strong>仓库名（Repository Name）</strong> 必须填：<code>你的用户名.github.io</code>。</p></li><li><p>确保仓库设为 <strong>Public</strong>。</p></li></ol><h3 id="3-2-安装-Git-部署插件"><a href="#3-2-安装-Git-部署插件" class="headerlink" title="3.2 安装 Git 部署插件"></a>3.2 安装 Git 部署插件</h3><p>在你的博客根目录（<code>myblog</code>）下运行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="3-3-修改站点配置文件"><a href="#3-3-修改站点配置文件" class="headerlink" title="3.3 修改站点配置文件"></a>3.3 修改站点配置文件</h3><p>打开目录下的 <code>_config.yml</code> 文件，拉到最底部，修改 <code>deploy</code> 部分：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:你的用户名/你的用户名.github.io.git<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：YAML 格式要求冒号 <code>:</code> 后必须留一个空格。建议使用 SSH 链接以避免频繁输入密码。</p></blockquote><h2 id="4-遇到的坑与解决方法"><a href="#4-遇到的坑与解决方法" class="headerlink" title="4. 遇到的坑与解决方法"></a>4. 遇到的坑与解决方法</h2><h3 id="问题一：无法连接-GitHub"><a href="#问题一：无法连接-GitHub" class="headerlink" title="问题一：无法连接 GitHub"></a>问题一：无法连接 GitHub</h3><p>报错信息：fatal: unable to access … Failed to connect to port 443</p><p>解决方法：</p><p>这是因为网络问题导致无法直接访问 GitHub。如果你有代理服务器（例如端口是 10808），可以设置 Git 全局代理：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-selector-attr">[http://127.0.0.1:10808]</span>(http:<span class="hljs-comment">//127.0.0.1:10808)</span><br>git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-selector-attr">[https://127.0.0.1:10808]</span>(https:<span class="hljs-comment">//127.0.0.1:10808)</span><br></code></pre></td></tr></table></figure><h3 id="问题二：部署后-404-或样式乱码"><a href="#问题二：部署后-404-或样式乱码" class="headerlink" title="问题二：部署后 404 或样式乱码"></a>问题二：部署后 404 或样式乱码</h3><p><strong>原因</strong>：</p><ol><li><p>仓库设为了 Private（私有）。</p></li><li><p>_config.yml 中的 url 配置不正确。</p><p> 解决方法：</p></li><li><p>进入 GitHub 仓库 Settings -&gt; Danger Zone -&gt; Change visibility，改为 <strong>Public</strong>。</p></li><li><p>检查 <code>_config.yml</code> 中的 <code>url</code> 是否填写的为 <code>https://你的用户名.github.io</code>。</p></li></ol><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5. 常用命令"></a>5. 常用命令</h2><p>每次更新博客只需要这三步：</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>命令</strong></td><td><strong>作用</strong></td><td><strong>简写</strong></td></tr><tr><td><code>hexo clean</code></td><td>清除缓存（推荐部署前执行）</td><td>无</td></tr><tr><td><code>hexo generate</code></td><td>生成静态网页文件</td><td><code>hexo g</code></td></tr><tr><td><code>hexo server</code></td><td>启动本地预览（localhost:4000）</td><td><code>hexo s</code></td></tr><tr><td><code>hexo deploy</code></td><td>推送到 GitHub 线上</td><td><code>hexo d</code></td></tr></tbody></table></div><p><strong>标准发布流程：</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
