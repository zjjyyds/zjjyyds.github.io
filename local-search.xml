<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS50 AI project0 Tic-Tac-Toe</title>
    <link href="/2026/01/24/CS50AI-Project1-%20Minesweeper/"/>
    <url>/2026/01/24/CS50AI-Project1-%20Minesweeper/</url>
    
    <content type="html"><![CDATA[<h1 id="Minesweeper-——-CS50《使用-Python-的人工智能导论》"><a href="#Minesweeper-——-CS50《使用-Python-的人工智能导论》" class="headerlink" title="Minesweeper —— CS50《使用 Python 的人工智能导论》"></a>Minesweeper —— CS50《使用 Python 的人工智能导论》</h1><p>编写一个 <strong>可以自动玩扫雷（Minesweeper）的人工智能程序</strong>。</p><hr><h2 id="🕒-完成时间（When-to-Do-It）"><a href="#🕒-完成时间（When-to-Do-It）" class="headerlink" title="🕒 完成时间（When to Do It）"></a>🕒 完成时间（When to Do It）</h2><p><strong>截止时间：</strong></p><p>📅 <strong>2026 年 7 月 1 日（星期三）上午 7:59（GMT+8）</strong></p><hr><h2 id="🆘-如何获取帮助（How-to-Get-Help）"><a href="#🆘-如何获取帮助（How-to-Get-Help）" class="headerlink" title="🆘 如何获取帮助（How to Get Help）"></a>🆘 如何获取帮助（How to Get Help）</h2><ol><li>通过 <strong>Ed Discussion</strong> 提问  </li><li>通过任意一个 <strong>CS50 官方社区</strong></li></ol><hr><h2 id="📘-背景（Background）"><a href="#📘-背景（Background）" class="headerlink" title="📘 背景（Background）"></a>📘 背景（Background）</h2><h3 id="Minesweeper（扫雷）"><a href="#Minesweeper（扫雷）" class="headerlink" title="Minesweeper（扫雷）"></a>Minesweeper（扫雷）</h3><p>扫雷是一种经典的逻辑益智游戏，由一个由格子组成的网格构成，其中：</p><ul><li>某些格子中隐藏着 <strong>地雷（mines）</strong></li><li>点击含有地雷的格子会：<ul><li>引爆地雷</li><li>游戏失败</li></ul></li><li>点击一个 <strong>安全格子</strong>（没有地雷）会显示一个数字</li></ul><p>这个数字表示：</p><blockquote><p><strong>该格子周围 8 个相邻格子中，有多少个地雷</strong></p></blockquote><p>邻居格子的定义包括：</p><ul><li>上、下、左、右</li><li>四个对角方向</li></ul><hr><h3 id="游戏界面示例"><a href="#游戏界面示例" class="headerlink" title="游戏界面示例"></a>游戏界面示例</h3><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/game.png" alt="Minesweeper Game"></p><hr><h3 id="数字含义示例"><a href="#数字含义示例" class="headerlink" title="数字含义示例"></a>数字含义示例</h3><p>在下面这个 3×3 的棋盘中：</p><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/safe_cells.png" alt="Sample safe cell numbers"></p><ul><li>数字 <code>1</code> 表示周围 <strong>有 1 个地雷</strong></li><li>数字 <code>0</code> 表示周围 <strong>没有任何地雷</strong></li></ul><p>通过这些信息，具有逻辑推理能力的玩家可以判断：</p><ul><li>右下角格子 <strong>一定是地雷</strong></li><li>左上角格子 <strong>一定是安全的</strong></li></ul><p>否则，其余数字将无法成立。</p><hr><h3 id="🎯-游戏目标"><a href="#🎯-游戏目标" class="headerlink" title="🎯 游戏目标"></a>🎯 游戏目标</h3><blockquote><p><strong>找出并标记棋盘上的所有地雷。</strong></p></blockquote><p>在本项目中：</p><ul><li>玩家（或 AI）可以通过右键点击格子来标记地雷。</li></ul><hr><h2 id="🧠-命题逻辑（Propositional-Logic）"><a href="#🧠-命题逻辑（Propositional-Logic）" class="headerlink" title="🧠 命题逻辑（Propositional Logic）"></a>🧠 命题逻辑（Propositional Logic）</h2><p>在本项目中，你的目标是：</p><blockquote><p><strong>构建一个可以通过逻辑推理来玩扫雷的 AI。</strong></p></blockquote><p>回顾课堂内容：</p><ul><li>知识型智能体（Knowledge-Based Agent）</li><li>通过维护一个 <strong>知识库（Knowledge Base）</strong></li><li>利用逻辑推理做出决策</li></ul><hr><h3 id="如何表示扫雷中的知识？"><a href="#如何表示扫雷中的知识？" class="headerlink" title="如何表示扫雷中的知识？"></a>如何表示扫雷中的知识？</h3><p>我们可以将：</p><blockquote><p><strong>棋盘上的每一个格子视为一个命题变量</strong></p></blockquote><ul><li>若该格子是地雷 → 命题为 <code>True</code></li><li>若不是地雷 → 命题为 <code>False</code></li></ul><hr><h3 id="AI-可以获得哪些信息？"><a href="#AI-可以获得哪些信息？" class="headerlink" title="AI 可以获得哪些信息？"></a>AI 可以获得哪些信息？</h3><p>当 AI 点击一个安全格子时，会看到一个数字。</p><p>例如：</p><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/middle_safe.png" alt="Middle cell with labeled neighbors"></p><p>假设中间格子显示为 <code>1</code>。</p><p>这意味着：</p><blockquote><p>在 A～H 八个相邻格子中，<strong>恰好有 1 个是地雷</strong>。</p></blockquote><hr><h3 id="最弱的逻辑表达"><a href="#最弱的逻辑表达" class="headerlink" title="最弱的逻辑表达"></a>最弱的逻辑表达</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Or(A, B, C, D, E, F, G, H)<br></code></pre></td></tr></table></figure><p>表示：</p><blockquote><p>至少有一个格子是地雷。</p></blockquote><p>但这还不够精确。</p><hr><h3 id="正确含义：恰好一个"><a href="#正确含义：恰好一个" class="headerlink" title="正确含义：恰好一个"></a>正确含义：<strong>恰好一个</strong></h3><p>逻辑上真正的含义应为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">Or(<br>    And(A, Not(B), Not(C), Not(D), Not(E), Not(F), Not(G), Not(H)),<br>    And(Not(A), B, Not(C), Not(D), Not(E), Not(F), Not(G), Not(H)),<br>    And(Not(A), Not(B), C, Not(D), Not(E), Not(F), Not(G), Not(H)),<br>    And(Not(A), Not(B), Not(C), D, Not(E), Not(F), Not(G), Not(H)),<br>    And(Not(A), Not(B), Not(C), Not(D), E, Not(F), Not(G), Not(H)),<br>    And(Not(A), Not(B), Not(C), Not(D), Not(E), F, Not(G), Not(H)),<br>    And(Not(A), Not(B), Not(C), Not(D), Not(E), Not(F), G, Not(H)),<br>    And(Not(A), Not(B), Not(C), Not(D), Not(E), Not(F), Not(G), H)<br>)<br></code></pre></td></tr></table></figure><p>仅仅表达数字 <code>1</code> 就如此复杂。</p><p>如果是 <code>2</code>、<code>3</code>，复杂度会急剧上升。</p><hr><h3 id="🚫-模型检测不可行"><a href="#🚫-模型检测不可行" class="headerlink" title="🚫 模型检测不可行"></a>🚫 模型检测不可行</h3><p>在一个 8×8 的棋盘中：</p><ul><li>有 64 个格子</li><li>可能模型数量为：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>^<span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p>这在现实中是完全不可计算的。</p><hr><h2 id="✅-更高效的知识表示方法"><a href="#✅-更高效的知识表示方法" class="headerlink" title="✅ 更高效的知识表示方法"></a>✅ 更高效的知识表示方法</h2><p>我们使用如下形式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;A, B, C, D, E, F, G, H&#125; = 1<br></code></pre></td></tr></table></figure><p>含义：</p><blockquote><p>在这些格子中，<strong>恰好有 1 个地雷</strong>。</p></blockquote><hr><h3 id="每条知识句子包含："><a href="#每条知识句子包含：" class="headerlink" title="每条知识句子包含："></a>每条知识句子包含：</h3><ul><li><code>cells</code>：涉及的格子集合</li><li><code>count</code>：其中地雷的数量</li></ul><hr><h3 id="🔍-推理规则一：count-0"><a href="#🔍-推理规则一：count-0" class="headerlink" title="🔍 推理规则一：count = 0"></a>🔍 推理规则一：count = 0</h3><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/infer_safe.png" alt="infer safe"></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">D</span><span class="hljs-operator">,</span> <span class="hljs-built_in">E</span><span class="hljs-operator">,</span> <span class="hljs-variable">G</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>所有格子都是安全的。</p></blockquote><hr><h3 id="🔥-推理规则二：cells-数量-count"><a href="#🔥-推理规则二：cells-数量-count" class="headerlink" title="🔥 推理规则二：cells 数量 = count"></a>🔥 推理规则二：cells 数量 = count</h3><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/infer_mines.png" alt="infer mines"></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;E, F, H&#125;</span><span class="language-xml"> = 3</span><br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>E、F、H 全部是地雷。</p></blockquote><hr><h3 id="🔄-更新已有知识"><a href="#🔄-更新已有知识" class="headerlink" title="🔄 更新已有知识"></a>🔄 更新已有知识</h3><p>若已知：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-keyword">A</span>, B, C&#125; = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li>若 C 是安全的：</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-keyword">A</span>, B&#125; = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li>若 C 是地雷：</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-keyword">A</span>, B&#125; = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><hr><h3 id="⭐-子集推理（最关键）"><a href="#⭐-子集推理（最关键）" class="headerlink" title="⭐ 子集推理（最关键）"></a>⭐ 子集推理（最关键）</h3><p><img src="https://cs50.harvard.edu/ai/projects/1/minesweeper/images/subset_inference.png" alt="subset inference"></p><p>若：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">A</span><span class="hljs-operator">,</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">A</span><span class="hljs-operator">,</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-operator">,</span> <span class="hljs-built_in">D</span><span class="hljs-operator">,</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>则可推出：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">D</span><span class="hljs-operator">,</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><hr><h3 id="通用推理规则"><a href="#通用推理规则" class="headerlink" title="通用推理规则"></a>通用推理规则</h3><p>如果：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">set</span>1 ⊆ <span class="hljs-keyword">set</span>2<br></code></pre></td></tr></table></figure><p>那么：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">set</span>2 - <span class="hljs-keyword">set</span>1 = count2 - count1<br></code></pre></td></tr></table></figure><hr><h2 id="🚀-Getting-Started"><a href="#🚀-Getting-Started" class="headerlink" title="🚀 Getting Started"></a>🚀 Getting Started</h2><ol><li>下载项目代码：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>cdn.cs50.net<span class="hljs-regexp">/ai/</span><span class="hljs-number">2023</span><span class="hljs-regexp">/x/</span>projects<span class="hljs-regexp">/1/mi</span>nesweeper.zip<br></code></pre></td></tr></table></figure><ol><li>安装依赖：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install -r requirements.txt<br></code></pre></td></tr></table></figure><p>（主要依赖：<code>pygame</code>）</p><hr><h2 id="📂-项目结构（Understanding）"><a href="#📂-项目结构（Understanding）" class="headerlink" title="📂 项目结构（Understanding）"></a>📂 项目结构（Understanding）</h2><h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><ul><li><p><code>runner.py</code></p><ul><li>游戏界面（已完成）</li></ul></li><li><p><code>minesweeper.py</code></p><ul><li>游戏逻辑</li><li>AI 推理系统（你需要完成）</li></ul></li></ul><hr><h3 id="minesweeper-py-中的三个类"><a href="#minesweeper-py-中的三个类" class="headerlink" title="minesweeper.py 中的三个类"></a>minesweeper.py 中的三个类</h3><h4 id="1️⃣-Minesweeper"><a href="#1️⃣-Minesweeper" class="headerlink" title="1️⃣ Minesweeper"></a>1️⃣ Minesweeper</h4><p>负责棋盘逻辑（已完成）</p><hr><h4 id="2️⃣-Sentence"><a href="#2️⃣-Sentence" class="headerlink" title="2️⃣ Sentence"></a>2️⃣ Sentence</h4><p>表示逻辑语句：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">cells</span> <span class="hljs-operator">=</span> 一组未知格子<br><span class="hljs-attribute">count</span> <span class="hljs-operator">=</span> 地雷数量<br></code></pre></td></tr></table></figure><p>包含方法：</p><ul><li><code>known_mines</code></li><li><code>known_safes</code></li><li><code>mark_mine</code></li><li><code>mark_safe</code></li></ul><hr><h4 id="3️⃣-MinesweeperAI"><a href="#3️⃣-MinesweeperAI" class="headerlink" title="3️⃣ MinesweeperAI"></a>3️⃣ MinesweeperAI</h4><p>维护：</p><ul><li><code>moves_made</code></li><li><code>mines</code></li><li><code>safes</code></li><li><code>knowledge</code></li></ul><p>并根据逻辑推理选择下一步。</p><hr><h2 id="📝-作业要求（Specification）"><a href="#📝-作业要求（Specification）" class="headerlink" title="📝 作业要求（Specification）"></a>📝 作业要求（Specification）</h2><p>你需要完成以下函数：</p><h3 id="Sentence-类"><a href="#Sentence-类" class="headerlink" title="Sentence 类"></a>Sentence 类</h3><ul><li><code>known_mines</code></li><li><code>known_safes</code></li><li><code>mark_mine</code></li><li><code>mark_safe</code></li></ul><hr><h3 id="MinesweeperAI-类"><a href="#MinesweeperAI-类" class="headerlink" title="MinesweeperAI 类"></a>MinesweeperAI 类</h3><ul><li><code>add_knowledge</code></li><li><code>make_safe_move</code></li><li><code>make_random_move</code></li></ul><hr><h3 id="add-knowledge-必须实现："><a href="#add-knowledge-必须实现：" class="headerlink" title="add_knowledge 必须实现："></a>add_knowledge 必须实现：</h3><ol><li>标记该格子已被点击  </li><li>标记为安全格子  </li><li>添加新的逻辑句子  </li><li>推导新的安全格子  </li><li>推导新的地雷  </li><li>使用子集规则生成新句子  </li><li>不断重复推理直到无新知识  </li></ol><hr><h3 id="make-safe-move"><a href="#make-safe-move" class="headerlink" title="make_safe_move"></a>make_safe_move</h3><ul><li>返回一个：<ul><li>已知安全</li><li>且尚未点击的格子</li></ul></li><li>若不存在，返回 <code>None</code></li></ul><hr><h3 id="make-random-move"><a href="#make-random-move" class="headerlink" title="make_random_move"></a>make_random_move</h3><ul><li>随机选择：<ul><li>未点击</li><li>未被标记为地雷的格子</li></ul></li><li>若不存在，返回 <code>None</code></li></ul><hr><h2 id="💡-提示（Hints）"><a href="#💡-提示（Hints）" class="headerlink" title="💡 提示（Hints）"></a>💡 提示（Hints）</h2><ul><li>仔细阅读 Background（非常重要）</li><li>熟练使用 Python 的 <code>set</code></li><li>不要在遍历集合时修改集合</li><li>AI 并不保证每局都能赢（有时必须猜）</li></ul><hr><h2 id="🧪-测试（Testing）"><a href="#🧪-测试（Testing）" class="headerlink" title="🧪 测试（Testing）"></a>🧪 测试（Testing）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">check50 ai50/projects/2024/x/minesweeper<br></code></pre></td></tr></table></figure><p>风格检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">style50<br></code></pre></td></tr></table></figure><hr><h2 id="📤-提交（How-to-Submit）"><a href="#📤-提交（How-to-Submit）" class="headerlink" title="📤 提交（How to Submit）"></a>📤 提交（How to Submit）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">submit50 ai50/projects/2024/x/minesweeper<br></code></pre></td></tr></table></figure><p>或推送至：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/me50/</span>USERNAME.git<br></code></pre></td></tr></table></figure><p>分支名：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ai50<span class="hljs-regexp">/projects/</span><span class="hljs-number">2024</span><span class="hljs-regexp">/x/mi</span>nesweeper<br></code></pre></td></tr></table></figure><hr><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h1 id="一、实现思路"><a href="#一、实现思路" class="headerlink" title="一、实现思路"></a>一、实现思路</h1><p>本项目实现的是一个<strong>基于知识推理的扫雷人工智能（Knowledge-Based Agent）</strong>。</p><p>核心思想只有一句话：</p><blockquote><p><strong>把扫雷数字信息转化为逻辑约束，再通过集合推理不断推出新的安全格和地雷格。</strong></p></blockquote><hr><h2 id="1-扫雷信息如何转化为知识"><a href="#1-扫雷信息如何转化为知识" class="headerlink" title="1. 扫雷信息如何转化为知识"></a>1. 扫雷信息如何转化为知识</h2><p>当 AI 点击一个安全格时，游戏会返回一个数字：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">count</span><br></code></pre></td></tr></table></figure><p>表示：</p><blockquote><p>该格周围 8 个相邻格子中有 <code>count</code> 个地雷。</p></blockquote><p>AI 会做三件事：</p><ol><li>找出该格周围 <strong>所有状态未知的格子</strong></li><li>统计其中已经确定为地雷的数量</li><li>构造如下逻辑表达式：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&#123;相邻未知格集合&#125; <span class="hljs-operator">=</span> count<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">A</span><span class="hljs-operator">,</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-operator">,</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>含义是：</p><blockquote><p>在 A、B、C、D 四个格子中，<strong>恰好有 2 个地雷</strong>。</p></blockquote><hr><h2 id="2-知识的存储方式"><a href="#2-知识的存储方式" class="headerlink" title="2. 知识的存储方式"></a>2. 知识的存储方式</h2><p>每一条逻辑知识用一个 <code>Sentence</code> 表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Sentence(<br>    cells = 一组未知格子,<br>    count = 这些格子中地雷的数量<br>)<br></code></pre></td></tr></table></figure><p>AI 内部维护一个知识库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-variable language_">self</span>.knowledge = []<br></code></pre></td></tr></table></figure><p>用于存储所有逻辑句子。</p><hr><h2 id="3-基本推理规则"><a href="#3-基本推理规则" class="headerlink" title="3. 基本推理规则"></a>3. 基本推理规则</h2><p>AI 主要依靠以下三条规则进行推理。</p><hr><h3 id="（1）安全格推理"><a href="#（1）安全格推理" class="headerlink" title="（1）安全格推理"></a>（1）安全格推理</h3><p>若某个句子满足：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">cells</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>所有格子都不是地雷。</p></blockquote><p>因此这些格子全部是安全格。</p><hr><h3 id="（2）地雷推理"><a href="#（2）地雷推理" class="headerlink" title="（2）地雷推理"></a>（2）地雷推理</h3><p>若某个句子满足：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(cells)</span></span> == count<br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>所有格子都是地雷。</p></blockquote><hr><h3 id="（3）知识更新规则"><a href="#（3）知识更新规则" class="headerlink" title="（3）知识更新规则"></a>（3）知识更新规则</h3><p>当某个格子被确定后：</p><ul><li><p>如果是安全格：<br>从所有句子中移除该格</p></li><li><p>如果是地雷：<br>从所有句子中移除该格，并将计数减 1</p></li></ul><p>从而保证所有知识始终一致。</p><hr><h2 id="4-子集推理（核心）"><a href="#4-子集推理（核心）" class="headerlink" title="4. 子集推理（核心）"></a>4. 子集推理（核心）</h2><p>这是整个算法最重要的部分。</p><p>若存在两个逻辑句子：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">S1</span> ⊆ <span class="hljs-built_in">S2</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-keyword">A</span>, B&#125; = <span class="hljs-number">1</span><br>&#123;<span class="hljs-keyword">A</span>, B, C, D&#125; = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>则可推出：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">C</span><span class="hljs-operator">,</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>推理公式为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">S2</span> - <span class="hljs-built_in">S1</span> = count2 - count1<br></code></pre></td></tr></table></figure><p>通过不断应用该规则，AI 可以自动生成新的逻辑句子。</p><hr><h2 id="5-推理流程总结"><a href="#5-推理流程总结" class="headerlink" title="5. 推理流程总结"></a>5. 推理流程总结</h2><p>当 AI 获得新信息时，会不断循环执行：</p><ol><li>找出所有确定安全的格子</li><li>找出所有确定地雷的格子</li><li>更新所有句子</li><li>执行子集推理生成新句子</li></ol><p>直到知识库无法产生新信息为止。</p><hr><h1 id="1-Sentence-类：每段代码详细解释"><a href="#1-Sentence-类：每段代码详细解释" class="headerlink" title="1) Sentence 类：每段代码详细解释"></a>1) Sentence 类：每段代码详细解释</h1><p><code>Sentence</code> 的含义是一个约束：</p><blockquote><p><code>cells</code> 这堆格子里 <strong>恰好</strong> 有 <code>count</code> 个雷</p></blockquote><p>例如：<code>&#123;(1,2),(1,3),(2,3)&#125; = 1</code></p><hr><h2 id="1-1-known-mines"><a href="#1-1-known-mines" class="headerlink" title="1.1 known_mines"></a>1.1 <code>known_mines</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">known_mines</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 若数量等于格子数，则所有格子都必为地雷</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.count == <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.cells) <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.count &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>(<span class="hljs-variable language_">self</span>.cells)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><h3 id="这段代码在做什么？"><a href="#这段代码在做什么？" class="headerlink" title="这段代码在做什么？"></a>这段代码在做什么？</h3><ul><li>它想从一条句子里<strong>直接推出“哪些格子一定是雷”</strong>。</li></ul><h3 id="为什么-count-len-cells-就全是雷？"><a href="#为什么-count-len-cells-就全是雷？" class="headerlink" title="为什么 count == len(cells) 就全是雷？"></a>为什么 <code>count == len(cells)</code> 就全是雷？</h3><ul><li><code>cells</code> 里有 <code>len(cells)</code> 个格子</li><li>句子说其中 <strong>有 <code>count</code> 个雷</strong></li><li><p>如果 <code>count</code> 恰好等于格子数，意味着：</p><ul><li>“这里面每一个格子都是雷”，否则雷数就不够。</li></ul></li></ul><h3 id="为什么还要-count-gt-0？"><a href="#为什么还要-count-gt-0？" class="headerlink" title="为什么还要 count &gt; 0？"></a>为什么还要 <code>count &gt; 0</code>？</h3><ul><li><p>防止 <code>cells</code> 为空或一些边界情况：</p><ul><li>比如 <code>cells</code> 为空，<code>len(cells)=0</code>，<code>count</code> 也可能为 0（理论上）</li><li><code>count==len(cells)</code> 会成立，但“全是雷”没有意义</li></ul></li><li>加上 <code>count&gt;0</code> 更严谨：只有真的存在雷数量时才返回。</li></ul><h3 id="为什么-return-set-self-cells-要再套一层-set？"><a href="#为什么-return-set-self-cells-要再套一层-set？" class="headerlink" title="为什么 return set(self.cells) 要再套一层 set？"></a>为什么 <code>return set(self.cells)</code> 要再套一层 <code>set</code>？</h3><ul><li>返回一个新的集合拷贝，避免外部误修改 <code>self.cells</code>（更安全）。</li></ul><hr><h2 id="1-2-known-safes"><a href="#1-2-known-safes" class="headerlink" title="1.2 known_safes"></a>1.2 <code>known_safes</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">known_safes</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 若数量为 0，则所有格子都安全</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.count == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>(<span class="hljs-variable language_">self</span>.cells)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><h3 id="这段代码在做什么？-1"><a href="#这段代码在做什么？-1" class="headerlink" title="这段代码在做什么？"></a>这段代码在做什么？</h3><ul><li>从句子直接推出“哪些格子一定安全”。</li></ul><h3 id="为什么-count-0-就全安全？"><a href="#为什么-count-0-就全安全？" class="headerlink" title="为什么 count == 0 就全安全？"></a>为什么 <code>count == 0</code> 就全安全？</h3><ul><li>句子含义是“这些格子里有 <code>count</code> 个雷”</li><li><p>如果 <code>count=0</code>，说明：</p><ul><li>“这里面一个雷都没有”</li><li>所以全是安全格。</li></ul></li></ul><hr><h2 id="1-3-mark-mine"><a href="#1-3-mark-mine" class="headerlink" title="1.3 mark_mine"></a>1.3 <code>mark_mine</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mark_mine</span>(<span class="hljs-params">self, cell</span>):<br>    <span class="hljs-comment"># 移除该格并减少计数，因为这个雷已被“解释”掉</span><br>    <span class="hljs-keyword">if</span> cell <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.cells:<br>        <span class="hljs-variable language_">self</span>.cells.remove(cell)<br>        <span class="hljs-variable language_">self</span>.count -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="这段代码在做什么？-2"><a href="#这段代码在做什么？-2" class="headerlink" title="这段代码在做什么？"></a>这段代码在做什么？</h3><p>当外部已经确定某个格子 <code>cell</code> 是雷时，要把这个信息同步到当前句子里。</p><h3 id="为什么要-remove-cell-？"><a href="#为什么要-remove-cell-？" class="headerlink" title="为什么要 remove(cell)？"></a>为什么要 <code>remove(cell)</code>？</h3><ul><li>当前句子的 <code>cells</code> 表示“还不确定状态的格子”</li><li>既然 <code>cell</code> 已经确定是雷了，就不应该继续留在“未知集合”里。</li></ul><h3 id="为什么还要-count-1？"><a href="#为什么还要-count-1？" class="headerlink" title="为什么还要 count -= 1？"></a>为什么还要 <code>count -= 1</code>？</h3><p>因为句子原本说：</p><blockquote><p><code>cells</code> 里一共有 <code>count</code> 个雷</p></blockquote><p>如果我们已经知道其中某一个 <code>cell</code> 是雷，那么剩下的雷数量就应该减少 1：</p><ul><li>原来：<code>&#123;A, B, C&#125; = 2</code></li><li><p>若发现 <code>C</code> 是雷：</p><ul><li>剩余未知就变成 <code>&#123;A, B&#125;</code></li><li>雷数变成 <code>1</code></li></ul></li><li>所以必须 <code>count -= 1</code></li></ul><hr><h2 id="1-4-mark-safe"><a href="#1-4-mark-safe" class="headerlink" title="1.4 mark_safe"></a>1.4 <code>mark_safe</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mark_safe</span>(<span class="hljs-params">self, cell</span>):<br>    <span class="hljs-comment"># 安全格可直接移除，计数不变</span><br>    <span class="hljs-keyword">if</span> cell <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.cells:<br>        <span class="hljs-variable language_">self</span>.cells.remove(cell)<br></code></pre></td></tr></table></figure><h3 id="为什么安全格移除但-count-不变？"><a href="#为什么安全格移除但-count-不变？" class="headerlink" title="为什么安全格移除但 count 不变？"></a>为什么安全格移除但 <code>count</code> 不变？</h3><p>句子说的是“雷的数量”，安全格不是雷，因此不会占用雷数：</p><ul><li>原来：<code>&#123;A, B, C&#125; = 2</code></li><li><p>若发现 <code>C</code> 安全：</p><ul><li>剩余未知变 <code>&#123;A, B&#125;</code></li><li>雷还是 <code>2</code></li></ul></li><li>所以只移除，不减 count。</li></ul><hr><h1 id="2-MinesweeperAI-类：每段代码详细解释"><a href="#2-MinesweeperAI-类：每段代码详细解释" class="headerlink" title="2) MinesweeperAI 类：每段代码详细解释"></a>2) MinesweeperAI 类：每段代码详细解释</h1><p>AI 维护全局状态：</p><ul><li><code>moves_made</code>: 已经点过的格子</li><li><code>safes</code>: 已知安全</li><li><code>mines</code>: 已知地雷</li><li><code>knowledge</code>: 逻辑句子列表</li></ul><hr><h2 id="2-1-mark-mine"><a href="#2-1-mark-mine" class="headerlink" title="2.1 mark_mine"></a>2.1 <code>mark_mine</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mark_mine</span>(<span class="hljs-params">self, cell</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    标记某格为地雷，并同步更新所有已知句子。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-variable language_">self</span>.mines.add(cell)<br>    <span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge:<br>        sentence.mark_mine(cell)<br></code></pre></td></tr></table></figure><h3 id="这段代码做什么？"><a href="#这段代码做什么？" class="headerlink" title="这段代码做什么？"></a>这段代码做什么？</h3><ul><li>把 <code>cell</code> 放到 AI 的“地雷集合”里</li><li>并告诉知识库里的每一句话：这个格子是雷（更新约束）</li></ul><h3 id="为什么要遍历所有句子更新？"><a href="#为什么要遍历所有句子更新？" class="headerlink" title="为什么要遍历所有句子更新？"></a>为什么要遍历所有句子更新？</h3><p>因为任何一句话里只要包含这个格子，都必须变成“已解释过的雷”，不然知识库会不一致。</p><hr><h2 id="2-2-mark-safe"><a href="#2-2-mark-safe" class="headerlink" title="2.2 mark_safe"></a>2.2 <code>mark_safe</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mark_safe</span>(<span class="hljs-params">self, cell</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    标记某格为安全，并同步更新所有已知句子。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-variable language_">self</span>.safes.add(cell)<br>    <span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge:<br>        sentence.mark_safe(cell)<br></code></pre></td></tr></table></figure><p>同理：</p><ul><li>放入安全集合</li><li>同步删掉所有句子里包含它的部分（保持一致）</li></ul><hr><h1 id="2-3-add-knowledge（最关键：逐段拆解）"><a href="#2-3-add-knowledge（最关键：逐段拆解）" class="headerlink" title="2.3 add_knowledge（最关键：逐段拆解）"></a>2.3 <code>add_knowledge</code>（最关键：逐段拆解）</h1><p>函数目标：点击一个安全格 <code>cell</code>，游戏告诉你周围雷数 <code>count</code>，AI 要把它变成知识并推理。</p><hr><h3 id="1-记录“已经点过”"><a href="#1-记录“已经点过”" class="headerlink" title="(1) 记录“已经点过”"></a>(1) 记录“已经点过”</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-variable language_">self</span>.moves_made.add(cell)<br></code></pre></td></tr></table></figure><ul><li>防止后续再点同一个格子</li><li><code>make_safe_move</code> / <code>make_random_move</code> 都会依赖它过滤候选。</li></ul><hr><h3 id="2-标记为安全"><a href="#2-标记为安全" class="headerlink" title="(2) 标记为安全"></a>(2) 标记为安全</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-variable language_">self</span>.mark_safe(cell)<br></code></pre></td></tr></table></figure><p>因为调用 <code>add_knowledge(cell,count)</code> 的前提就是：<strong>这个 cell 是你点开的安全格</strong>（游戏只会对安全格给数字）。</p><hr><h3 id="3-收集未知邻居，修正计数"><a href="#3-收集未知邻居，修正计数" class="headerlink" title="(3) 收集未知邻居，修正计数"></a>(3) 收集未知邻居，修正计数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">neighbors = <span class="hljs-built_in">set</span>()<br>adjusted_count = count<br></code></pre></td></tr></table></figure><ul><li><code>neighbors</code>：用来放“周围尚未知状态”的格子</li><li><code>adjusted_count</code>：因为周围如果有一些格子已知是雷，<code>count</code> 里已经包含它们了，但我们之后的句子里不会包含这些已知雷，所以要减掉。</li></ul><hr><h3 id="4-枚举周围-8-格"><a href="#4-枚举周围-8-格" class="headerlink" title="(4) 枚举周围 8 格"></a>(4) 枚举周围 8 格</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cell[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, cell[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cell[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, cell[<span class="hljs-number">1</span>] + <span class="hljs-number">2</span>):<br></code></pre></td></tr></table></figure><p>这里 <code>+2</code> 是因为 Python range 不包含右端点。<br>所以实际 i/j 取值是：</p><ul><li><code>cell[0]-1, cell[0], cell[0]+1</code></li><li><code>cell[1]-1, cell[1], cell[1]+1</code></li></ul><p>即 3×3 的区域。</p><hr><h3 id="5-跳过自身"><a href="#5-跳过自身" class="headerlink" title="(5) 跳过自身"></a>(5) 跳过自身</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> (i, j) == cell:<br>    <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><p>扫雷规则中：数字只统计“周围”，不包括自己。</p><hr><h3 id="6-边界检查"><a href="#6-边界检查" class="headerlink" title="(6) 边界检查"></a>(6) 边界检查</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= i &lt; <span class="hljs-variable language_">self</span>.height <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= j &lt; <span class="hljs-variable language_">self</span>.width:<br></code></pre></td></tr></table></figure><p>防止访问越界（比如在角落格子时会出现 -1 或 width）。</p><hr><h3 id="7-处理邻居格子的三种情况"><a href="#7-处理邻居格子的三种情况" class="headerlink" title="(7) 处理邻居格子的三种情况"></a>(7) 处理邻居格子的三种情况</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">neighbor = (i, j)<br><span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.mines:<br>    adjusted_count -= <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.safes:<br>    neighbors.add(neighbor)<br></code></pre></td></tr></table></figure><p><strong>情况 A：邻居是已知雷</strong></p><ul><li>说明 <code>count</code> 的雷里有一个已经被我们“确定”了</li><li>但我们的新句子不会把这个格子再算进 <code>cells</code>（因为它不再未知）</li><li>所以必须：<code>adjusted_count -= 1</code></li></ul><p><strong>情况 B：邻居是已知安全</strong></p><ul><li>不加入 <code>neighbors</code></li><li>因为句子只应该描述“未知格”</li></ul><p><strong>情况 C：邻居未知</strong></p><ul><li>加入 <code>neighbors</code></li></ul><hr><h3 id="8-把新句子加入知识库"><a href="#8-把新句子加入知识库" class="headerlink" title="(8) 把新句子加入知识库"></a>(8) 把新句子加入知识库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> neighbors:<br>    <span class="hljs-variable language_">self</span>.knowledge.append(Sentence(neighbors, adjusted_count))<br></code></pre></td></tr></table></figure><p>如果周围还有未知格子，就形成约束：</p><blockquote><p><code>neighbors</code> 里恰好 <code>adjusted_count</code> 个雷</p></blockquote><hr><h2 id="2-4-推理循环（直到无新结论）"><a href="#2-4-推理循环（直到无新结论）" class="headerlink" title="2.4 推理循环（直到无新结论）"></a>2.4 推理循环（直到无新结论）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">changed = <span class="hljs-literal">True</span><br><span class="hljs-keyword">while</span> changed:<br>    changed = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><code>changed</code> 作为“本轮是否推导出新信息”的标记。<br>只要推导出了新 safe/mine/new sentence，就再循环一次。</p><hr><h3 id="1-从每个句子里提取可确定信息"><a href="#1-从每个句子里提取可确定信息" class="headerlink" title="(1) 从每个句子里提取可确定信息"></a>(1) 从每个句子里提取可确定信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">new_mines = <span class="hljs-built_in">set</span>()<br>new_safes = <span class="hljs-built_in">set</span>()<br><span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge:<br>    new_mines.update(sentence.known_mines())<br>    new_safes.update(sentence.known_safes())<br></code></pre></td></tr></table></figure><ul><li>遍历所有句子</li><li>如果发现 “全是雷” 或 “全是安全”</li><li>就把这些格子加入临时集合，等待统一更新。</li></ul><hr><h3 id="2-把推导结果同步到全局"><a href="#2-把推导结果同步到全局" class="headerlink" title="(2) 把推导结果同步到全局"></a>(2) 把推导结果同步到全局</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> mine <span class="hljs-keyword">in</span> new_mines:<br>    <span class="hljs-keyword">if</span> mine <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.mines:<br>        <span class="hljs-variable language_">self</span>.mark_mine(mine)<br>        changed = <span class="hljs-literal">True</span><br><span class="hljs-keyword">for</span> safe <span class="hljs-keyword">in</span> new_safes:<br>    <span class="hljs-keyword">if</span> safe <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.safes:<br>        <span class="hljs-variable language_">self</span>.mark_safe(safe)<br>        changed = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>这里的 <code>if mine not in self.mines</code> 是为了避免重复标记。<br>只要新增了信息，就把 <code>changed</code> 设为 True，说明还要继续推理。</p><hr><h3 id="3-清理空句子"><a href="#3-清理空句子" class="headerlink" title="(3) 清理空句子"></a>(3) 清理空句子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-variable language_">self</span>.knowledge = [s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge <span class="hljs-keyword">if</span> s.cells]<br></code></pre></td></tr></table></figure><p>如果某句子的 <code>cells</code> 被删光了，就没意义了，删掉防止污染推理。</p><hr><h3 id="4-子集推理生成新句子"><a href="#4-子集推理生成新句子" class="headerlink" title="(4) 子集推理生成新句子"></a>(4) 子集推理生成新句子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> s1 <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge:<br>    <span class="hljs-keyword">for</span> s2 <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge:<br>        <span class="hljs-keyword">if</span> s1 <span class="hljs-keyword">is</span> s2:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> s1.cells <span class="hljs-keyword">and</span> s1.cells.issubset(s2.cells):<br>            diff_cells = s2.cells - s1.cells<br>            diff_count = s2.count - s1.count<br>            candidate = Sentence(diff_cells, diff_count)<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li>遍历任意两句 <code>s1, s2</code></li><li>如果 <code>s1.cells ⊆ s2.cells</code></li><li><p>那么可以推出：</p><ul><li><code>diff_cells = s2 - s1</code></li><li><code>diff_count = count2 - count1</code></li></ul></li></ul><p>这是作业说明里最重要的推理规则。</p><hr><h3 id="5-防止重复加入"><a href="#5-防止重复加入" class="headerlink" title="(5) 防止重复加入"></a>(5) 防止重复加入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> diff_cells <span class="hljs-keyword">and</span> candidate <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.knowledge <span class="hljs-keyword">and</span> candidate <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> inferred:<br>    inferred.append(candidate)<br></code></pre></td></tr></table></figure><ul><li><code>diff_cells</code> 为空就没意义</li><li>不能重复添加同样句子，否则知识库会无限膨胀</li></ul><hr><h3 id="6-加入知识库并继续循环"><a href="#6-加入知识库并继续循环" class="headerlink" title="(6) 加入知识库并继续循环"></a>(6) 加入知识库并继续循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> inferred:<br>    <span class="hljs-variable language_">self</span>.knowledge.extend(inferred)<br>    changed = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>只要产生了新句子，就说明可能可以推出更多 safe/mine，所以继续 while 循环。</p><hr><h1 id="3-make-safe-move-逐段解释"><a href="#3-make-safe-move-逐段解释" class="headerlink" title="3) make_safe_move 逐段解释"></a>3) <code>make_safe_move</code> 逐段解释</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_safe_move</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.safes:<br>        <span class="hljs-keyword">if</span> cell <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.moves_made:<br>            <span class="hljs-keyword">return</span> cell<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><ul><li>遍历所有已知安全格</li><li>找一个没点过的就返回</li><li>如果没有可点安全格，返回 <code>None</code></li></ul><p>注意：该函数<strong>不修改任何集合</strong>，只负责“选一个”。</p><hr><h1 id="4-make-random-move-逐段解释"><a href="#4-make-random-move-逐段解释" class="headerlink" title="4) make_random_move 逐段解释"></a>4) <code>make_random_move</code> 逐段解释</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_random_move</span>(<span class="hljs-params">self</span>):<br>    candidates = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.height):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.width):<br>            cell = (i, j)<br>            <span class="hljs-keyword">if</span> cell <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.moves_made <span class="hljs-keyword">or</span> cell <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.mines:<br>                <span class="hljs-keyword">continue</span><br>            candidates.append(cell)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> candidates:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> random.choice(candidates)<br></code></pre></td></tr></table></figure><ul><li>枚举全棋盘</li><li><p>排除：</p><ul><li>已点过的格子</li><li>已知地雷格子</li></ul></li><li>剩下的是“可猜测”的候选</li><li>从候选里随机挑一个</li></ul><p>如果候选为空，说明无路可走（游戏结束或全点完），返回 <code>None</code>。</p>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50 AI project1 Knights</title>
    <link href="/2026/01/24/CS50AI-Project1-Knights/"/>
    <url>/2026/01/24/CS50AI-Project1-Knights/</url>
    
    <content type="html"><![CDATA[<h1 id="Knights-——-CS50《使用-Python-的人工智能导论》"><a href="#Knights-——-CS50《使用-Python-的人工智能导论》" class="headerlink" title="Knights —— CS50《使用 Python 的人工智能导论》"></a>Knights —— CS50《使用 Python 的人工智能导论》</h1><p>编写一个程序来解决逻辑谜题。</p><hr><h2 id="何时完成（When-to-Do-It）"><a href="#何时完成（When-to-Do-It）" class="headerlink" title="何时完成（When to Do It）"></a>何时完成（When to Do It）</h2><p><strong>截止时间：</strong><br>📅 <strong>2026 年 7 月 1 日（星期三）上午 7:59（GMT+8）之前</strong>  </p><hr><h2 id="如何获取帮助（How-to-Get-Help）"><a href="#如何获取帮助（How-to-Get-Help）" class="headerlink" title="如何获取帮助（How to Get Help）"></a>如何获取帮助（How to Get Help）</h2><ol><li>通过 <strong>Ed</strong> 提问  </li><li>通过任意一个 <strong>CS50 官方社区</strong> 提问  </li></ol><hr><h2 id="背景（Background）"><a href="#背景（Background）" class="headerlink" title="背景（Background）"></a>背景（Background）</h2><p>1978 年，逻辑学家 <strong>Raymond Smullyan</strong> 出版了一本名为<br><strong>《What is the name of this book?》</strong> 的书。</p><p>在这本书中包含了一类著名的逻辑谜题，被称为：</p><blockquote><p><strong>骑士与骗子（Knights and Knaves）谜题</strong></p></blockquote><p>在这类谜题中，有如下设定：</p><ul><li>每个角色<strong>要么是骑士（Knight），要么是骗子（Knave）</strong></li><li><strong>骑士永远说真话</strong><ul><li>如果骑士说出一句话，那么这句话一定为真</li></ul></li><li><strong>骗子永远说假话</strong><ul><li>如果骗子说出一句话，那么这句话一定为假</li></ul></li></ul><hr><h3 id="谜题目标"><a href="#谜题目标" class="headerlink" title="谜题目标"></a>谜题目标</h3><p>给定每个角色所说的句子：</p><blockquote><p><strong>判断每个角色究竟是骑士还是骗子。</strong></p></blockquote><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设只有一个角色 <strong>A</strong>。</p><p>A 说：</p><blockquote><p>“我既是骑士，又是骗子。”</p></blockquote><p>我们可以这样推理：</p><ul><li>如果 A 是骑士，那么他说的话必须为真  </li><li>但这句话<strong>不可能为真</strong><br>因为一个人不可能同时既是骑士又是骗子  </li></ul><p>因此可以得出结论：</p><blockquote><p>✅ <strong>A 一定是骗子（knave）</strong></p></blockquote><hr><p>当然，这只是最简单的情况。<br>当角色更多、语句更复杂时，推理也会变得更加困难。</p><hr><h3 id="本项目的任务"><a href="#本项目的任务" class="headerlink" title="本项目的任务"></a>本项目的任务</h3><p>你的任务是：</p><blockquote><p><strong>使用命题逻辑来表示这些谜题，<br>使得一个运行模型检测算法（model-checking）的 AI 能够自动求解它们。</strong></p></blockquote><hr><h2 id="开始（Getting-Started）"><a href="#开始（Getting-Started）" class="headerlink" title="开始（Getting Started）"></a>开始（Getting Started）</h2><p>下载并解压项目代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>cdn.cs50.net<span class="hljs-regexp">/ai/</span><span class="hljs-number">2023</span><span class="hljs-regexp">/x/</span>projects<span class="hljs-regexp">/1/</span>knights.zip<br></code></pre></td></tr></table></figure><hr><h2 id="理解项目结构（Understanding）"><a href="#理解项目结构（Understanding）" class="headerlink" title="理解项目结构（Understanding）"></a>理解项目结构（Understanding）</h2><p>请查看文件 <strong><code>logic.py</code></strong>。</p><p>你不需要完全理解其中的所有代码，但需要注意：</p><h3 id="1️⃣-逻辑连接词类"><a href="#1️⃣-逻辑连接词类" class="headerlink" title="1️⃣ 逻辑连接词类"></a>1️⃣ 逻辑连接词类</h3><p>该文件中定义了多种逻辑结构，例如：</p><ul><li><code>And</code></li><li><code>Or</code></li><li><code>Not</code></li><li><code>Implication</code></li><li>等等</li></ul><p>这些类可以<strong>互相嵌套组合</strong>。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">And(Not(A), Or(B, C))<br></code></pre></td></tr></table></figure><p>表示的逻辑含义是：</p><blockquote><p>A 不成立，<br>并且 B 或 C 成立<br>（这里的“或”为<strong>包含或</strong>，不是异或）</p></blockquote><hr><h3 id="2️⃣-model-check-函数"><a href="#2️⃣-model-check-函数" class="headerlink" title="2️⃣ model_check 函数"></a>2️⃣ <code>model_check</code> 函数</h3><p><code>logic.py</code> 中还包含一个重要函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model_check(knowledge, query)<br></code></pre></td></tr></table></figure><ul><li><p><strong>knowledge（知识库）</strong><br>一个逻辑表达式<br>如果有多条知识，可以用 <code>And(...)</code> 连接起来</p></li><li><p><strong>query（查询语句）</strong><br>想要判断是否能从知识库中推出的命题</p></li></ul><p>该函数会：</p><ul><li>枚举所有可能的模型</li><li>判断：</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">knowledge ⊨ <span class="hljs-keyword">query</span><br></code></pre></td></tr></table></figure><p>如果知识库逻辑蕴含该查询，则返回 <code>True</code>，否则返回 <code>False</code>。</p><hr><h2 id="puzzle-py-文件说明"><a href="#puzzle-py-文件说明" class="headerlink" title="puzzle.py 文件说明"></a>puzzle.py 文件说明</h2><p>在 <code>puzzle.py</code> 文件顶部，已经定义了 6 个命题符号：</p><ul><li><code>AKnight</code>：A 是骑士  </li><li><code>AKnave</code>：A 是骗子  </li></ul><p>同样地，也为 B、C 定义了对应变量。</p><hr><h3 id="知识库变量"><a href="#知识库变量" class="headerlink" title="知识库变量"></a>知识库变量</h3><p>接下来你会看到四个知识库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge0<br>knowledge1<br>knowledge2<br>knowledge3<br></code></pre></td></tr></table></figure><p>它们分别对应：</p><ul><li>Puzzle 0</li><li>Puzzle 1</li><li>Puzzle 2</li><li>Puzzle 3</li></ul><p>目前它们都是<strong>空的</strong>。</p><p>👉 <strong>你的任务就是向这些知识库中添加逻辑知识。</strong></p><hr><h3 id="main-函数做了什么？"><a href="#main-函数做了什么？" class="headerlink" title="main 函数做了什么？"></a>main 函数做了什么？</h3><p><code>main</code> 函数会：</p><ol><li>遍历所有谜题</li><li>使用模型检测算法</li><li>推断每个角色是骑士还是骗子</li><li>输出能够确定的结论</li></ol><hr><h2 id="任务说明（Specification）"><a href="#任务说明（Specification）" class="headerlink" title="任务说明（Specification）"></a>任务说明（Specification）</h2><p>请向 <code>knowledge0</code>、<code>knowledge1</code>、<code>knowledge2</code>、<code>knowledge3</code> 中添加知识，使程序能够解决以下谜题。</p><hr><h3 id="🧩-Puzzle-0"><a href="#🧩-Puzzle-0" class="headerlink" title="🧩 Puzzle 0"></a>🧩 Puzzle 0</h3><ul><li>只有一个角色：A  </li><li>A 说：</li></ul><blockquote><p>“我既是骑士，又是骗子。”</p></blockquote><hr><h3 id="🧩-Puzzle-1"><a href="#🧩-Puzzle-1" class="headerlink" title="🧩 Puzzle 1"></a>🧩 Puzzle 1</h3><ul><li>两个角色：A 和 B  </li><li>A 说：</li></ul><blockquote><p>“我们都是骗子。”</p></blockquote><ul><li>B 什么也没说</li></ul><hr><h3 id="🧩-Puzzle-2"><a href="#🧩-Puzzle-2" class="headerlink" title="🧩 Puzzle 2"></a>🧩 Puzzle 2</h3><ul><li>两个角色：A 和 B  </li><li>A 说：</li></ul><blockquote><p>“我们是同一种人。”</p></blockquote><ul><li>B 说：</li></ul><blockquote><p>“我们是不同种类的人。”</p></blockquote><hr><h3 id="🧩-Puzzle-3"><a href="#🧩-Puzzle-3" class="headerlink" title="🧩 Puzzle 3"></a>🧩 Puzzle 3</h3><ul><li><p>三个角色：A、B、C  </p></li><li><p>A 说了以下两句话之一（但你不知道是哪一句）：</p><ul><li>“我是骑士。”</li><li>“我是骗子。”</li></ul></li><li><p>B 说：</p><blockquote><p>“A 说过：‘我是骗子。’”</p></blockquote></li><li><p>B 接着又说：</p><blockquote><p>“C 是骗子。”</p></blockquote></li><li><p>C 说：</p><blockquote><p>“A 是骑士。”</p></blockquote></li></ul><hr><h3 id="通用规则"><a href="#通用规则" class="headerlink" title="通用规则"></a>通用规则</h3><p>在以上所有谜题中：</p><ul><li>每个人要么是骑士，要么是骗子</li><li>骑士说的所有话都是真的</li><li>骗子说的所有话都是假的</li></ul><hr><p>完成知识库后，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python puzzle.py<br></code></pre></td></tr></table></figure><p>即可看到谜题的解答结果。</p><hr><h2 id="提示（Hints）"><a href="#提示（Hints）" class="headerlink" title="提示（Hints）"></a>提示（Hints）</h2><ul><li><p>每个知识库通常需要编码两类信息：</p><ol><li><strong>谜题的结构性规则</strong><ul><li>每个人非骑士即骗子</li></ul></li><li><strong>角色所说的话本身</strong></li></ol></li><li><p>思考：</p><ul><li>如果一句话是由骑士说的，会意味着什么？</li><li>如果一句话是由骗子说的，又意味着什么？</li><li>如何将“说真话 / 说假话”转化为逻辑公式？</li></ul></li></ul><hr><h3 id="⚠️-注意"><a href="#⚠️-注意" class="headerlink" title="⚠️ 注意"></a>⚠️ 注意</h3><p>虽然存在很多种写法都能得出正确答案：</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge0 = AKnave<br></code></pre></td></tr></table></figure><p>确实能得到正确结果，</p><p>但这<strong>违背了本题的精神</strong>。</p><blockquote><p>你的目标是：<br><strong>让 AI 自己推理出答案，而不是你提前替它推理。</strong></p></blockquote><hr><p>你也<strong>不需要，也不应该</strong>修改 <code>logic.py</code> 文件。</p><hr><h2 id="测试（Testing）"><a href="#测试（Testing）" class="headerlink" title="测试（Testing）"></a>测试（Testing）</h2><p>如果你已经配置好 <code>check50</code>，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">check50 ai50/projects/2024/x/knights<br></code></pre></td></tr></table></figure><p>检查正确性。</p><p>使用下面命令检查代码风格：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">style50<br></code></pre></td></tr></table></figure><hr><h2 id="提交方式（How-to-Submit）"><a href="#提交方式（How-to-Submit）" class="headerlink" title="提交方式（How to Submit）"></a>提交方式（How to Submit）</h2><ol><li><p>打开以下链接并使用 GitHub 登录：<br><a href="https://submit.cs50.io/invites/d03c31aef1984c29b5e7b268c3a87b7b">https://submit.cs50.io/invites/d03c31aef1984c29b5e7b268c3a87b7b</a></p></li><li><p>安装 Git（可选安装 submit50）</p></li><li><p>提交代码：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">submit50 ai50/projects/2024/x/knights<br></code></pre></td></tr></table></figure><p>或将代码推送至：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/me50/</span>USERNAME.git<br></code></pre></td></tr></table></figure><p>分支名：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ai50<span class="hljs-regexp">/projects/</span><span class="hljs-number">2024</span><span class="hljs-regexp">/x/</span>knights<br></code></pre></td></tr></table></figure><hr><p>作业通常会在 <strong>5 分钟内完成评分</strong>。</p><p>你可以在这里查看进度：</p><p>👉 <a href="https://cs50.me/cs50ai">https://cs50.me/cs50ai</a></p><hr><h1 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h1><h2 id="1-核心逻辑支柱"><a href="#1-核心逻辑支柱" class="headerlink" title="1. 核心逻辑支柱"></a>1. 核心逻辑支柱</h2><h3 id="A-身份约束（Identity-Constraints）"><a href="#A-身份约束（Identity-Constraints）" class="headerlink" title="A. 身份约束（Identity Constraints）"></a>A. 身份约束（Identity Constraints）</h3><p>在所有谜题中，每个角色（如 A）必须满足：</p><ul><li><strong>非此即彼</strong>：A 要么是骑士，要么是骗子。逻辑表达为：<code>Or(AKnight, AKnave)</code>。</li><li><strong>互斥性</strong>：A 不能同时既是骑士又是骗子。逻辑表达为：<code>Not(And(AKnight, AKnave))</code>。</li></ul><h3 id="B-说话规则（Speech-Rules）"><a href="#B-说话规则（Speech-Rules）" class="headerlink" title="B. 说话规则（Speech Rules）"></a>B. 说话规则（Speech Rules）</h3><p>这是将自然语言转化为逻辑公式的关键。若角色 A 说出命题 $S$：</p><ul><li>如果 A 是骑士，则 $S$ 为真；如果 A 是骗子，则 $S$ 为假。</li><li>在 <code>logic.py</code> 中，这可以用 <strong>双条件（Biconditional）</strong> 完美表达：<code>Biconditional(AKnight, S)</code>，意味着 $AKnight$ 与 $S$ 的真值必须始终保持一致。</li></ul><hr><h2 id="2-谜题逻辑建模代码实现"><a href="#2-谜题逻辑建模代码实现" class="headerlink" title="2. 谜题逻辑建模代码实现"></a>2. 谜题逻辑建模代码实现</h2><p>以下是各谜题在 <code>puzzle.py</code> 中的完整逻辑构建方案：</p><h3 id="🧩-Puzzle-0-1"><a href="#🧩-Puzzle-0-1" class="headerlink" title="🧩 Puzzle 0"></a>🧩 Puzzle 0</h3><p><strong>题目</strong>：A 说：“我既是骑士，又是骗子。”<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge0 = And(<br>    <span class="hljs-comment"># 身份约束</span><br>    Or(AKnight, AKnave), Not(And(AKnight, AKnave)),<br>    <span class="hljs-comment"># 说话规则</span><br>    Biconditional(AKnight, And(AKnight, AKnave))<br>)<br><br></code></pre></td></tr></table></figure></p><h3 id="🧩-Puzzle-1-1"><a href="#🧩-Puzzle-1-1" class="headerlink" title="🧩 Puzzle 1"></a>🧩 Puzzle 1</h3><p><strong>题目</strong>：A 说：“我们两个都是骗子。” B 什么也没说。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge1 = And(<br>    <span class="hljs-comment"># A, B 身份约束</span><br>    Or(AKnight, AKnave), Not(And(AKnight, AKnave)),<br>    Or(BKnight, BKnave), Not(And(BKnight, BKnave)),<br>    <span class="hljs-comment"># A 的陈述与其身份绑定</span><br>    Biconditional(AKnight, And(AKnave, BKnave))<br>)<br><br></code></pre></td></tr></table></figure><h3 id="🧩-Puzzle-2-1"><a href="#🧩-Puzzle-2-1" class="headerlink" title="🧩 Puzzle 2"></a>🧩 Puzzle 2</h3><p><strong>题目</strong>：A 说：“我们是同类。” B 说：“我们是不同种类的人。”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge2 = And(<br>    <span class="hljs-comment"># A, B 身份约束</span><br>    Or(AKnight, AKnave), Not(And(AKnight, AKnave)),<br>    Or(BKnight, BKnave), Not(And(BKnight, BKnave)),<br>    <span class="hljs-comment"># A 说两人身份等价</span><br>    Biconditional(AKnight, Biconditional(AKnight, BKnight)),<br>    <span class="hljs-comment"># B 说两人身份不等价</span><br>    Biconditional(BKnight, Not(Biconditional(AKnight, BKnight)))<br>)<br><br></code></pre></td></tr></table></figure><h3 id="🧩-Puzzle-3-1"><a href="#🧩-Puzzle-3-1" class="headerlink" title="🧩 Puzzle 3"></a>🧩 Puzzle 3</h3><p><strong>题目</strong>：A 说了“我是骑士”或“我是骗子”；B 声称“A 说了‘我是骗子’”；B 又说“C 是骗子”；C 说“A 是骑士”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge3 = And(<br>    <span class="hljs-comment"># A, B, C 身份约束</span><br>    Or(AKnight, AKnave), Not(And(AKnight, AKnave)),<br>    Or(BKnight, BKnave), Not(And(BKnight, BKnave)),<br>    Or(CKnight, CKnave), Not(And(CKnight, CKnave)),<br><br>    <span class="hljs-comment"># 1. 关于 A 的言论逻辑：无论 A 选哪句，其身份与陈述的真值一致性是隐含的。</span><br>    <span class="hljs-comment"># 2. B 的第一句：B 声称 A 说了“我是骗子”。</span><br>    <span class="hljs-comment"># 逻辑表达：B 是骑士 当且仅当 “A 是骑士 &lt;=&gt; A 是骗子” 为真。</span><br>    Biconditional(BKnight, Biconditional(AKnight, AKnave)),<br><br>    <span class="hljs-comment"># 3. B 的第二句：B 声称“C 是骗子”。</span><br>    Biconditional(BKnight, CKnave),<br><br>    <span class="hljs-comment"># 4. C 的陈述：C 声称“A 是骑士”。</span><br>    Biconditional(CKnight, AKnight)<br>)<br><br></code></pre></td></tr></table></figure><hr><h2 id="3-模型检测算法原理"><a href="#3-模型检测算法原理" class="headerlink" title="3. 模型检测算法原理"></a>3. 模型检测算法原理</h2><p><code>model_check(knowledge, query)</code> 函数的核心任务是判断一个逻辑推论是否有效。在逻辑学中，这被称为<strong>逻辑蕴含（Entailment）</strong>，记作 。</p><p>它的工作原理可以概括为：<strong>穷举所有可能的真相组合，验证在所有使“知识库”成立的情况下，“查询语句”是否也成立。</strong></p><hr><h2 id="1-核心算法流程：递归穷举"><a href="#1-核心算法流程：递归穷举" class="headerlink" title="1. 核心算法流程：递归穷举"></a>1. 核心算法流程：递归穷举</h2><p><code>model_check</code> 使用了一种深度优先的递归搜索算法（通常称为真值表枚举）：</p><ol><li><strong>收集符号</strong>：首先找出 <code>knowledge</code> 和 <code>query</code> 中出现的所有原子命题符号（如 <code>AKnight</code>, <code>AKnave</code>）。</li><li><strong>构建模型</strong>：模型（Model）是一个字典，为每个符号分配一个布尔值（<code>True</code> 或 <code>False</code>）。</li><li><strong>递归分支</strong>：</li></ol><ul><li>从符号集合中取出一个符号 。</li><li>分别创建一个  为 <code>True</code> 的分支和  为 <code>False</code> 的分支。</li><li>在每个分支中继续为剩余符号赋值，直到所有符号都被分配了真值。</li></ul><ol><li><strong>最终评估</strong>：当一个完整的模型建立后，评估该模型是否让 <code>knowledge</code> 为真。</li></ol><ul><li>如果 <code>knowledge</code> 在该模型下为 <strong>True</strong>，则必须检查 <code>query</code> 是否也为 <strong>True</strong>。</li><li>如果 <code>knowledge</code> 为 <strong>True</strong> 但 <code>query</code> 为 <strong>False</strong>，则推论失败，返回 <code>False</code>。</li></ul><hr><h2 id="2-详细案例分析：以-Puzzle-0-为例"><a href="#2-详细案例分析：以-Puzzle-0-为例" class="headerlink" title="2. 详细案例分析：以 Puzzle 0 为例"></a>2. 详细案例分析：以 Puzzle 0 为例</h2><p>假设我们要判断：在 <strong>Puzzle 0</strong> 的条件下，<strong>A 是否为骗子（AKnave）</strong>。</p><h3 id="初始条件"><a href="#初始条件" class="headerlink" title="初始条件"></a>初始条件</h3><ul><li><strong>符号集合</strong>：<code>&#123;AKnight, AKnave&#125;</code>。</li><li><strong>知识库 (<code>knowledge</code>)</strong>：</li></ul><ol><li><code>Or(AKnight, AKnave)</code>（A 是骑士或骗子）</li><li><code>Not(And(AKnight, AKnave))</code>（不能同时是两者）</li><li><code>Biconditional(AKnight, And(AKnight, AKnave))</code>（A 是骑士，当且仅当他说的话“我是骑士也是骗子”为真）</li></ol><ul><li><strong>查询句 (<code>query</code>)</strong>：<code>AKnave</code>。</li></ul><h3 id="递归遍历过程（真值表）"><a href="#递归遍历过程（真值表）" class="headerlink" title="递归遍历过程（真值表）"></a>递归遍历过程（真值表）</h3><p>AI 会遍历以下 4 个可能的模型：</p><div class="table-container"><table><thead><tr><th>模型 #</th><th>AKnight</th><th>AKnave</th><th>知识库 (<code>knowledge</code>) 评估</th><th>查询句 (<code>query</code>) 评估</th><th>结论</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>True</td><td>True</td><td><strong>False</strong> (违反互斥规则)</td><td>True</td><td>跳过</td></tr><tr><td><strong>2</strong></td><td>True</td><td>False</td><td><strong>False</strong> (违反说话规则： 为假)</td><td>False</td><td>跳过</td></tr><tr><td><strong>3</strong></td><td><strong>False</strong></td><td><strong>True</strong></td><td><strong>True</strong> (所有条件均满足)</td><td><strong>True</strong></td><td><strong>符合蕴含</strong></td></tr><tr><td><strong>4</strong></td><td>False</td><td>False</td><td><strong>False</strong> (违反完备规则)</td><td>True</td><td>跳过</td></tr></tbody></table></div><h3 id="逻辑判定"><a href="#逻辑判定" class="headerlink" title="逻辑判定"></a>逻辑判定</h3><p>在上述所有模型中，<strong>唯一一个</strong>能让 <code>knowledge</code> 为真的模型是 <strong>模型 3</strong>。在模型 3 中，<code>AKnave</code> 的值为 <code>True</code>。因此，AI 判定 <code>knowledge</code> 逻辑蕴含 <code>AKnave</code>，返回 <code>True</code>。</p><hr><h2 id="3-代码实现逻辑拆解"><a href="#3-代码实现逻辑拆解" class="headerlink" title="3. 代码实现逻辑拆解"></a>3. 代码实现逻辑拆解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_all</span>(<span class="hljs-params">knowledge, query, symbols, model</span>):<br>    <span class="hljs-comment"># 基准情况：如果符号集为空，说明模型已完整构建</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> symbols:<br>        <span class="hljs-comment"># 逻辑蕴含的定义：如果前提为真，结论必须为真</span><br>        <span class="hljs-keyword">if</span> knowledge.evaluate(model):<br>            <span class="hljs-keyword">return</span> query.evaluate(model)<br>        <span class="hljs-comment"># 如果前提为假，根据蕴含定义，该模型自动满足</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 递归步骤：选取一个符号</span><br>        remaining = symbols.copy()<br>        p = remaining.pop()<br><br>        <span class="hljs-comment"># 分支 1：假设 p 为真</span><br>        model_true = model.copy()<br>        model_true[p] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 分支 2：假设 p 为假</span><br>        model_false = model.copy()<br>        model_false[p] = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 只有两个分支都满足蕴含关系，才返回 True</span><br>        <span class="hljs-keyword">return</span> (check_all(knowledge, query, remaining, model_true) <span class="hljs-keyword">and</span><br>                check_all(knowledge, query, remaining, model_false))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂</title>
    <link href="/2026/01/21/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2026/01/21/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/快速幂/2026-01-21-21-35-09.png" alt=""></p><p>⚠️部分语言需要注意，当 $n = -2^{31}$ 时，$-n = 2^{31}$ 比 32 位整数的最大值还大，溢出了。可以转成 64 位整数解决。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> N)</span> &#123;<br>    <span class="hljs-type">double</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n = N;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// x^-n = (1/x)^n</span><br>        n = -n;<br>        x = <span class="hljs-number">1</span> / x;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (n) &#123; <span class="hljs-comment">// 从低到高枚举 n 的每个比特位</span><br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 这个比特位是 1</span><br>            ans *= x; <span class="hljs-comment">// 把 x 乘到 ans 中</span><br>        &#125;<br>        x *= x; <span class="hljs-comment">// x 自身平方</span><br>        n &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 继续枚举下一个比特位</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> N)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> N;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// x^-n = (1/x)^n</span><br>            n = -n;<br>            x = <span class="hljs-number">1</span> / x;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 从低到高枚举 n 的每个比特位</span><br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 这个比特位是 1</span><br>                ans *= x; <span class="hljs-comment">// 把 x 乘到 ans 中</span><br>            &#125;<br>            x *= x; <span class="hljs-comment">// x 自身平方</span><br>            n &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 继续枚举下一个比特位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS</tag>
      
      <tag>算法</tag>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维前缀和</title>
    <link href="/2026/01/21/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2026/01/21/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/二维前缀和/2026-01-21-21-39-29.png" alt=""></p><h1 id="算法核心笔记：二维前缀和-2D-Prefix-Sum"><a href="#算法核心笔记：二维前缀和-2D-Prefix-Sum" class="headerlink" title="算法核心笔记：二维前缀和 (2D Prefix Sum)"></a>算法核心笔记：二维前缀和 (2D Prefix Sum)</h1><blockquote><p><strong>核心洞察</strong>：二维前缀和是“容斥原理”在矩阵计算中的完美应用。它通过预处理，将任意子矩阵的和查询耗时从 $O(N \times M)$ 降低到惊人的 <strong>$O(1)$</strong>。</p></blockquote><hr><h2 id="一、-什么是二维前缀和？"><a href="#一、-什么是二维前缀和？" class="headerlink" title="一、 什么是二维前缀和？"></a>一、 什么是二维前缀和？</h2><p>如果说一维前缀和是计算“一段线段”的和，那么二维前缀和就是计算“一个矩形区域”内所有元素的总和。</p><h3 id="1-核心定义"><a href="#1-核心定义" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h3><p>我们定义一个二维数组 <code>sum[i+1][j+1]</code>，它代表：<br>以原点 <code>a[0][0]</code> 为左上角，到 <code>a[i][j]</code> 为右下角的这个<strong>大矩形</strong>中所有元素的和。</p><ul><li><strong>小技巧</strong>：为了处理边界情况（比如第一行或第一列），我们通常将前缀和数组的下标整体偏移 +1，即 <code>sum[0][0]</code> 默认为 0。</li></ul><hr><h2 id="二、-核心逻辑图解"><a href="#二、-核心逻辑图解" class="headerlink" title="二、 核心逻辑图解"></a>二、 核心逻辑图解</h2><h3 id="1-如何初始化（构建前缀和矩阵）？"><a href="#1-如何初始化（构建前缀和矩阵）？" class="headerlink" title="1. 如何初始化（构建前缀和矩阵）？"></a>1. 如何初始化（构建前缀和矩阵）？</h3><p>要算出 <code>sum[i+1][j+1]</code>，我们不能简单地加减，而是要利用已经算好的“左边”和“上边”的面积。</p><p><strong>公式：</strong></p><script type="math/tex; mode=display">sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + a[i][j]</script><p><strong>通俗解释：</strong></p><ul><li><strong>加上左边的面积</strong>：<code>sum[i+1][j]</code></li><li><strong>加上上边的面积</strong>：<code>sum[i][j+1]</code></li><li><strong>减去重叠的部分</strong>：由于左边和上边的面积都包含了左上角的 <code>sum[i][j]</code>，它被加了两次，所以要<strong>减去一次</strong>。</li><li><strong>加上当前格子的值</strong>：最后带上当前的 <code>a[i][j]</code>。</li></ul><hr><h3 id="2-如何计算任意子矩阵的元素和？"><a href="#2-如何计算任意子矩阵的元素和？" class="headerlink" title="2. 如何计算任意子矩阵的元素和？"></a>2. 如何计算任意子矩阵的元素和？</h3><p>假设我们要计算左上角为 <code>(r1, c1)</code>，右下角为 <code>(r2, c2)</code> 的子矩阵和。</p><p><strong>公式：</strong></p><script type="math/tex; mode=display">Result = sum[r2+1][c2+1] - sum[r2+1][c1] - sum[r1][c2+1] + sum[r1][c1]</script><p><strong>通俗解释（切蛋糕法）：</strong></p><ol><li>拿走右下角的大蛋糕：<code>sum[r2+1][c2+1]</code></li><li><strong>减去左侧多余的长条</strong>：<code>sum[r2+1][c1]</code></li><li><strong>减去上方多余的长条</strong>：<code>sum[r1][c2+1]</code></li><li><strong>补回多减的角</strong>：在减去左侧和上方长条时，左上角的重叠区域 <code>sum[r1][c1]</code> 被多减了一次，所以要<strong>加回来</strong>。</li></ol><hr><h2 id="三、-代码实现"><a href="#三、-代码实现" class="headerlink" title="三、 代码实现"></a>三、 代码实现</h2><h3 id="1-C-语言实现-接口封装"><a href="#1-C-语言实现-接口封装" class="headerlink" title="1. C 语言实现 (接口封装)"></a>1. C 语言实现 (接口封装)</h3><p>在 LeetCode 的 C 语言模式下，通常使用结构体来模拟类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span>** preSum;<br>    <span class="hljs-type">int</span> rowSize;<br>    <span class="hljs-type">int</span> colSize;<br>&#125; NumMatrix;<br><br><span class="hljs-comment">/** 构造函数：预处理前缀和矩阵 */</span><br>NumMatrix* <span class="hljs-title function_">numMatrixCreate</span><span class="hljs-params">(<span class="hljs-type">int</span>** matrix, <span class="hljs-type">int</span> matrixSize, <span class="hljs-type">int</span>* matrixColSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (matrixSize == <span class="hljs-number">0</span> || matrixColSize[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <br>    NumMatrix* obj = (NumMatrix*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(NumMatrix));<br>    <span class="hljs-type">int</span> rows = matrixSize;<br>    <span class="hljs-type">int</span> cols = matrixColSize[<span class="hljs-number">0</span>];<br>    obj-&gt;rowSize = rows;<br>    obj-&gt;colSize = cols;<br>    <br>    <span class="hljs-comment">// 分配 preSum 空间 (rows + 1) x (cols + 1)</span><br>    obj-&gt;preSum = (<span class="hljs-type">int</span>**)<span class="hljs-built_in">malloc</span>((rows + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>*));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= rows; i++) &#123;<br>        obj-&gt;preSum[i] = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">calloc</span>((cols + <span class="hljs-number">1</span>), <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// calloc 自动初始化为0</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 填充前缀和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;<br>            obj-&gt;preSum[i][j] = obj-&gt;preSum[i - <span class="hljs-number">1</span>][j] + <br>                                obj-&gt;preSum[i][j - <span class="hljs-number">1</span>] - <br>                                obj-&gt;preSum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <br>                                matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-comment">/** 查询函数：O(1) 时间获取子矩阵和 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">numMatrixSumRegion</span><span class="hljs-params">(NumMatrix* obj, <span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> &#123;<br>    <span class="hljs-comment">// 转换到 preSum 的 1-based 下标</span><br>    <span class="hljs-keyword">return</span> obj-&gt;preSum[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - <br>           obj-&gt;preSum[row1][col2 + <span class="hljs-number">1</span>] - <br>           obj-&gt;preSum[row2 + <span class="hljs-number">1</span>][col1] + <br>           obj-&gt;preSum[row1][col1];<br>&#125;<br><br><span class="hljs-comment">/** 析构函数：释放内存 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">numMatrixFree</span><span class="hljs-params">(NumMatrix* obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= obj-&gt;rowSize; i++) &#123;<br>        <span class="hljs-built_in">free</span>(obj-&gt;preSum[i]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(obj-&gt;preSum);<br>    <span class="hljs-built_in">free</span>(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Java-实现-经典类封装"><a href="#2-Java-实现-经典类封装" class="headerlink" title="2. Java 实现 (经典类封装)"></a>2. Java 实现 (经典类封装)</h3><p>Java 版更加简洁，利用数组初始值为 0 的特性简化了代码。</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] preSum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>            <span class="hljs-comment">// preSum[i][j] 表示从 matrix[0][0] 到 matrix[i-1][j-1] 的总和</span><br>            preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                    preSum[i][j] = preSum[i - <span class="hljs-number">1</span>][j] + <br>                                   preSum[i][j - <span class="hljs-number">1</span>] - <br>                                   preSum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <br>                                   matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> &#123;<br>        <span class="hljs-comment">// 利用容斥原理：大矩形 - 上方长条 - 左侧长条 + 重叠角落</span><br>        <span class="hljs-keyword">return</span> preSum[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - <br>               preSum[row1][col2 + <span class="hljs-number">1</span>] - <br>               preSum[row2 + <span class="hljs-number">1</span>][col1] + <br>               preSum[row1][col1];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></h2><h2 id="四、-避坑指南"><a href="#四、-避坑指南" class="headerlink" title="四、 避坑指南"></a>四、 避坑指南</h2><ol><li><strong>下标偏移</strong>：强烈建议 <code>sum</code> 数组多开一行一列（即 <code>n+1, m+1</code>），这能避免判断 <code>i-1</code> 是否越界。</li><li><strong>数据溢出</strong>：对于较大的矩阵或元素，<code>sum</code> 数组一定要使用 <code>long long</code> (C++) 或 <code>long</code> (Java)，否则容易发生溢出。</li><li><strong>坐标对应</strong>：计算时要注意题目给出的是“下标”还是“第几个数”，确保 <code>r1, c1</code> 与 <code>sum</code> 数组的对应关系正确。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS</tag>
      
      <tag>算法</tag>
      
      <tag>二维前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模运算</title>
    <link href="/2026/01/21/%E6%A8%A1%E8%BF%90%E7%AE%97/"/>
    <url>/2026/01/21/%E6%A8%A1%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/">https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/</a></p><h1 id="分享丨模运算的世界：当加减乘除遇上取模（模运算恒等式-费马小定理-组合数）"><a href="#分享丨模运算的世界：当加减乘除遇上取模（模运算恒等式-费马小定理-组合数）" class="headerlink" title="分享丨模运算的世界：当加减乘除遇上取模（模运算恒等式/费马小定理/组合数）"></a>分享丨模运算的世界：当加减乘除遇上取模（模运算恒等式/费马小定理/组合数）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>某些题目，由于要计算的答案非常大（超出 64 位整数的范围），会要求把答案对 10⁹+7 取模。如果没有处理得当的话，会 WA（错误）或者 TLE（超时）。</p><p>例如计算一堆数字的乘积，如果没有及时取模，乘法会溢出（例如计算结果超出 C++ 中 <code>long long</code> 的最大值），从而得到和预期不符的答案。对于 Python 来说，虽然没有溢出的问题，但大整数（big integer）之间的运算并不是 O(1) 的，可能会导致 TLE。</p><p>如何正确地取模呢？</p><hr><h2 id="加法和乘法的取模"><a href="#加法和乘法的取模" class="headerlink" title="加法和乘法的取模"></a>加法和乘法的取模</h2><p>如果让你计算 <code>1234 × 6789</code> 的个位数，你会如何计算？</p><p>由于只有个位数会影响到乘积的个位数，那么 <code>4 × 9 = 36</code> 的个位数 6 就是答案。</p><p>对于 <code>1234 + 6789</code> 的个位数，同理，<code>4 + 9 = 13</code> 的个位数 3 就是答案。</p><p>你能把这个结论抽象成数学等式吗？</p><p>一般涉及到取模的题目，会用到如下两个恒等式，其中 mod 表示取模运算（modulo），即编程语言中的 <code>%</code>。上面计算的是 m=10 的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(a + b) mod m = ((a mod m) + (b mod m)) mod m<br>(a ⋅ b) mod m = ((a mod m) ⋅ (b mod m)) mod m<br></code></pre></td></tr></table></figure><p>证明：根据带余除法，任意整数 a 都可以表示为 <code>a = q m + r</code>（m ≠ 0），其中整数 q 为 a 除以 m 的商（quotient），整数 r 为 a 除以 m 的余数（remainder），即 r = a mod m。</p><p>设整数 a = q₁ m + r₁，b = q₂ m + r₂。</p><p>第一个恒等式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">(a + b) mod m <br>= ((q₁ + q₂)m + r₁ + r₂) mod m <br>= (r₁ + r₂) mod m <br>= ((a mod m) + (b mod m)) mod m<br></code></pre></td></tr></table></figure><p>第二个恒等式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">(a⋅b) mod m<br>= (q₁q₂m² + (q₁r₂+q₂r₁)m + r₁r₂) mod m<br>= (r₁r₂) mod m<br>= ((a mod m)⋅(b mod m)) mod m<br></code></pre></td></tr></table></figure><p>根据这两个恒等式，我们可以在计算过程中（例如循环），对加法和乘法的结果取模，而不是在循环结束后再取模。</p><p>注：如果涉及到幂运算，指数是不能随意取模的。如果指数在 64 位整数的范围内，可以用快速幂计算；如果指数超出范围，则需要使用欧拉降幂等技巧。</p><hr><h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><p>首先引入 同余（congruence modulo）的概念。</p><p>两个整数 x 和 y，如果 <code>(x − y) mod m = 0</code>（也就是 x − y 是 m 的倍数），则称 x 与 y 关于模 m 同余，记作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x ≡ y (mod m)<br></code></pre></td></tr></table></figure><p>上式也称作模 m 的同余式，简称同余式。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">42</span> ≡ <span class="hljs-number">12</span> (mod <span class="hljs-number">10</span>)<br>−<span class="hljs-number">17</span> ≡ <span class="hljs-number">3</span> (mod <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>特别地：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">m ≡ <span class="hljs-number">0</span> (mod m)<br></code></pre></td></tr></table></figure><hr><h2 id="同余式的移项"><a href="#同余式的移项" class="headerlink" title="同余式的移项"></a>同余式的移项</h2><p>同余式中的加减法可以移项。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a + b ≡ c + d (mod m)<br></code></pre></td></tr></table></figure><p>可以移项得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a − c ≡ d − b (mod m)<br></code></pre></td></tr></table></figure><p>推论：在同余式两边加上或减去同一个数，同余式仍然成立。</p><p>特别地，在同余式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0</span> ≡ m (mod m)<br></code></pre></td></tr></table></figure><p>的两边加上 −x，得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">−x ≡ m − x (mod m)<br></code></pre></td></tr></table></figure><p>例如在无符号 32 位整数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">−<span class="hljs-number">1</span> ≡ <span class="hljs-number">4294967295</span> (mod <span class="hljs-number">2</span>³²)<br></code></pre></td></tr></table></figure><hr><h2 id="负数和减法的取模"><a href="#负数和减法的取模" class="headerlink" title="负数和减法的取模"></a>负数和减法的取模</h2><p>根据同余的定义，我们有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">−<span class="hljs-number">17</span> ≡ <span class="hljs-number">3</span> (mod <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>怎么从 −17 得到 3？</p><p>我们可以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">−<span class="hljs-number">17</span> + <span class="hljs-number">10</span> + <span class="hljs-number">10</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>也可以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">−<span class="hljs-number">17</span> mod <span class="hljs-number">10</span> + <span class="hljs-number">10</span> = −<span class="hljs-number">7</span> + <span class="hljs-number">10</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>这样只需加一次 m。</p><p>一般地，如果 x &lt; 0 且 0 ≤ y &lt; m，则 x ≡ y (mod m) 相当于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x mod m + m = y<br></code></pre></td></tr></table></figure><p>也就是用「模 m 加 m」，把 x「调整」为非负数。</p><p>为了避免判断 x &lt; 0，可以统一写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(x mod m + m) mod m<br></code></pre></td></tr></table></figure><p>这样无论 x 是正是负还是零，运算结果都会落在区间 [0, m − 1] 中。</p><p>对于减法来说，当 a − b ≥ 0 时，取模可以写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(a − b) mod m<br>= ((a mod m) − (b mod m) + m) mod m<br></code></pre></td></tr></table></figure><p>注：</p><ul><li>在代码实现时，在计算中产生负数也可以，在最后用 <code>(x mod m + m) mod m</code> 调整就行。</li><li>Python 用户可以忽略，只要 m 是正整数，取模运算结果就一定是非负的。</li></ul><hr><h2 id="除法的取模"><a href="#除法的取模" class="headerlink" title="除法的取模"></a>除法的取模</h2><p>如果要计算 $\frac{24}{8} \bmod 5$，可以像加法或乘法那样，写成 $\frac{24 \bmod 5}{8 \bmod 5} \bmod 5$ 吗？这不行，$\frac{24 \bmod 5}{8 \bmod 5} = \frac{4}{3}$ 甚至不是一个整数。</p><p>先说结论，如果 $p$ 是一个质数，$a$ 是 $b$ 的倍数且 $b$ 和 $p$ 互质（$b$ 不是 $p$ 的倍数），那么有</p><script type="math/tex; mode=display">\frac{a}{b} \bmod p = (a \cdot b^{p-2}) \bmod p</script><p>上式中 $a$ 和 $b$ 可以是很大的数，例如 $a = 100!, b = 50!50!$。</p><p>由于 $10^9 + 7$ 是一个质数，所以上式可用于要求对 $10^9 + 7$ 取模的题目。如果推导出了包含除法的式子，可以用上式转换成乘法，并用快速幂计算 $b^{p-2} \bmod p$。</p><p>下面是证明。</p><p><strong>引理 1：</strong> 当 $p$ 是质数且 $1 \le i \le p - 1$ 时，有</p><script type="math/tex; mode=display">\binom{p}{i} \equiv 0 \pmod p</script><p>其中</p><script type="math/tex; mode=display">\binom{p}{i} = \frac{p!}{i!(p - i)!}</script><p><strong>证明：</strong> 注意当 $1 \le i \le p - 1$ 时，$\frac{p!}{i!(p - i)!}$ 的分母是不包含 $p$ 的。由于分子包含 $p$ 且 $\frac{p!}{i!(p - i)!}$ 是整数，所以 $\binom{p}{i}$ 可以被 $p$ 整除，即 $\binom{p}{i} \equiv 0 \pmod p$。</p><p><strong>注：</strong> 如果 $p$ 不是质数，分母可能被 $p$ 整除，上面的结论不一定成立。例如 $p = 4, i = 2$ 的情况，$\binom{p}{i} = 6$，不是 $p = 4$ 的倍数。</p><p><strong>引理 2：</strong> 对于任意整数 $x$ 和 $y$ 和任意质数 $p$，有</p><script type="math/tex; mode=display">(x + y)^p \equiv x^p + y^p \pmod p</script><p><strong>证明：</strong> 根据二项式定理，有</p><script type="math/tex; mode=display">(x + y)^p = \binom{p}{0}x^p y^0 + \binom{p}{1}x^{p-1} y^1 + \binom{p}{2}x^{p-2} y^2 + \dots + \binom{p}{p-1}x^1 y^{p-1} + \binom{p}{p}x^0 y^p</script><p>根据引理 1，除了第一项和最后一项以外，其余项都是 $p$ 的倍数，于是</p><p><strong>定理</strong>（费马小定理）：对于任意整数 $b$ 和任意质数 $p$，有 <script type="math/tex">b^p \equiv b \pmod p</script> <strong>证明</strong>：当 $b = 0$ 时，$0^p \equiv 0 \pmod p$ 成立。 假设 $b = k$ 时原命题成立，即 <script type="math/tex">k^p \equiv k \pmod p</script> 根据引理 2，我们有 <script type="math/tex">(k + 1)^p \equiv k^p + 1^p \pmod p</script> 根据归纳假设，得 <script type="math/tex">(k + 1)^p \equiv k + 1 \pmod p</script> 即当 $b = k + 1$ 时，原命题成立。 根据数学归纳法，原命题对于 $b \ge 0$ 成立。对于 $b &lt; 0$ 的情况同理。 $b^p \equiv b \pmod p$ 变形得 $b(b^{p-1} - 1) \equiv 0 \pmod p$，如果 $b$ 不是 $p$ 的倍数，那么 $b^{p-1} - 1$ 必须是 $p$ 的倍数（注意 $p$ 是质数），即 $b^{p-1} - 1 \equiv 0 \pmod p$，移项得 <script type="math/tex">b^{p-1} \equiv 1 \pmod p</script> 两边同时乘以 $\frac{a}{b}$（$a$ 是 $b$ 的倍数），得 <script type="math/tex">a \cdot b^{p-2} \equiv \frac{a}{b} \pmod p</script> 即 <script type="math/tex">\frac{a}{b} \bmod p = (a \cdot b^{p-2}) \bmod p</script> 注：除以 $b$ 相当于乘以 $b$ 的<strong>逆元</strong> $b^{-1} \bmod p$。在概率期望等题目中，会遇到 $a$ 不是 $b$ 的倍数的情况，这些题目通常会规定计算 $(a \cdot b^{-1}) \bmod p$，计算方法和上式一样。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码实现时，上面的加减乘除通常是这样写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs python">MOD = <span class="hljs-number">1_000_000_007</span><br><br>// 加<br>(a + b) % MOD<br><br>// 减，b 在 [<span class="hljs-number">0</span>,MOD-<span class="hljs-number">1</span>] 中<br>(a - b + MOD) % MOD<br><br>// 把任意整数 a 取模到 [<span class="hljs-number">0</span>,MOD-<span class="hljs-number">1</span>] 中，无论 a 是正是负<br>(a % MOD + MOD) % MOD<br><br>// 乘（注意使用 <span class="hljs-number">64</span> 位整数）<br>a * b % MOD<br><br>// 多个数相乘，要步步取模，防止溢出<br>a * b % MOD * c % MOD<br><br>// 除（MOD 是质数且 b 不是 MOD 的倍数）<br>a * qpow(b, MOD - <span class="hljs-number">2</span>, MOD) % MOD<br>````<br><br>其中 `qpow` 为**快速幂**，具体请看【图解】一张图秒懂快速幂。<br><br>&gt; 注：Python 内置快速幂函数 `<span class="hljs-built_in">pow</span>(x, y, m)` 用于计算 $x^y \bmod m$。特别地，除法也可以写成 `a * <span class="hljs-built_in">pow</span>(b, -<span class="hljs-number">1</span>, MOD) % MOD`。<br><br>总之，如果发现解答错误，可以检查下代码，看看是不是哪里漏掉取模了。<br><br>---<br><br><span class="hljs-comment">## 附：组合数的计算</span><br><br>关于组合数，我们需要预处理阶乘及其逆元，然后利用公式<br><br>$$C(n,m) = \frac&#123;n!&#125;&#123;m!(n-m)!&#125; = n! \cdot \frac&#123;<span class="hljs-number">1</span>&#125;&#123;m!&#125; \cdot \frac&#123;<span class="hljs-number">1</span>&#125;&#123;(n-m)!&#125;$$<br><br>计算。<br><br>对于阶乘 $n!$，可以用<br><br>$$n! = (n - <span class="hljs-number">1</span>)! \cdot n$$<br><br>递推计算。<br><br>对于阶乘的倒数 $\frac&#123;<span class="hljs-number">1</span>&#125;&#123;n!&#125;$，可以先计算 $N!$ 的逆元（其中 $N$ 是 $n$ 的最大值），然后用<br><br>$$\frac&#123;<span class="hljs-number">1</span>&#125;&#123;(n-<span class="hljs-number">1</span>)!&#125; = \frac&#123;<span class="hljs-number">1</span>&#125;&#123;n!&#125; \cdot n$$<br><br>倒着递推计算。<br><br>模板代码如下：<br><br>```java<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    private static final <span class="hljs-built_in">int</span> MOD = <span class="hljs-number">1_000_000_007</span>;<br>    private static final <span class="hljs-built_in">int</span> MX = <span class="hljs-number">100_001</span>; // 根据题目数据范围修改<br><br>    private static final long[] F = new long[MX]; // F[i] = i!<br>    private static final long[] INV_F = new long[MX]; // INV_F[i] = i!^-<span class="hljs-number">1</span> = <span class="hljs-built_in">pow</span>(i!, MOD-<span class="hljs-number">2</span>)<br><br>    static &#123;<br>        F[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; MX; i++) &#123;<br>            F[i] = F[i - <span class="hljs-number">1</span>] * i % MOD;<br>        &#125;<br><br>        INV_F[MX - <span class="hljs-number">1</span>] = <span class="hljs-built_in">pow</span>(F[MX - <span class="hljs-number">1</span>], MOD - <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = MX - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            INV_F[i - <span class="hljs-number">1</span>] = INV_F[i] * i % MOD;<br>        &#125;<br>    &#125;<br><br>    private static long <span class="hljs-built_in">pow</span>(long x, <span class="hljs-built_in">int</span> n) &#123;<br>        long res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (; n &gt; <span class="hljs-number">0</span>; n /= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) &#123;<br>                res = res * x % MOD;<br>            &#125;<br>            x = x * x % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    // 从 n 个数中选 m 个数的方案数<br>    private long comb(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> m) &#123;<br>        <span class="hljs-keyword">return</span> m &lt; <span class="hljs-number">0</span> || m &gt; n ? <span class="hljs-number">0</span> : F[n] * INV_F[m] % MOD * INV_F[n - m] % MOD;<br>    &#125;<br><br>    public <span class="hljs-built_in">int</span> solve(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        // 预处理的逻辑写在 static 块中，这样只会初始化一次<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果模数不是质数呢？见 <a href="https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-ii/">3463. 判断操作后字符串中的数字是否相等 II</a>。</p><h2 id="取模练习"><a href="#取模练习" class="headerlink" title="取模练习"></a>取模练习</h2><ul><li><a href="https://leetcode.cn/problems/transformed-array/">3379. 转换数组</a> 做到</li><li><a href="https://leetcode.cn/problems/binary-prefix-divisible-by-5/">1018. 可被 5 整除的二进制前缀</a> 1376</li></ul><h2 id="快速幂练习"><a href="#快速幂练习" class="headerlink" title="快速幂练习"></a>快速幂练习</h2><ul><li><a href="https://leetcode.cn/problems/double-modular-exponentiation/">2961. 双模幂运算</a> 1451</li><li><a href="https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/">2550. 猴子碰撞的方法数</a> 1663</li><li><a href="https://leetcode.cn/problems/super-pow/">372. 超级次方</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS</tag>
      
      <tag>算法</tag>
      
      <tag>模运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50AI note1</title>
    <link href="/2026/01/14/CS50%20AI%20note%201/"/>
    <url>/2026/01/14/CS50%20AI%20note%201/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Lecture-1"><a href="#Lecture-1" class="headerlink" title="Lecture 1"></a><a href="https://cs50.harvard.edu/ai/notes/1/#lecture-1">Lecture 1</a></h1><h1 id="Knowledge"><a href="#Knowledge" class="headerlink" title="Knowledge"></a><a href="https://cs50.harvard.edu/ai/notes/1/#knowledge">Knowledge</a></h1><p>人类会基于已有知识进行推理并得出结论。AI 中也同样会用“表示知识 + 从知识中推出结论”的概念。在这一讲中，我们将探索如何实现这种行为。</p><h2 id="知识型智能体（Knowledge-Based-Agents）"><a href="#知识型智能体（Knowledge-Based-Agents）" class="headerlink" title="知识型智能体（Knowledge-Based Agents）"></a>知识型智能体（Knowledge-Based Agents）</h2><p>这些智能体通过对内部的知识表示进行运算，从而完成推理。</p><p>那么，“基于知识推理并得出结论”到底是什么意思？</p><p>我们用一个《哈利·波特》的例子开始。考虑下面这些句子：</p><ol><li>如果今天没有下雨，Harry 今天去看了 Hagrid。</li><li>Harry 今天要么去看了 Hagrid，要么去看了 Dumbledore，但不能两个都去。</li><li>Harry 今天去看了 Dumbledore。</li></ol><p>根据这三句话，我们可以回答问题：“今天下雨了吗？”，尽管每一句都没有直接告诉我们今天是否下雨。推理过程如下：</p><p>观察句子 3，我们知道 Harry 去了 Dumbledore。<br>观察句子 2，我们知道 Harry 去了 Dumbledore 或 Hagrid（二者之一），因此我们可以推出：</p><ol><li>Harry 今天没有去看 Hagrid。</li></ol><p>再观察句子 1，我们知道：如果今天没有下雨，那么 Harry 会去看 Hagrid。<br>但根据句子 4，我们知道 Harry 并没有去看 Hagrid，因此可以推出：</p><ol><li>今天下雨了。</li></ol><p>为了得出这个结论，我们使用了<strong>逻辑（logic）</strong>。这一讲将探索 AI 如何利用逻辑从已有信息推出新的结论。</p><hr><h2 id="句子（Sentence）"><a href="#句子（Sentence）" class="headerlink" title="句子（Sentence）"></a>句子（Sentence）</h2><p>句子是对世界的断言，存在于某种知识表示语言中。句子是 AI 存储知识并据此推理新信息的方式。</p><hr><h1 id="Propositional-Logic"><a href="#Propositional-Logic" class="headerlink" title="Propositional Logic"></a><a href="https://cs50.harvard.edu/ai/notes/1/#propositional-logic">Propositional Logic</a></h1><p>命题逻辑基于命题（propositions）：对世界的陈述，它们要么为真，要么为假（就像上面的句子 1-5）。</p><h2 id="命题符号（Propositional-Symbols）"><a href="#命题符号（Propositional-Symbols）" class="headerlink" title="命题符号（Propositional Symbols）"></a>命题符号（Propositional Symbols）</h2><p>命题符号通常用字母（P, Q, R）表示，用来代表一个命题。</p><h2 id="逻辑连接词（Logical-Connectives）"><a href="#逻辑连接词（Logical-Connectives）" class="headerlink" title="逻辑连接词（Logical Connectives）"></a>逻辑连接词（Logical Connectives）</h2><p>逻辑连接词是逻辑符号，用来连接命题符号，从而更复杂地推理世界。</p><h3 id="否定（Not-¬）"><a href="#否定（Not-¬）" class="headerlink" title="否定（Not, ¬）"></a>否定（Not, ¬）</h3><p>否定会反转命题的真值。例如若 P：“正在下雨”，则 ¬P：“没有下雨”。</p><p>真值表（truth tables）用于枚举所有可能的真值赋值，从而比较不同连接词下命题的真值。下面是第一个真值表例子：</p><h3 id="与（And-∧）"><a href="#与（And-∧）" class="headerlink" title="与（And, ∧）"></a>与（And, ∧）</h3><p>当两个命题 P 和 Q 用 ∧ 连接时，P ∧ Q 仅在 P 和 Q 都为真时为真。</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P ∧ Q</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><h3 id="或（Or-∨）"><a href="#或（Or-∨）" class="headerlink" title="或（Or, ∨）"></a>或（Or, ∨）</h3><p>P ∨ Q 只要任一参数为真即为真。也就是说，P ∨ Q 为真要求 P 或 Q 至少一个为真。</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P ∨ Q</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>true</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><p>值得一提的是，“或”有两种：<strong>包含式或（inclusive Or）</strong>与<strong>排他式或（exclusive Or）</strong>。<br>在排他式或中，如果 P ∧ Q 为真，则 P ∨ Q 为假：也就是要求只能一个为真，不能都为真。<br>包含式或在 P、Q 或 P ∧ Q 为真时都为真。这里的 Or（∨）默认指<strong>包含式或</strong>。</p><blockquote><p>旁注（课堂没提到）：</p><ul><li>一个例子可帮助理解包含式 vs 排他式：<ul><li>包含式：为了吃甜点，你必须“打扫房间<strong>或</strong>割草”。如果两个都做了，也依然能吃到饼干。</li><li>排他式：甜点你可以吃“曲奇<strong>或</strong>冰淇淋”。这时不能两个都吃。</li></ul></li><li>排他式或常缩写为 XOR，常用符号 ⊕。</li></ul></blockquote><h3 id="蕴含（Implication-→）"><a href="#蕴含（Implication-→）" class="headerlink" title="蕴含（Implication, →）"></a>蕴含（Implication, →）</h3><p>蕴含表示“如果 P，那么 Q”。例如：</p><ul><li>P：“正在下雨”</li><li>Q：“我在室内”<br>则 P → Q 表示：“如果下雨，那么我在室内。”<br>其中 P 称为<strong>前件（antecedent）</strong>，Q 称为<strong>后件（consequent）</strong>。</li></ul><p>当<strong>前件为真</strong>时，整个蕴含在<strong>后件为真</strong>时为真（下雨且在室内，则“如果下雨我在室内”是真的）。<br>当<strong>前件为真</strong>时，如果<strong>后件为假</strong>，则蕴含为假（下雨却在室外，“如果下雨我在室内”为假）。<br>然而当<strong>前件为假</strong>时，不论后件如何，蕴含都为真。这可能令人困惑：逻辑上，若 P 为假，则从 P → Q 中无法推出关于 Q 的任何信息。<br>在例子中：如果没下雨，那么蕴含并没有说明我是否在室内；我可能一直在室内，也可能一直在室外。<br>因此当前件为假时，我们称蕴含为<strong>平凡真（trivially true）</strong>。</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P → Q</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>true</td></tr><tr><td>false</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><h3 id="双条件（Biconditional-↔）"><a href="#双条件（Biconditional-↔）" class="headerlink" title="双条件（Biconditional, ↔）"></a>双条件（Biconditional, ↔）</h3><p>双条件是双向的蕴含，可读作“当且仅当”。<br>P ↔ Q 等价于 (P → Q) 与 (Q → P) 同时成立。</p><p>例如：</p><ul><li>P：“正在下雨”</li><li>Q：“我在室内”<br>P ↔ Q 表示：“如果下雨则我在室内”并且“如果我在室内则下雨”。<br>这比单向蕴含能推出更多信息：如果 P 为假，那么 Q 也为假；如果没下雨，则我也不在室内。</li></ul><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P ↔ Q</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>true</td></tr><tr><td>false</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><hr><h2 id="模型（Model）"><a href="#模型（Model）" class="headerlink" title="模型（Model）"></a>模型（Model）</h2><p>模型是对每个命题都赋予真值的一种赋值方式。再次强调，命题是可以为真或假的世界陈述；世界知识体现在这些命题的真值上。模型就是这种真值赋值，它描述了一个可能的世界。</p><p>例如：</p><ul><li>P：“正在下雨”</li><li>Q：“今天是星期二”<br>一种模型可以是：{P = True, Q = False}<br>这表示：下雨，但不是星期二。</li></ul><p>当然还有其他可能模型，例如 {P=True, Q=True} 表示既下雨又是星期二。<br>一般来说，n 个命题会有 2^n 种可能模型。这里 n=2，所以 2²=4 种。</p><hr><h2 id="知识库（Knowledge-Base-KB）"><a href="#知识库（Knowledge-Base-KB）" class="headerlink" title="知识库（Knowledge Base, KB）"></a>知识库（Knowledge Base, KB）</h2><p>知识库是一组句子（sentences），它们是知识型智能体已知为真的知识集合。<br>AI 以命题逻辑句子的形式获得这些关于世界的信息，并利用它们进行额外推理。</p><hr><h2 id="蕴含（Entailment-⊨）"><a href="#蕴含（Entailment-⊨）" class="headerlink" title="蕴含（Entailment, ⊨）"></a>蕴含（Entailment, ⊨）</h2><p>若 α ⊨ β（α 蕴含 β），则在任何 α 为真的世界里，β 也为真。</p><p>例如：</p><ul><li>α：“一月的某个星期二”</li><li>β：“是一月”<br>则 α ⊨ β。若真的是“一月的星期二”，必然是在一月。</li></ul><p>蕴含不同于蕴含连接词（implication）。  </p><ul><li><strong>Implication（→）</strong>是逻辑连接词，把两个命题连成一个复合命题。  </li><li><strong>Entailment（⊨）</strong>是关系：当 α 中所有信息为真时，β 也必为真。</li></ul><hr><h1 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a><a href="https://cs50.harvard.edu/ai/notes/1/#inference">Inference</a></h1><p>推理（Inference）是从旧句子推导出新句子的过程。</p><p>例如，在前面的哈利波特例子中，句子 4 和 5 是由 1、2、3 推导出来的。</p><p>从已有知识中推出新知识有多种方法。首先我们考虑 <strong>模型检测（Model Checking）</strong>算法。</p><h2 id="模型检测（Model-Checking）"><a href="#模型检测（Model-Checking）" class="headerlink" title="模型检测（Model Checking）"></a>模型检测（Model Checking）</h2><p>为了判断 KB ⊨ α（即回答：“我们能否仅依据 KB 推出 α 为真？”）：</p><ul><li>枚举所有可能模型</li><li>若在所有使 KB 为真的模型中，α 也为真，则 KB 蕴含 α（KB ⊨ α）</li></ul><p>考虑例子：</p><ul><li>P：今天是星期二  </li><li>Q：正在下雨  </li><li>R：Harry 会去跑步  </li><li>KB：(P ∧ ¬Q) → R（即：P 且不 Q 蕴含 R）  </li><li>KB 还包含：P（P 为真）、¬Q（Q 为假）  </li><li>Query：R（我们想知道 KB 是否蕴含 R）</li></ul><p>枚举所有模型（3 个命题 → 2^3=8 行）：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>R</th><th>KB</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td><td></td></tr><tr><td>false</td><td>false</td><td>true</td><td></td></tr><tr><td>false</td><td>true</td><td>false</td><td></td></tr><tr><td>false</td><td>true</td><td>true</td><td></td></tr><tr><td>true</td><td>false</td><td>false</td><td></td></tr><tr><td>true</td><td>false</td><td>true</td><td></td></tr><tr><td>true</td><td>true</td><td>false</td><td></td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><p>逐步筛掉与 KB 不一致的模型：</p><p>1）KB 中包含 P 为真 → 所有 P 为 false 的行都让 KB 为 false：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>R</th><th>KB</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>false</td><td>true</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td><td></td></tr><tr><td>true</td><td>false</td><td>true</td><td></td></tr><tr><td>true</td><td>true</td><td>false</td><td></td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><p>2）KB 中包含 ¬Q → 所有 Q 为 true 的行都让 KB 为 false：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>R</th><th>KB</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>false</td><td>true</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td><td></td></tr><tr><td>true</td><td>false</td><td>true</td><td></td></tr><tr><td>true</td><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td><td>false</td></tr></tbody></table></div><p>3）只剩两行：P=true 且 Q=false。<br>由于 KB 有 (P ∧ ¬Q) → R，所以在 P=true 且 Q=false 时，R 必须为真。<br>因此 R=false 那一行 KB 为 false，而 R=true 那一行 KB 为 true：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>R</th><th>KB</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>false</td><td>true</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td><td>false</td></tr><tr><td>true</td><td>false</td><td>true</td><td>true</td></tr><tr><td>true</td><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td><td>false</td></tr></tbody></table></div><p>最终只有一个模型使 KB 为真，而在该模型里 R 也为真。<br>所以 KB ⊨ R。</p><hr><p>接下来我们看如何用代码表示知识与逻辑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> logic <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 为每个命题创建一个符号（Symbol）</span><br>rain = Symbol(<span class="hljs-string">&quot;rain&quot;</span>)              <span class="hljs-comment"># 正在下雨</span><br>hagrid = Symbol(<span class="hljs-string">&quot;hagrid&quot;</span>)          <span class="hljs-comment"># Harry 去看了 Hagrid</span><br>dumbledore = Symbol(<span class="hljs-string">&quot;dumbledore&quot;</span>)  <span class="hljs-comment"># Harry 去看了 Dumbledore</span><br><br><span class="hljs-comment"># 将句子保存进 KB（knowledge）</span><br>knowledge = And(<br>    Implication(Not(rain), hagrid),        <span class="hljs-comment"># ¬rain → hagrid</span><br>    Or(hagrid, dumbledore),                <span class="hljs-comment"># hagrid ∨ dumbledore</span><br>    Not(And(hagrid, dumbledore)),          <span class="hljs-comment"># ¬(hagrid ∧ dumbledore)</span><br>    dumbledore                             <span class="hljs-comment"># dumbledore 为真（事实）</span><br>)<br></code></pre></td></tr></table></figure><p>要运行模型检测算法，需要：</p><ul><li><p>Knowledge Base（知识库）</p></li><li><p>Query（查询命题）</p></li><li><p>Symbols（所有原子命题符号列表）</p></li><li><p>Model（对符号的真值赋值）</p></li></ul><p>模型检测算法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_all</span>(<span class="hljs-params">knowledge, query, symbols, model</span>):<br><br>    <span class="hljs-comment"># 如果 model 已经对每个 symbol 赋值</span><br>    <span class="hljs-comment"># （这里的逻辑可能有点绕：symbols 初始是符号列表。函数递归，每次弹出一个 symbol 并据此生成模型。</span><br>    <span class="hljs-comment"># 当 symbols 为空，表示所有符号都已被赋值，因此我们完成了所有可能模型的生成。）</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> symbols:<br><br>        <span class="hljs-comment"># 如果 KB 在该 model 下为真，则 query 必须也为真</span><br>        <span class="hljs-keyword">if</span> knowledge.evaluate(model):<br>            <span class="hljs-keyword">return</span> query.evaluate(model)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br><br>        <span class="hljs-comment"># 选择一个尚未使用的符号</span><br>        remaining = symbols.copy()<br>        p = remaining.pop()<br><br>        <span class="hljs-comment"># 创建 p 为真的 model</span><br>        model_true = model.copy()<br>        model_true[p] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 创建 p 为假的 model</span><br>        model_false = model.copy()<br>        model_false[p] = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 在两种 model 下都必须成立（保证蕴含）</span><br>        <span class="hljs-keyword">return</span> (<br>            check_all(knowledge, query, remaining, model_true)<br>            <span class="hljs-keyword">and</span> check_all(knowledge, query, remaining, model_false)<br>        )<br></code></pre></td></tr></table></figure><p>注意：我们只关心 KB 为真的模型。若 KB 为假，则意味着这些模型不符合我们已知事实，因此对推理无关。</p><blockquote><p>课堂外例子：<br>令 P：Harry 是找球手（seeker），Q：Oliver 是守门员（keeper），R：Gryffindor 赢。<br>KB 指定：P、Q、(P ∧ Q) → R。<br>如果某个模型中 ¬P（Harry 不是找球手），那么我们不关心 R 是否为真，因为 KB 已经告诉我们 P 为真。<br>我们只关心与 KB 一致的模型。</p></blockquote><p>此外，<code>check_all</code> 是递归的：每次选一个符号，生成两个模型（真/假），继续递归，直到符号列表为空。<br>一旦为空（<code>if not symbols</code>），函数会检查 KB 是否在该模型下为真；若为真，则再检查 query 是否为真。</p><hr><h1 id="Knowledge-Engineering"><a href="#Knowledge-Engineering" class="headerlink" title="Knowledge Engineering"></a><a href="https://cs50.harvard.edu/ai/notes/1/#knowledge-engineering">Knowledge Engineering</a></h1><p>知识工程（Knowledge Engineering）是思考“如何用命题与逻辑表示现实问题”的过程。</p><p>我们用 Clue（妙探寻凶/Cluedo）游戏练习知识工程：</p><p>谋杀由 <strong>人物</strong>、<strong>工具</strong>、<strong>地点</strong> 三类中的各一个组成。每类随机抽一张放入信封，其余发给玩家。玩家通过不断获得线索推断信封里是什么。<br>在模型中，我们将与谋杀有关的项标为 True，否则标为 False。</p><p>假设：</p><ul><li><p>人物：Mustard, Plum, Scarlet</p></li><li><p>工具：knife, revolver, wrench</p></li><li><p>地点：ballroom, kitchen, library</p></li></ul><p>先加入游戏规则：每类至少一个为真：</p><ul><li><p>(Mustard ∨ Plum ∨ Scarlet)</p></li><li><p>(knife ∨ revolver ∨ wrench)</p></li><li><p>(ballroom ∨ kitchen ∨ library)</p></li></ul><p>游戏开始时，你看到一张人物、一张工具、一张地点，确定它们不在信封。<br>假设你拿到 Mustard、kitchen、revolver，则加入：</p><ul><li><p>¬Mustard</p></li><li><p>¬kitchen</p></li><li><p>¬revolver</p></li></ul><p>在游戏中，你可以提出猜测：某人物 + 某工具 + 某地点。<br>假设猜测 “Scarlet 用 wrench 在 library”，如果这个猜测是错的，则至少有一个不成立：</p><ul><li>(¬Scarlet ∨ ¬library ∨ ¬wrench)</li></ul><p>再假设有人给你看了 Plum 卡，则加入：</p><ul><li>¬Plum</li></ul><p>此时可推出凶手是 Scarlet，因为凶手必须在 Mustard/Plum/Scarlet 中，而前两者都已排除。</p><p>再加入一个知识：地点不是 ballroom：</p><ul><li>¬ballroom</li></ul><p>现在就能推出：Scarlet 在 library 用 knife 作案。<br>library 的推理：地点必须在 ballroom/kitchen/library 中，而 ballroom、kitchen 都被排除。<br>工具的推理：猜测 “Scarlet, library, wrench” 为假，且 Scarlet、library 已为真，因此 wrench 必为假；<br>工具必须在 knife/revolver/wrench 中且 revolver、wrench 都为假，因此 knife 为真。</p><p>将这些信息写入 Python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">knowledge = And(<br>    <span class="hljs-comment"># 游戏条件：每类至少一个为真</span><br>    Or(mustard, plum, scarlet),<br>    Or(ballroom, kitchen, library),<br>    Or(knife, revolver, wrench),<br><br>    <span class="hljs-comment"># 起手三张牌（不在信封）</span><br>    Not(mustard),<br>    Not(kitchen),<br>    Not(revolver),<br><br>    <span class="hljs-comment"># 有人猜 Scarlet + library + wrench，但猜错了</span><br>    Or(Not(scarlet), Not(library), Not(wrench)),<br><br>    <span class="hljs-comment"># 后续看到的牌与线索</span><br>    Not(plum),<br>    Not(ballroom)<br>)<br></code></pre></td></tr></table></figure><p>也可以看其他逻辑谜题。<br>例如：四个人（Gilderoy, Pomona, Minerva, Horace）要分配到四个学院（Gryffindor, Hufflepuff, Ravenclaw, Slytherin），每个学院恰好一个人。<br>用命题逻辑表示会非常繁琐：每一种“人-学院”的组合都要一个命题，如 MinervaGryffindor、MinervaHufflepuff 等。<br>还要表示“每个人至少属于一个学院”，需要写一个 Or 列出所有学院；<br>再表示“若属于某学院，则不属于其他学院”，需要写大量蕴含式。<br>这种低效在“一阶逻辑”部分会给出解决思路，但命题逻辑也能解，只是很啰嗦。</p><p>另一类可用命题逻辑解决的是 Mastermind（猜颜色位置）游戏。<br>玩家一设定颜色顺序，玩家二不断猜；每次反馈“有多少个颜色位置正确”。<br>例如四种颜色：</p><p>第一猜：<br><img src="https://cs50.harvard.edu/ai/notes/1/mastermind1.png" alt="Mastermind1"></p><p>反馈 “two”：两个位置正确，两个位置错误。<br>接着交换其中两个颜色位置再猜：</p><p><img src="https://cs50.harvard.edu/ai/notes/1/mastermind2.png" alt="Mastermind2"></p><p>反馈 “zero”：说明刚才交换的两个其实原来就在正确位置，因此未动的两个原来位置是错的。<br>再交换剩下两个：</p><p><img src="https://cs50.harvard.edu/ai/notes/1/mastermind3.png" alt="Mastermind3"></p><p>反馈 “four”：结束。</p><p>用命题逻辑表示需要 (颜色数)² 个原子命题：如 red0、red1… 表示颜色与位置。<br>接着要表示规则（每个位置只有一种颜色、颜色不重复）并加入 KB；<br>最后加入线索（第一猜两个对、第二猜零对），用模型检测就能求解。</p><hr><h1 id="Inference-Rules"><a href="#Inference-Rules" class="headerlink" title="Inference Rules"></a><a href="https://cs50.harvard.edu/ai/notes/1/#inference-rules">Inference Rules</a></h1><p>模型检测效率不高，因为要枚举所有模型。<br>推理规则（Inference Rules）允许我们不枚举所有模型就推出新知识。</p><p>推理规则通常画成一条横线：上面是前提（premise），下面是结论（conclusion）。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/modusponensexample.png" alt="Modus Ponens Example"></p><p>例子前提：</p><ul><li><p>如果下雨，则 Harry 在室内</p></li><li><p>下雨</p></li></ul><p>结论：</p><ul><li>Harry 在室内</li></ul><h2 id="Modus-Ponens（肯定前件）"><a href="#Modus-Ponens（肯定前件）" class="headerlink" title="Modus Ponens（肯定前件）"></a>Modus Ponens（肯定前件）</h2><p>如果知道 P → Q 且 P 为真，则 Q 为真。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/modusponens.png" alt="Modus Ponens"></p><h2 id="And-Elimination（合取消去）"><a href="#And-Elimination（合取消去）" class="headerlink" title="And Elimination（合取消去）"></a>And Elimination（合取消去）</h2><p>若 P ∧ Q 为真，则 P 为真（或 Q 为真）。<br>例如知道 Harry 同时是 Ron 和 Hermione 的朋友，则可推出 Harry 是 Hermione 的朋友。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/andelimination.png" alt="And Elimination"></p><h2 id="Double-Negation-Elimination（双重否定消去）"><a href="#Double-Negation-Elimination（双重否定消去）" class="headerlink" title="Double Negation Elimination（双重否定消去）"></a>Double Negation Elimination（双重否定消去）</h2><p>¬¬P 等价于 P。<br>例如 “并非（Harry 没通过考试）” → Harry 通过了考试。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/doublenegationelimination.png" alt="Double Negation Elimination"></p><h2 id="Implication-Elimination（蕴含消去）"><a href="#Implication-Elimination（蕴含消去）" class="headerlink" title="Implication Elimination（蕴含消去）"></a>Implication Elimination（蕴含消去）</h2><p>P → Q 等价于 ¬P ∨ Q。<br>例如 “如果下雨，Harry 在室内” 等价于 “不下雨 或 Harry 在室内”。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/implicationelimination.png" alt="Implication Elimination"></p><p>这可能有点绕。看真值表可知二者等价：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P → Q</th><th>¬P ∨ Q</th></tr></thead><tbody><tr><td>false</td><td>false</td><td>true</td><td>true</td></tr><tr><td>false</td><td>true</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><h2 id="Biconditional-Elimination（双条件消去）"><a href="#Biconditional-Elimination（双条件消去）" class="headerlink" title="Biconditional Elimination（双条件消去）"></a>Biconditional Elimination（双条件消去）</h2><p>P ↔ Q 等价于 (P → Q) ∧ (Q → P)。</p><p><img src="https://cs50.harvard.edu/ai/notes/1/biconditionalelimination.png" alt="Biconditional Elimination"></p><h2 id="De-Morgan’s-Law（德摩根定律）"><a href="#De-Morgan’s-Law（德摩根定律）" class="headerlink" title="De Morgan’s Law（德摩根定律）"></a>De Morgan’s Law（德摩根定律）</h2><p>把 And 与 Or 在否定下互换：</p><p>¬(P ∧ Q) ≡ ¬P ∨ ¬Q<br>¬(P ∨ Q) ≡ ¬P ∧ ¬Q</p><p><img src="https://cs50.harvard.edu/ai/notes/1/demorgans1.png" alt="De Morgan&#39;s 1"><br><img src="https://cs50.harvard.edu/ai/notes/1/demorgans2.png" alt="De Morgan&#39;s 2"></p><h2 id="Distributive-Property（分配律）"><a href="#Distributive-Property（分配律）" class="headerlink" title="Distributive Property（分配律）"></a>Distributive Property（分配律）</h2><p>将 And/Or 分配展开：</p><p><img src="https://cs50.harvard.edu/ai/notes/1/distributive1.png" alt="Distributive 1"><br><img src="https://cs50.harvard.edu/ai/notes/1/distributive2.png" alt="Distributive 2"></p><hr><h2 id="知识与搜索问题（Knowledge-and-Search-Problems）"><a href="#知识与搜索问题（Knowledge-and-Search-Problems）" class="headerlink" title="知识与搜索问题（Knowledge and Search Problems）"></a>知识与搜索问题（Knowledge and Search Problems）</h2><p>推理可以被视为一个搜索问题：</p><ul><li><p>初始状态：起始知识库</p></li><li><p>动作：推理规则</p></li><li><p>状态转移：应用推理规则后的新知识库</p></li><li><p>目标测试：想证明的语句是否已在 KB 中</p></li><li><p>路径代价：证明步数</p></li></ul><p>这说明搜索算法的普适性：推理也能视为“在证明空间里搜索”。</p><hr><h1 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a><a href="https://cs50.harvard.edu/ai/notes/1/#resolution">Resolution</a></h1><p>归结（Resolution）是一条强大的推理规则：若在一个 Or 子句中，一个文字为假，则另一个必须为真。</p><p>例如：</p><ul><li><p>Ron 在大厅 ∨ Hermione 在图书馆</p></li><li><p>¬(Ron 在大厅)<br>  则可推出：</p></li><li><p>Hermione 在图书馆</p></li></ul><p>形式化：</p><p><img src="https://cs50.harvard.edu/ai/notes/1/resolution1.png" alt="Resolution"></p><p>归结依赖<strong>互补文字（Complementary Literals）</strong>：同一个命题的正负形式，如 P 与 ¬P。</p><p>归结可推广：若还有</p><ul><li>¬(Ron 在大厅) ∨ Harry 在睡觉</li></ul><p>可归结出：</p><ul><li>Hermione 在图书馆 ∨ Harry 在睡觉</li></ul><p><img src="https://cs50.harvard.edu/ai/notes/1/resolution2.png" alt="Resolution"></p><hr><h2 id="子句（Clause）与-CNF（合取范式）"><a href="#子句（Clause）与-CNF（合取范式）" class="headerlink" title="子句（Clause）与 CNF（合取范式）"></a>子句（Clause）与 CNF（合取范式）</h2><ul><li><p><strong>文字（literal）</strong>：命题符号或其否定（P 或 ¬P）</p></li><li><p><strong>子句（clause）</strong>：文字的析取（Or），如 (P ∨ Q ∨ ¬R)</p></li><li><p><strong>CNF（Conjunctive Normal Form）</strong>：多个子句的合取（And），如：<br>  (A ∨ B ∨ C) ∧ (D ∨ ¬E) ∧ (F ∨ G)</p></li></ul><hr><h2 id="将命题转换为-CNF-的步骤"><a href="#将命题转换为-CNF-的步骤" class="headerlink" title="将命题转换为 CNF 的步骤"></a>将命题转换为 CNF 的步骤</h2><ol><li><p>消除双条件<br> (α ↔ β) → (α → β) ∧ (β → α)</p></li><li><p>消除蕴含<br> (α → β) → (¬α ∨ β)</p></li><li><p>将否定向内推进到只否定文字（用德摩根）<br> ¬(α ∧ β) → ¬α ∨ ¬β</p></li></ol><p>示例：把 (P ∨ Q) → R 转成 CNF：</p><ul><li><p>(P ∨ Q) → R</p></li><li><p>¬(P ∨ Q) ∨ R（消除蕴含）</p></li><li><p>(¬P ∧ ¬Q) ∨ R（德摩根）</p></li><li><p>(¬P ∨ R) ∧ (¬Q ∨ R)（分配律）</p></li></ul><hr><h2 id="因式分解（Factoring）与空子句"><a href="#因式分解（Factoring）与空子句" class="headerlink" title="因式分解（Factoring）与空子句"></a>因式分解（Factoring）与空子句</h2><p>归结过程中可能出现同一个文字重复，如推导出 (Q ∨ R ∨ S ∨ S)。<br><strong>Factoring</strong> 会去掉重复的 S，得到 (Q ∨ R ∨ S)。</p><p>当归结 P 与 ¬P 时，会得到<strong>空子句</strong> ()。空子句恒为假，表示矛盾（不可能同时 P 与 ¬P 为真）。</p><hr><h2 id="用归结判断蕴含（反证法）"><a href="#用归结判断蕴含（反证法）" class="headerlink" title="用归结判断蕴含（反证法）"></a>用归结判断蕴含（反证法）</h2><p>判断 KB ⊨ α：</p><ul><li><p>检查 (KB ∧ ¬α) 是否矛盾</p><ul><li><p>若矛盾，则 KB ⊨ α</p></li><li><p>否则不蕴含</p></li></ul></li></ul><p>更技术化的算法：</p><ol><li><p>将 (KB ∧ ¬α) 转为 CNF</p></li><li><p>不断用归结产生新子句</p></li><li><p>若产生空子句 ()，则得到矛盾，证明 KB ⊨ α</p></li><li><p>若无法得到矛盾且也无法产生新子句，则不蕴含</p></li></ol><p>示例：</p><p>要判断 (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) 是否蕴含 A？</p><ul><li><p>反证：假设 ¬A</p></li><li><p>得到 (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) ∧ (¬A)</p></li><li><p>由 ¬C，可知 (¬B ∨ C) 要为真只能 ¬B</p></li><li><p>有了 ¬B，(A ∨ B) 要为真只能 A</p></li><li><p>现在有 A 与 ¬A，归结得到空子句 () → 矛盾 → 蕴含成立</p></li></ul><hr><h1 id="First-Order-Logic"><a href="#First-Order-Logic" class="headerlink" title="First Order Logic"></a><a href="https://cs50.harvard.edu/ai/notes/1/#first-order-logic">First Order Logic</a></h1><p>一阶逻辑能比命题逻辑更简洁地表达复杂信息。</p><p>一阶逻辑包含两类符号：</p><ul><li><p><strong>常量符号（Constant Symbols）</strong>：表示对象（如人物、学院）</p></li><li><p><strong>谓词符号（Predicate Symbols）</strong>：像关系/函数，输入参数并返回真假</p></li></ul><p>例如：</p><ul><li><p>Person(Minerva)：Minerva 是人</p></li><li><p>House(Gryffindor)：Gryffindor 是学院</p></li><li><p>¬House(Minerva)：Minerva 不是学院</p></li><li><p>BelongsTo(Minerva, Gryffindor)：Minerva 属于 Gryffindor</p></li></ul><p>一阶逻辑能让“每个人一个符号、每个学院一个符号”，比命题逻辑为每个“人-学院组合”都建一个命题更简洁。</p><hr><h2 id="全称量化（Universal-Quantification-∀）"><a href="#全称量化（Universal-Quantification-∀）" class="headerlink" title="全称量化（Universal Quantification, ∀）"></a>全称量化（Universal Quantification, ∀）</h2><p>量化可以表示“不指明具体常量”的句子。<br>全称量化 ∀ 表示“对所有”。</p><p>例如：</p><p>∀x. BelongsTo(x, Gryffindor) → ¬BelongsTo(x, Hufflepuff)</p><p>表示：对任何 x，如果 x 属于 Gryffindor，则 x 不属于 Hufflepuff。</p><hr><h2 id="存在量化（Existential-Quantification-∃）"><a href="#存在量化（Existential-Quantification-∃）" class="headerlink" title="存在量化（Existential Quantification, ∃）"></a>存在量化（Existential Quantification, ∃）</h2><p>存在量化 ∃ 表示“至少存在一个”。</p><p>例如：</p><p>∃x. House(x) ∧ BelongsTo(Minerva, x)</p><p>表示：存在至少一个对象 x，它既是学院，且 Minerva 属于 x。<br>也就是：Minerva 属于某个学院。</p><hr><h2 id="同时使用-∀-与-∃"><a href="#同时使用-∀-与-∃" class="headerlink" title="同时使用 ∀ 与 ∃"></a>同时使用 ∀ 与 ∃</h2><p>例如：</p><p>∀x. Person(x) → (∃y. House(y) ∧ BelongsTo(x, y))</p><p>表示：对所有 x，如果 x 是人，则存在至少一个学院 y，使得 x 属于 y。<br>也就是说：每个人都属于某个学院。</p><hr>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>讲义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分思想不只能查找</title>
    <link href="/2026/01/03/%E4%BA%8C%E5%88%86/"/>
    <url>/2026/01/03/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="1-四种需求通用转换公式"><a href="#1-四种需求通用转换公式" class="headerlink" title="1. 四种需求通用转换公式"></a>1. 四种需求通用转换公式</h3><p>无论使用开区间还是闭区间写法，核心逻辑都是通过 <code>lowerBound</code> 来实现的。以下公式适用于所有情况：</p><div class="table-container"><table><thead><tr><th style="text-align:left">你的需求</th><th style="text-align:left">转化为 <code>lowerBound</code></th><th style="text-align:left">结果下标处理</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><strong>找 $\ge x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x)</code></td><td style="text-align:left">无</td><td style="text-align:left">标准定义</td></tr><tr><td style="text-align:left"><strong>找 $&gt; x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1)</code></td><td style="text-align:left">无</td><td style="text-align:left">整数性质：$&gt;x \Leftrightarrow \ge x+1$</td></tr><tr><td style="text-align:left"><strong>找 $&lt; x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x)</code></td><td style="text-align:left"><code>- 1</code></td><td style="text-align:left">$\ge x$ 的左边就是 $&lt; x$</td></tr><tr><td style="text-align:left"><strong>找 $\le x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1)</code></td><td style="text-align:left"><code>- 1</code></td><td style="text-align:left">$&gt; x$ 的左边就是 $\le x$</td></tr></tbody></table></div><hr><h3 id="2-开区间写法-Open-Interval"><a href="#2-开区间写法-Open-Interval" class="headerlink" title="2. 开区间写法 (Open Interval)"></a>2. 开区间写法 (Open Interval)</h3><p><strong>特点</strong>：逻辑最统一，无需考虑 <code>+1/-1</code> 细节，不易死循环。<br><strong>区间定义</strong>：<code>(-1, n)</code>。<code>left</code> 始终指向红色（不满足），<code>right</code> 始终指向蓝色（满足）。</p><h4 id="2-1-Java-开区间"><a href="#2-1-Java-开区间" class="headerlink" title="2.1 Java (开区间)"></a>2.1 Java (开区间)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 初始化：开区间 (left, right)</span><br>    <span class="hljs-comment">// left = -1 代表红色区域（&lt; target）</span><br>    <span class="hljs-comment">// right = n 代表蓝色区域（&gt;= target）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, right = nums.length;<br>    <br>    <span class="hljs-comment">// 循环不变量：left + 1 &lt; right (区间不为空)</span><br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// 核心判断：mid 在哪边？</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid; <span class="hljs-comment">// mid 满足条件(蓝色)，可能是答案，向左收缩</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// mid 不满足条件(红色)，答案在右边，向右收缩</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 循环结束时 left + 1 == right</span><br>    <span class="hljs-comment">// right 指向第一个满足 &gt;= target 的位置</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-C语言-开区间"><a href="#2-2-C语言-开区间" class="headerlink" title="2.2 C语言 (开区间)"></a>2.2 C语言 (开区间)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = numsSize;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid; <span class="hljs-comment">// 蓝色区域，更新右边界</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// 红色区域，更新左边界</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 返回蓝色区域的起点</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-闭区间写法-Closed-Interval-——-教科书经典"><a href="#3-闭区间写法-Closed-Interval-——-教科书经典" class="headerlink" title="3. 闭区间写法 (Closed Interval) —— 教科书经典"></a>3. 闭区间写法 (Closed Interval) —— 教科书经典</h3><p><strong>特点</strong>：最常见，面试中常用。<br><strong>区间定义</strong>：<code>[0, n-1]</code>。每次更新必须排除 <code>mid</code>。</p><h4 id="3-1-Java-闭区间"><a href="#3-1-Java-闭区间" class="headerlink" title="3.1 Java (闭区间)"></a>3.1 Java (闭区间)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 循环结束条件：left &gt; right</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 尝试查找更小的下标</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 必须查找更大的下标</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// left 指向第一个 &gt;= target 的位置</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-C语言-闭区间"><a href="#3-2-C语言-闭区间" class="headerlink" title="3.2 C语言 (闭区间)"></a>3.2 C语言 (闭区间)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = numsSize - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li><strong>开区间</strong>：初始化 <code>(-1, n)</code>，更新 <code>left=mid</code> / <code>right=mid</code>，返回 <code>right</code>。记忆口诀：<strong>check 成功更新谁，最后就返回谁</strong>（针对 <code>lowerBound</code> 求最小，check 成功更新 right，故返回 right）。</li><li><strong>闭区间</strong>：初始化 <code>[0, n-1]</code>，更新 <code>mid+1</code> / <code>mid-1</code>，返回 <code>left</code>。</li></ul><h3 id="5-找不到时的返回值"><a href="#5-找不到时的返回值" class="headerlink" title="5. 找不到时的返回值"></a>5. 找不到时的返回值</h3><p>无论是<strong>开区间</strong>还是<strong>闭区间</strong>，标准的 <code>lowerBound</code>（寻找第一个 $\ge target$ 的下标）算法在“找不到”时的表现是<strong>一致的</strong>：</p><ol><li><strong>如果数组中所有数都小于 <code>target</code></strong>（即目标值太大，越界）：返回 <strong>数组长度 <code>n</code></strong>。</li><li><strong>如果数组中所有数都大于等于 <code>target</code></strong>（即目标值比谁都小）：返回 <strong><code>0</code></strong>。</li><li><strong>如果目标值在数组范围内但不存在</strong>：返回它<strong>按顺序应该插入的位置</strong>（即第一个大于它的数的下标）。</li></ol><hr><h4 id="5-1-详细对比与解释"><a href="#5-1-详细对比与解释" class="headerlink" title="5.1 详细对比与解释"></a>5.1 详细对比与解释</h4><h5 id="5-1-1-开区间写法-Open-Interval"><a href="#5-1-1-开区间写法-Open-Interval" class="headerlink" title="5.1.1 开区间写法 (Open Interval)"></a>5.1.1 开区间写法 (Open Interval)</h5><ul><li><strong>初始化</strong>：<code>left = -1</code>, <code>right = n</code>。</li><li><strong>循环结束</strong>：<code>left + 1 == right</code>。</li><li><strong>返回值</strong>：<strong><code>right</code></strong>。</li><li><strong>“找不到”的情况</strong>：<ul><li><strong>Target 太大</strong>（所有数都 <code>&lt; target</code>）：<code>check(mid)</code> 永远为 <code>False</code>，<code>right</code> 从未被更新，始终保持初始值 <strong><code>n</code></strong>。</li><li><strong>Target 太小</strong>（所有数都 <code>≥ target</code>）：<code>check(mid)</code> 永远为 <code>True</code>，<code>right</code> 不断向左收缩，最终变为 <strong><code>0</code></strong>（此时 <code>left</code> 仍为 <code>-1</code>）。</li></ul></li></ul><h5 id="5-1-2-闭区间写法-Closed-Interval"><a href="#5-1-2-闭区间写法-Closed-Interval" class="headerlink" title="5.1.2 闭区间写法 (Closed Interval)"></a>5.1.2 闭区间写法 (Closed Interval)</h5><ul><li><strong>初始化</strong>：<code>left = 0</code>, <code>right = n - 1</code>。</li><li><strong>循环结束</strong>：<code>left &gt; right</code>。</li><li><strong>返回值</strong>：<strong><code>left</code></strong>。</li><li><strong>“找不到”的情况</strong>：<ul><li><strong>Target 太大</strong>：<code>nums[mid] &lt; target</code> 始终成立，<code>left</code> 不断右移（<code>mid + 1</code>），直到最后一次循环时 <code>left</code> 变为 <strong><code>n</code></strong>，循环结束。</li><li><strong>Target 太小</strong>：<code>nums[mid] &gt;= target</code> 始终成立，<code>right</code> 不断左移，<code>left</code> 保持初始值 <strong><code>0</code></strong> 不动。</li></ul></li></ul><hr><h4 id="5-2-特殊变种的“找不到”返回值"><a href="#5-2-特殊变种的“找不到”返回值" class="headerlink" title="5.2 特殊变种的“找不到”返回值"></a>5.2 特殊变种的“找不到”返回值</h4><p>根据资料，基于 <code>lowerBound</code> 衍生出的其他三种查找需求，其“找不到”的返回值如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">查找需求</th><th style="text-align:left">转化公式</th><th style="text-align:left"><strong>找不到时的返回值</strong></th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>$\ge x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x)</code></td><td style="text-align:left"><strong><code>n</code></strong></td><td style="text-align:left">所有数都 $&lt; x$</td></tr><tr><td style="text-align:left"><strong>$&gt; x$ 的第一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1)</code></td><td style="text-align:left"><strong><code>n</code></strong></td><td style="text-align:left">所有数都 $\le x$</td></tr><tr><td style="text-align:left"><strong>$&lt; x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x) - 1</code></td><td style="text-align:left"><strong><code>-1</code></strong></td><td style="text-align:left">所有数都 $\ge x$ (即 <code>lowerBound</code> 返回 0)</td></tr><tr><td style="text-align:left"><strong>$\le x$ 的最后一个</strong></td><td style="text-align:left"><code>lowerBound(nums, x + 1) - 1</code></td><td style="text-align:left"><strong><code>-1</code></strong></td><td style="text-align:left">所有数都 $&gt; x$ (即 <code>lowerBound</code> 返回 0)</td></tr></tbody></table></div><h4 id="5-3-如何判断“精确查找（Equal）”失败？"><a href="#5-3-如何判断“精确查找（Equal）”失败？" class="headerlink" title="5.3 如何判断“精确查找（Equal）”失败？"></a>5.3 如何判断“精确查找（Equal）”失败？</h4><p>如果你需要的是“找到返回下标，<strong>找不到返回 -1</strong>”的逻辑（即标准的 <code>indexOf</code>），无论使用开区间还是闭区间，都需要在拿到返回值后增加一步判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设 idx 是 lowerBound 的返回值 (无论开闭区间)</span><br>idx = lower_bound(nums, target)<br><br><span class="hljs-comment"># 必须同时满足两个条件才算“找到了”：</span><br><span class="hljs-comment"># 1. idx 不越界 (idx &lt; n)</span><br><span class="hljs-comment"># 2. 该位置的值确实等于 target</span><br><span class="hljs-keyword">if</span> idx &lt; <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">and</span> nums[idx] == target:<br>    <span class="hljs-keyword">return</span> idx<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># 真正的“找不到”</span><br></code></pre></td></tr></table></figure><h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><h3 id="1-核心概念与思维模型"><a href="#1-核心概念与思维模型" class="headerlink" title="1. 核心概念与思维模型"></a>1. 核心概念与思维模型</h3><ul><li><strong>基本定义</strong>：“花费一个 $\log$ 的时间，增加了一个条件”。我们将求解最优解（求最小/最大）的问题，转化为在一个<strong>虚拟的有序数组</strong> <code>[check(min), ..., check(max)]</code> 中寻找分界点的问题。</li><li><strong>红蓝染色法</strong>：与数组二分一样，我们将解空间分为两部分：<ul><li><strong>红色</strong>：不满足题目要求的区域。</li><li><strong>蓝色</strong>：满足题目要求的区域。</li><li><strong>目标</strong>：寻找红蓝分界线。</li></ul></li></ul><hr><h3 id="2-两大核心类型"><a href="#2-两大核心类型" class="headerlink" title="2. 两大核心类型"></a>2. 两大核心类型</h3><p>根据题目要求寻找的是“最小值”还是“最大值”，解题模型分为两类。资料强烈推荐使用<strong>开区间</strong>写法，因为它逻辑最统一。</p><h4 id="2-1-类型一：求最小-Find-Minimum"><a href="#2-1-类型一：求最小-Find-Minimum" class="headerlink" title="2.1 类型一：求最小 (Find Minimum)"></a>2.1 类型一：求最小 (Find Minimum)</h4><ul><li><strong>适用场景</strong>：<ul><li>求满足条件的<strong>最小值</strong>（如：完成任务的最少时间、最小花费）。</li><li><strong>最小化最大值</strong>（如：分割数组的最大值最小是多少）。</li><li><strong>第 K 小</strong>（转化为：求最小的 $x$，使得 $\le x$ 的数至少有 $k$ 个）。</li></ul></li><li><strong>染色模型</strong>：左边 <code>False</code>（红色），<strong>右边 <code>True</code>（蓝色）</strong>。</li><li><strong>核心逻辑</strong>：我们要找<strong>蓝色区域的起点</strong>。</li><li><strong>开区间口诀</strong>：<code>check</code> 成功更新 <code>right</code>，最后返回 <code>right</code>。</li></ul><h4 id="2-2-类型二：求最大-Find-Maximum"><a href="#2-2-类型二：求最大-Find-Maximum" class="headerlink" title="2.2 类型二：求最大 (Find Maximum)"></a>2.2 类型二：求最大 (Find Maximum)</h4><ul><li><strong>适用场景</strong>：<ul><li>求满足条件的<strong>最大值</strong>（如：最大收益、H指数）。</li><li><strong>最大化最小值</strong>（如：两球之间的最大磁力、让所有人分到的最小值最大）。</li></ul></li><li><strong>染色模型</strong>：<strong>左边 <code>True</code>（蓝色）</strong>，右边 <code>False</code>（红色）。</li><li><strong>核心逻辑</strong>：我们要找<strong>蓝色区域的终点</strong>。</li><li><strong>开区间口诀</strong>：<code>check</code> 成功更新 <code>left</code>，最后返回 <code>left</code>。</li></ul><hr><h3 id="3-四种常见应用模式"><a href="#3-四种常见应用模式" class="headerlink" title="3. 四种常见应用模式"></a>3. 四种常见应用模式</h3><div class="table-container"><table><thead><tr><th style="text-align:left">模式名称</th><th style="text-align:left">本质归属</th><th style="text-align:left">典型题目描述</th><th style="text-align:left">核心 Check 思路</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基础最值</strong></td><td style="text-align:left">求最小/最大</td><td style="text-align:left">x 秒能否完成？</td><td style="text-align:left">模拟过程，判断是否可行</td></tr><tr><td style="text-align:left"><strong>最小化最大值</strong></td><td style="text-align:left"><strong>求最小</strong></td><td style="text-align:left">限制最大负荷，求这个负荷的最小值</td><td style="text-align:left">设阈值为 <code>mid</code>，用贪心判断能否将所有组的数值都压在 <code>mid</code> 以下</td></tr><tr><td style="text-align:left"><strong>最大化最小值</strong></td><td style="text-align:left"><strong>求最大</strong></td><td style="text-align:left">保证每人至少分到 x，求 x 的最大值</td><td style="text-align:left">设下界为 <code>mid</code>，用贪心判断能否选出足够多的元素满足间距/大小 $\ge mid$</td></tr><tr><td style="text-align:left"><strong>第 K 小/大</strong></td><td style="text-align:left"><strong>求最小</strong>/最大</td><td style="text-align:left">乘法表第 K 小、第 K 小数对距离</td><td style="text-align:left">设答案为 <code>x</code>，计算 $\le x$ 的元素个数是否 $\ge k$</td></tr></tbody></table></div><hr><h3 id="4-代码模板（开区间）"><a href="#4-代码模板（开区间）" class="headerlink" title="4. 代码模板（开区间）"></a>4. 代码模板（开区间）</h3><p><strong>开区间二分法</strong>因其逻辑统一（“check更新谁，最后就返回谁”）被强烈推荐。</p><h4 id="4-1-求最小-Find-Minimum-Lower-Bound"><a href="#4-1-求最小-Find-Minimum-Lower-Bound" class="headerlink" title="4.1 求最小 (Find Minimum) / Lower Bound"></a>4.1 求最小 (Find Minimum) / Lower Bound</h4><p><strong>适用场景</strong>：</p><ul><li>求满足条件的<strong>最小值</strong>（如：完成任务的最少时间）。</li><li><strong>最小化最大值</strong>。</li><li><strong>第 K 小</strong>。</li><li>红蓝染色：<strong>左红（False）右蓝（True）</strong>，目标是寻找蓝色区域的起点。</li></ul><p><strong>核心口诀</strong>：<code>check(mid)</code> 成功时更新 <code>right</code>，最后返回 <code>right</code>。</p><h5 id="4-1-1-Java-代码"><a href="#4-1-1-Java-代码" class="headerlink" title="4.1.1 Java 代码"></a>4.1.1 Java 代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 模板：计算满足 check(x) == true 的最小整数 x</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1. 定义解空间范围 (根据题目具体要求设定)</span><br>        <span class="hljs-comment">// left 指向红色区域(不满足)，right 指向蓝色区域(满足)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length; <span class="hljs-comment">// 或者根据题目范围，如 max(nums) 等</span><br>        <br>        <span class="hljs-comment">// 2. 循环不变量：left + 1 &lt; right</span><br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <br>            <span class="hljs-comment">// 3. 核心判定</span><br>            <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>                right = mid; <span class="hljs-comment">// 满足条件，尝试更小的（收缩右边界）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid;  <span class="hljs-comment">// 不满足，需要更大的（收缩左边界）</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 4. 返回 right (最小的满足值)</span><br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-comment">// 具体的判断逻辑</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-1-2-C语言-代码"><a href="#4-1-2-C语言-代码" class="headerlink" title="4.1.2 C语言 代码"></a>4.1.2 C语言 代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-comment">// 具体的判断逻辑</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 模板：计算满足 check(x) == true 的最小整数 x</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMin</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-comment">// 1. 定义解空间 (开区间)</span><br>    <span class="hljs-comment">// left 始终不满足，right 始终满足</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = numsSize; <br>    <br>    <span class="hljs-comment">// 2. 循环不变量</span><br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>            right = mid; <span class="hljs-comment">// 满足条件，记录并在左侧继续找</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// 不满足，去右侧找</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 返回 right</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="4-2-求最大-Find-Maximum"><a href="#4-2-求最大-Find-Maximum" class="headerlink" title="4.2 求最大 (Find Maximum)"></a>4.2 求最大 (Find Maximum)</h4><p><strong>适用场景</strong>：</p><ul><li>求满足条件的<strong>最大值</strong>（如：最大化收益）。</li><li><strong>最大化最小值</strong>（如：磁力球最大距离）。</li><li>红蓝染色：<strong>左蓝（True）右红（False）</strong>，目标是寻找蓝色区域的终点。</li></ul><p><strong>核心口诀</strong>：<code>check(mid)</code> 成功时更新 <code>left</code>，最后返回 <code>left</code>。</p><h5 id="4-2-1-Java-代码"><a href="#4-2-1-Java-代码" class="headerlink" title="4.2.1 Java 代码"></a>4.2.1 Java 代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 模板：计算满足 check(x) == true 的最大整数 x</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1. 定义解空间 (根据题目范围设定)</span><br>        <span class="hljs-comment">// left 指向蓝色区域(满足)，right 指向红色区域(不满足)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length; <br>        <br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <br>            <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>                left = mid;  <span class="hljs-comment">// 满足条件，尝试更大的（收缩左边界）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid; <span class="hljs-comment">// 不满足，需要更小的（收缩右边界）</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 4. 返回 left (最大的满足值)</span><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-2-C语言-代码"><a href="#4-2-2-C语言-代码" class="headerlink" title="4.2.2 C语言 代码"></a>4.2.2 C语言 代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 根据题目实现</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 模板：计算满足 check(x) == true 的最大整数 x</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchMax</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-comment">// 1. 定义解空间</span><br>    <span class="hljs-comment">// left 始终满足，right 始终不满足</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> right = numsSize;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (check(mid)) &#123;<br>            left = mid;  <span class="hljs-comment">// 满足条件，记录答案并在右侧继续找更大值</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid; <span class="hljs-comment">// 不满足，去左侧找</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 返回 left</span><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h4><p>根据资料推荐的<strong>开区间</strong>写法：</p><ul><li><strong>求最小</strong>：<code>right</code> 维护满足条件的值，<code>check</code> 成功更新 <code>right</code>，返回 <code>right</code>。</li><li><strong>求最大</strong>：<code>left</code> 维护满足条件的值，<code>check</code> 成功更新 <code>left</code>，返回 <code>left</code>。</li></ul><h3 id="5-最小化最大值-Minimize-the-Maximum"><a href="#5-最小化最大值-Minimize-the-Maximum" class="headerlink" title="5. 最小化最大值 (Minimize the Maximum)"></a>5. 最小化最大值 (Minimize the Maximum)</h3><p>这类问题通常描述为：“在满足某种分组或分配限制下，让某个最大指标（如最大负荷、最大距离、最大花费）尽可能小”。</p><ul><li><strong>本质归属</strong>：<strong>二分答案求最小</strong>（Find Minimum）。</li><li><strong>思维模型</strong>：<strong>“压盖子”</strong>。<ul><li>二分的 <code>mid</code> 是一个<strong>上界</strong>（Upper Bound）。</li><li>我们试图用这个盖子去“压”住所有元素，看能否在限制条件（如分组成 $k$ 份）下把所有数值都压在 <code>mid</code> 之下。</li></ul></li><li><strong>Check 函数逻辑</strong>：<ul><li>通常使用 <strong>贪心 + 模拟</strong>。</li><li>判断：<strong>“如果最大值不能超过 <code>mid</code>，我最少需要多少组/多少时间？”</strong></li><li>如果需要的组数 $\le k$，说明 <code>mid</code> 给的预算太宽裕或者刚好，尝试<strong>更小</strong>的（收缩右边界 <code>right = mid</code>）。</li><li>如果需要的组数 $&gt; k$，说明 <code>mid</code> 太严苛了，压不住，必须<strong>更大</strong>（收缩左边界 <code>left = mid</code>）。</li></ul></li><li><strong>典型题目</strong>：分割数组的最大值、完成任务的最少时间、爱吃香蕉的珂珂。</li><li><strong>代码行为 (开区间)</strong>：<ul><li><code>check(mid)</code> 成功（True）时更新 <code>right = mid</code>。</li><li>最终返回 <strong><code>right</code></strong>。</li></ul></li></ul><hr><h3 id="6-最大化最小值-Maximize-the-Minimum"><a href="#6-最大化最小值-Maximize-the-Minimum" class="headerlink" title="6. 最大化最小值 (Maximize the Minimum)"></a>6. 最大化最小值 (Maximize the Minimum)</h3><p>这类问题通常描述为：“在选取 $k$ 个元素或进行某种分配时，让其中最小的指标（如最小间距、最小得分）尽可能大”。</p><ul><li><strong>本质归属</strong>：<strong>二分答案求最大</strong>（Find Maximum）。</li><li><strong>思维模型</strong>：<strong>“抬地板”</strong>。<ul><li>二分的 <code>mid</code> 是一个<strong>下界</strong>（Lower Bound）。</li><li>我们试图把标准“抬”高，看能否找到足够多的元素/方案，使得它们都<strong>至少</strong>达到 <code>mid</code> 的水平。</li></ul></li><li><strong>Check 函数逻辑</strong>：<ul><li>通常使用 <strong>贪心</strong>。</li><li>判断：<strong>“如果要求所有选中的元素都 $\ge mid$，我最多能选出多少个？”</strong></li><li>如果选出的个数 $\ge k$，说明 <code>mid</code> 这个标准是可行的，尝试<strong>更大</strong>的（收缩左边界 <code>left = mid</code>）。</li><li>如果选出的个数 $&lt; k$，说明 <code>mid</code> 定太高了，凑不齐，必须<strong>更小</strong>（收缩右边界 <code>right = mid</code>）。</li></ul></li><li><strong>典型题目</strong>：两球之间的磁力、木头切割、H指数。</li><li><strong>代码行为 (开区间)</strong>：<ul><li><code>check(mid)</code> 成功（True）时更新 <code>left = mid</code>。</li><li>最终返回 <strong><code>left</code></strong>。</li></ul></li></ul><hr><h3 id="7-对比总结表"><a href="#7-对比总结表" class="headerlink" title="7. 对比总结表"></a>7. 对比总结表</h3><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left"><strong>最小化最大值</strong> (Min-Max)</th><th style="text-align:left"><strong>最大化最小值</strong> (Max-Min)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>问题类型</strong></td><td style="text-align:left"><strong>求最小</strong> (Find Minimum)</td><td style="text-align:left"><strong>求最大</strong> (Find Maximum)</td></tr><tr><td style="text-align:left"><strong>物理含义</strong></td><td style="text-align:left">限制上限，越小越好</td><td style="text-align:left">保证下限，越大越好</td></tr><tr><td style="text-align:left"><strong>Check方向</strong></td><td style="text-align:left">$\le mid$ 是否可行？</td><td style="text-align:left">$\ge mid$ 是否可行？</td></tr><tr><td style="text-align:left"><strong>更新逻辑</strong></td><td style="text-align:left">Check成功 $\to$ <code>right = mid</code> (试更小)</td><td style="text-align:left">Check成功 $\to$ <code>left = mid</code> (试更大)</td></tr><tr><td style="text-align:left"><strong>开区间返回</strong></td><td style="text-align:left"><strong><code>right</code></strong></td><td style="text-align:left"><strong><code>left</code></strong></td></tr><tr><td style="text-align:left"><strong>闭区间返回</strong></td><td style="text-align:left"><strong><code>left</code></strong></td><td style="text-align:left"><strong><code>right</code></strong></td></tr></tbody></table></div><h3 id="8-代码模板建议-开区间"><a href="#8-代码模板建议-开区间" class="headerlink" title="8. 代码模板建议 (开区间)"></a>8. 代码模板建议 (开区间)</h3><p>根据资料推荐，使用<strong>开区间</strong>写法可以避免复杂的边界判断。</p><p><strong>最小化最大值（求最小）：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心：Check成功更新 right，返回 right</span><br><span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (check(mid)) right = mid; <span class="hljs-comment">// 满足条件，试探更小的</span><br>    <span class="hljs-keyword">else</span> left = mid;<br>&#125;<br><span class="hljs-keyword">return</span> right;<br></code></pre></td></tr></table></figure></p><p><strong>最大化最小值（求最大）：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心：Check成功更新 left，返回 left</span><br><span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (check(mid)) left = mid;  <span class="hljs-comment">// 满足条件，试探更大的</span><br>    <span class="hljs-keyword">else</span> right = mid;<br>&#125;<br><span class="hljs-keyword">return</span> left;<br></code></pre></td></tr></table></figure></p><p><strong>记忆口诀</strong>：</p><ul><li>求最小（压盖子）：返回右边的 <code>right</code>。</li><li>求最大（抬地板）：返回左边的 <code>left</code>。</li></ul><h3 id="9-第-K-小-大"><a href="#9-第-K-小-大" class="headerlink" title="9. 第 K 小/大"></a>9. 第 K 小/大</h3><h4 id="9-1-核心转换逻辑"><a href="#9-1-核心转换逻辑" class="headerlink" title="9.1 核心转换逻辑"></a>9.1 核心转换逻辑</h4><h5 id="9-1-1-第-K-小-Kth-Smallest"><a href="#9-1-1-第-K-小-Kth-Smallest" class="headerlink" title="9.1.1 第 K 小 (Kth Smallest)"></a>9.1.1 第 K 小 (Kth Smallest)</h5><ul><li><strong>定义</strong>：在一个（可能虚拟的）有序序列中，第 K 小的数是 $x$。</li><li><strong>转化公式</strong>：等价于求 <strong>最小</strong> 的 $x$，满足 <strong>$\le x$ 的数至少有 $k$ 个</strong>。</li><li><strong>归属类型</strong>：<strong>求最小</strong>（Find Minimum）。</li><li><strong>单调性</strong>：$x$ 越大，$\le x$ 的数的个数越多（单调递增）。我们要找的是刚刚达到 $k$ 个的那个临界点。</li></ul><h5 id="9-1-2-第-K-大-Kth-Largest"><a href="#9-1-2-第-K-大-Kth-Largest" class="headerlink" title="9.1.2 第 K 大 (Kth Largest)"></a>9.1.2 第 K 大 (Kth Largest)</h5><ul><li><strong>定义</strong>：第 K 大的数是 $x$。</li><li><strong>转化公式</strong>：等价于求 <strong>最大</strong> 的 $x$，满足 <strong>$\ge x$ 的数至少有 $k$ 个</strong>。</li><li><strong>归属类型</strong>：<strong>求最大</strong>（Find Maximum）。</li><li><strong>实际技巧</strong>：虽然可以直接按“求最大”做，但工程和竞赛中常将其转换为 <strong>第 $N - K + 1$ 小</strong> 的问题，从而统一使用“求最小”的模板。</li></ul><hr><h4 id="9-2-代码模板（开区间写法）"><a href="#9-2-代码模板（开区间写法）" class="headerlink" title="9.2 代码模板（开区间写法）"></a>9.2 代码模板（开区间写法）</h4><h5 id="9-2-1-第-K-小模板（推荐）"><a href="#9-2-1-第-K-小模板（推荐）" class="headerlink" title="9.2.1 第 K 小模板（推荐）"></a>9.2.1 第 K 小模板（推荐）</h5><p>这是最常用的形式。例如：乘法表中第 K 小的数、第 K 小的数对距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标：求最小的 x，使得 count(&lt;= x) &gt;= k</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minVal, <span class="hljs-type">int</span> maxVal)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> minVal - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxVal + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// Check逻辑：计算 &lt;= mid 的元素个数是否达到了 k</span><br>        <span class="hljs-keyword">if</span> (countLessOrEqual(mid) &gt;= k) &#123;<br>            right = mid; <span class="hljs-comment">// 够了，甚至多了 -&gt; 尝试更小的（收缩右边界）</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid;  <span class="hljs-comment">// 不够 -&gt; 必须更大（收缩左边界）</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// Check成功更新的是 right，故返回 right</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9-2-2-第-K-大模板（直接法）"><a href="#9-2-2-第-K-大模板（直接法）" class="headerlink" title="9.2.2 第 K 大模板（直接法）"></a>9.2.2 第 K 大模板（直接法）</h5><p>如果不进行转换，直接求第 K 大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 目标：求最大的 x，使得 count(&gt;= x) &gt;= k</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> minVal, <span class="hljs-type">int</span> maxVal)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> minVal - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxVal + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// Check逻辑：计算 &gt;= mid 的元素个数是否达到了 k</span><br>        <span class="hljs-keyword">if</span> (countGreaterOrEqual(mid) &gt;= k) &#123;<br>            left = mid;  <span class="hljs-comment">// 够了 -&gt; 尝试更大的（收缩左边界）</span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            right = mid; <span class="hljs-comment">// 不够 -&gt; 必须更小（收缩右边界）</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// Check成功更新的是 left，故返回 left</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h3><p><strong>“第 K 小”本质上是二分答案求最小</strong>。<br>只需记住：我们二分一个数值 <code>mid</code>，计算“小于等于 <code>mid</code> 的数有多少个”。</p><ul><li>如果个数 $\ge k$，说明 <code>mid</code> 可能是答案，甚至答案比 <code>mid</code> 还小（<strong>Right = mid</strong>）。</li><li>如果个数 $&lt; k$，说明 <code>mid</code> 太小了，不够排到第 $k$ 位（<strong>Left = mid</strong>）。</li><li>最后返回 <strong>Right</strong>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS</tag>
      
      <tag>算法</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java怎么实现Stirng不变的</title>
    <link href="/2026/01/03/Java%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81String%E4%B8%8D%E5%8F%98%E7%9A%84/"/>
    <url>/2026/01/03/Java%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81String%E4%B8%8D%E5%8F%98%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>这是一个<strong>问到 Java 设计“核心骨架”的问题</strong>。<br>我先给你一句<strong>结论级答案</strong>，然后我们像拆发动机一样，把每一层都拆开。</p><blockquote><p><strong><code>String</code> 的不可变性不是靠一句 <code>final</code>，<br>而是靠一整套“多层封锁 + JVM 协同”的设计体系共同保证的。</strong></p></blockquote><p>下面我们分 <strong>5 道防线</strong> 来看。</p><hr><h2 id="第一层防线：String-类本身是-final"><a href="#第一层防线：String-类本身是-final" class="headerlink" title="第一层防线：String 类本身是 final"></a>第一层防线：<code>String</code> 类本身是 <code>final</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="这意味着什么？"><a href="#这意味着什么？" class="headerlink" title="这意味着什么？"></a>这意味着什么？</h3><ul><li>❌ 不能被继承</li><li>❌ 不能通过子类添加“破坏性方法”</li><li>❌ 不能 override 任何行为</li></ul><h3 id="为什么这是第一道防线？"><a href="#为什么这是第一道防线？" class="headerlink" title="为什么这是第一道防线？"></a>为什么这是第一道防线？</h3><p>假如 <code>String</code> <strong>可以被继承</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilString</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 改内部 char[]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么：</p><ul><li>JVM</li><li>HashMap</li><li>ClassLoader</li><li>安全管理器</li></ul><p>都会被<strong>彻底破坏</strong></p><p>📌 <strong>第一层作用</strong>：<br>👉 <strong>防止通过继承破坏不可变性</strong></p><hr><h2 id="第二层防线：内部状态是-private-final"><a href="#第二层防线：内部状态是-private-final" class="headerlink" title="第二层防线：内部状态是 private final"></a>第二层防线：内部状态是 <code>private final</code></h2><h3 id="早期-JDK（≤8）："><a href="#早期-JDK（≤8）：" class="headerlink" title="早期 JDK（≤8）："></a>早期 JDK（≤8）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] value;<br></code></pre></td></tr></table></figure><h3 id="JDK-9-（压缩字符串）："><a href="#JDK-9-（压缩字符串）：" class="headerlink" title="JDK 9+（压缩字符串）："></a>JDK 9+（压缩字符串）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] value;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> coder; <span class="hljs-comment">// LATIN1 / UTF16</span><br></code></pre></td></tr></table></figure><h3 id="这两点非常关键："><a href="#这两点非常关键：" class="headerlink" title="这两点非常关键："></a>这两点非常关键：</h3><ol><li><p><strong><code>final</code></strong></p><ul><li>引用不能被替换</li></ul></li><li><p><strong><code>private</code></strong></p><ul><li>外界完全无法访问</li></ul></li></ol><p>📌 注意：<br><code>final</code> 只保证“引用不变”，<br><strong>真正防修改的是 <code>private</code> + 不暴露引用</strong>。</p><hr><h2 id="第三层防线：没有任何“修改自身”的方法"><a href="#第三层防线：没有任何“修改自身”的方法" class="headerlink" title="第三层防线：没有任何“修改自身”的方法"></a>第三层防线：没有任何“修改自身”的方法</h2><p>你仔细想一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="String-提供的方法是什么？"><a href="#String-提供的方法是什么？" class="headerlink" title="String 提供的方法是什么？"></a>String 提供的方法是什么？</h3><ul><li><code>substring</code></li><li><code>replace</code></li><li><code>toUpperCase</code></li><li><code>concat</code></li></ul><p><strong>它们全部：</strong></p><blockquote><p>❌ 不修改原对象<br>✅ 返回一个新 <code>String</code></p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">s.toUpperCase();<br></code></pre></td></tr></table></figure><p>实际等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(...);<br></code></pre></td></tr></table></figure><p>📌 <strong>这是不可变设计的“行为层保证”</strong>。</p><hr><h2 id="第四层防线：构造阶段的“防御性拷贝”"><a href="#第四层防线：构造阶段的“防御性拷贝”" class="headerlink" title="第四层防线：构造阶段的“防御性拷贝”"></a>第四层防线：构造阶段的“防御性拷贝”</h2><h3 id="你以为这样能破坏-String？"><a href="#你以为这样能破坏-String？" class="headerlink" title="你以为这样能破坏 String？"></a>你以为这样能破坏 String？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] arr = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr);<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;<br>System.out.println(s);<br></code></pre></td></tr></table></figure><h3 id="实际输出："><a href="#实际输出：" class="headerlink" title="实际输出："></a>实际输出：</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abc</span><br></code></pre></td></tr></table></figure><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>因为 <code>String</code> 构造器里做了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.value = Arrays.copyOf(arr, arr.length);<br></code></pre></td></tr></table></figure><p>📌 <strong>String 永远不信任外部传入的数据</strong></p><blockquote><p>这是“不可变类”的黄金法则之一。</p></blockquote><hr><h2 id="第五层防线（终极）：JVM-amp-语言层级的“特权协作”"><a href="#第五层防线（终极）：JVM-amp-语言层级的“特权协作”" class="headerlink" title="第五层防线（终极）：JVM &amp; 语言层级的“特权协作”"></a>第五层防线（终极）：JVM &amp; 语言层级的“特权协作”</h2><p>这是很多人<strong>不知道但最关键的一层</strong>。</p><hr><h3 id="1️⃣-字符串常量池（String-Pool）"><a href="#1️⃣-字符串常量池（String-Pool）" class="headerlink" title="1️⃣ 字符串常量池（String Pool）"></a>1️⃣ 字符串常量池（String Pool）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>a</code> 和 <code>b</code> 指向 <strong>同一个对象</strong></li><li><p>如果 String 可变：</p><ul><li>改一个，全世界跟着改</li></ul></li></ul><p>👉 所以 <strong>String 必须不可变</strong></p><hr><h3 id="2️⃣-hashCode-缓存"><a href="#2️⃣-hashCode-缓存" class="headerlink" title="2️⃣ hashCode 缓存"></a>2️⃣ <code>hashCode</code> 缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash;<br></code></pre></td></tr></table></figure><ul><li><code>hashCode()</code> 只算一次</li><li>之后直接缓存</li></ul><p>如果 String 可变：</p><ul><li>hash 失效</li><li>HashMap 直接崩溃</li></ul><hr><h3 id="3️⃣-ClassLoader-安全模型依赖-String"><a href="#3️⃣-ClassLoader-安全模型依赖-String" class="headerlink" title="3️⃣ ClassLoader / 安全模型依赖 String"></a>3️⃣ ClassLoader / 安全模型依赖 String</h3><ul><li>类名</li><li>方法名</li><li>权限名</li><li>文件路径</li></ul><p>📌 <strong>如果 String 可变，Java 的安全模型不成立</strong></p><hr><h2 id="一句话拆穿所有误解（非常重要）"><a href="#一句话拆穿所有误解（非常重要）" class="headerlink" title="一句话拆穿所有误解（非常重要）"></a>一句话拆穿所有误解（非常重要）</h2><blockquote><p><strong>String 的不可变性不是“防你”，<br>而是“防整个 Java 世界被你不小心炸掉”。</strong></p></blockquote><hr><h2 id="用一个“完整类比”帮你彻底定型"><a href="#用一个“完整类比”帮你彻底定型" class="headerlink" title="用一个“完整类比”帮你彻底定型"></a>用一个“完整类比”帮你彻底定型</h2><p>把 <code>String</code> 想成：</p><blockquote><p><strong>法律里的“身份证号码”</strong></p></blockquote><ul><li>不能改</li><li>可以复制</li><li>可以传递</li><li>可以比较</li><li>但绝不允许“修改原值”</li></ul><p>而：</p><ul><li><code>StringBuilder</code> = 草稿纸</li><li><code>char[]</code> = 可随意涂改的纸</li></ul><hr><h2 id="最容易被忽略的一点（高手标志）"><a href="#最容易被忽略的一点（高手标志）" class="headerlink" title="最容易被忽略的一点（高手标志）"></a>最容易被忽略的一点（高手标志）</h2><h3 id="为什么-String-的-value-数组不是暴露的？"><a href="#为什么-String-的-value-数组不是暴露的？" class="headerlink" title="为什么 String 的 value 数组不是暴露的？"></a>为什么 <code>String</code> 的 <code>value</code> 数组不是暴露的？</h3><p>如果有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] getValue();<br></code></pre></td></tr></table></figure><p>哪怕是 <code>final</code>，<strong>整个设计立刻崩塌</strong>。</p><p>📌 所以不可变性的真正核心是：</p><blockquote><p><strong>不暴露任何可变内部状态的引用</strong></p></blockquote><hr><h2 id="终极总结（请记住）"><a href="#终极总结（请记住）" class="headerlink" title="终极总结（请记住）"></a>终极总结（请记住）</h2><p><code>String</code> 的不可变性 =</p><ol><li>类是 <code>final</code></li><li>内部状态 <code>private final</code></li><li>不提供修改自身的方法</li><li>构造期防御性拷贝</li><li>JVM / 常量池 / hash / 安全模型共同依赖</li></ol><blockquote><p><strong>它是 Java 中“不可变设计”的教科书级范例。</strong></p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50 AI project0 Degrees</title>
    <link href="/2026/01/01/CS50X%20project0%20Degrees/"/>
    <url>/2026/01/01/CS50X%20project0%20Degrees/</url>
    
    <content type="html"><![CDATA[<h1 id="项目-0-Degrees-六度分隔"><a href="#项目-0-Degrees-六度分隔" class="headerlink" title="项目 0: Degrees (六度分隔)"></a>项目 0: Degrees (六度分隔)</h1><p>编写一个程序，通过选择连接演员的电影序列，确定两个演员之间有多少“层”关系（即六度分隔理论）。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">$ python degrees.py large<br>Loading data...<br>Data loaded.<br><span class="hljs-section">Name: Emma Watson</span><br><span class="hljs-section">Name: Jennifer Lawrence</span><br>3 degrees of separation.<br><span class="hljs-section">1: Emma Watson and Brendan Gleeson starred in Harry Potter and the Order of the Phoenix</span><br><span class="hljs-section">2: Brendan Gleeson and Michael Fassbender starred in Trespass Against Us</span><br><span class="hljs-section">3: Michael Fassbender and Jennifer Lawrence starred in X-Men: First Class</span><br></code></pre></td></tr></table></figure><h2 id="截止时间"><a href="#截止时间" class="headerlink" title="[截止时间]"></a>[截止时间]</h2><p><a href="https://time.cs50.io/20260630T235900Z">2026 年 7 月 1 日，星期三，北京时间 07:59</a></p><h2 id="如何寻求帮助"><a href="#如何寻求帮助" class="headerlink" title="[如何寻求帮助]"></a>[如何寻求帮助]</h2><ol><li>通过 <a href="https://cs50.edx.org/ed">Ed</a> 平台提问。</li><li>在 CS50 的任何<a href="https://cs50.harvard.edu/ai/communities/">社区</a>中交流。</li></ol><hr><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="[背景介绍]"></a>[背景介绍]</h2><p>根据“<a href="https://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon">凯文·贝肯的六度分隔</a>”游戏，好莱坞电影业中的任何人都可以通过最多六个步骤连接到凯文·贝肯，其中每一步都由两位演员共同出演的一部电影组成。</p><p>在这个问题中，我们的目标是找到任意两个演员之间的<strong>最短路径</strong>。</p><p>通过使用<strong>广度优先搜索 (BFS)</strong>，我们可以找到从一个演员到另一个演员的最短路径：</p><ul><li><strong>状态 (States)</strong>：人（演员）。</li><li><strong>动作 (Actions)</strong>：电影（将我们从一个演员带到另一个演员）。</li><li><strong>初始状态与目标状态</strong>：我们要连接的两位演员。</li></ul><hr><h2 id="入门指南"><a href="#入门指南" class="headerlink" title="[入门指南]"></a>[入门指南]</h2><ul><li>从 <a href="https://cdn.cs50.net/ai/2023/x/projects/0/degrees.zip">此处</a> 下载分发代码并解压。</li></ul><hr><h2 id="理解代码"><a href="#理解代码" class="headerlink" title="[理解代码]"></a>[理解代码]</h2><p>分发代码包含两组 CSV 数据文件：<code>large</code>（大型）和 <code>small</code>（小型）。</p><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><ul><li><code>people.csv</code>：包含 <code>id</code>、<code>name</code> 和 <code>birth</code>（出生年份）。</li><li><code>movies.csv</code>：包含 <code>id</code>、<code>title</code> 和 <code>year</code>。</li><li><code>stars.csv</code>：关联演员和电影（<code>person_id</code> 与 <code>movie_id</code> 的对应关系）。</li></ul><h3 id="degrees-py"><a href="#degrees-py" class="headerlink" title="degrees.py"></a><code>degrees.py</code></h3><ul><li><code>names</code> 字典：将姓名映射到 <code>id</code> 集合（处理重名）。</li><li><code>people</code> 字典：映射 <code>id</code> 到演员详细信息。</li><li><code>movies</code> 字典：映射 <code>id</code> 到电影详细信息。</li><li><code>main</code> 函数：加载数据并调用 <code>shortest_path</code>。</li></ul><hr><h2 id="任务要求-Specification"><a href="#任务要求-Specification" class="headerlink" title="[任务要求 (Specification)]"></a>[任务要求 (Specification)]</h2><p>你需要实现 <code>shortest_path</code> 函数，使其返回从 <code>source</code> ID 到 <code>target</code> ID 的最短路径。</p><ul><li><strong>返回值</strong>：函数应返回一个列表，其中每个元素是一个 <code>(movie_id, person_id)</code> 元组。<ul><li>例如：<code>[(1, 2), (3, 4)]</code> 表示源演员通过电影 1 与演员 2 合作，演员 2 通过电影 3 与目标演员 4 合作。</li></ul></li><li><strong>多路径</strong>：如果存在多个等长的最短路径，返回其中任何一个即可。</li><li><strong>无路径</strong>：如果两人之间不连通，返回 <code>None</code>。</li><li><strong>辅助函数</strong>：你可以调用 <code>neighbors_for_person(person_id)</code>，它返回与该演员合作过的所有 <code>(movie_id, person_id)</code> 对。</li></ul><hr><h2 id="提示-Hints"><a href="#提示-Hints" class="headerlink" title="[提示 (Hints)]"></a>[提示 (Hints)]</h2><ul><li><strong>性能优化</strong>：在标准搜索中，算法在节点弹出边缘（Frontier）时检查目标。为了提高效率，你可以在<strong>节点加入边缘时</strong>就检查是否到达目标。</li><li><strong>借鉴代码</strong>：参考并修改课堂示例。<code>util.py</code> 中提供了 <code>Node</code>、<code>StackFrontier</code> 和 <code>QueueFrontier</code> 的实现。</li></ul><hr><h2 id="测试与提交"><a href="#测试与提交" class="headerlink" title="[测试与提交]"></a>[测试与提交]</h2><p>使用 <code>check50</code> 检查正确性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">check50 ai50/projects/2024/x/degrees<br></code></pre></td></tr></table></figure></p><h3 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h3><ol><li>在 <a href="https://submit.cs50.io/invites/d03c31aef1984c29b5e7b268c3a87b7b">submit.cs50.io</a> 授权并加入课程。</li><li>使用 <code>submit50</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">submit50 ai50/projects/2024/x/degrees<br></code></pre></td></tr></table></figure></li></ol><hr><p><strong>数据来源</strong>：信息由 <a href="https://www.imdb.com/">IMDb</a> 提供，经许可使用。</p><h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><p>用队列使用BFS，第一次遇到target时，返回路径。</p><blockquote><p>值得注意的是，Node使用的parent记录上一个结点的值，和一般的图的BFS使用一个path数组边走边记录路径不同。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">shortest_path</span>(<span class="hljs-params">source, target</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the shortest list of (movie_id, person_id) pairs</span><br><span class="hljs-string">    that connect the source to the target.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    If no possible path, returns None.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 使用广度优先搜索（BFS）和 QueueFrontier，保证按边数返回最短路径。</span><br><br>    <span class="hljs-comment"># 特殊情况：起点等于终点，返回空路径（没有边）。</span><br>    <span class="hljs-keyword">if</span> source == target:<br>        <span class="hljs-keyword">return</span> []<br><br>    <span class="hljs-comment"># 初始化 frontier，将起始节点加入队列</span><br>    start = Node(state=source, parent=<span class="hljs-literal">None</span>, action=<span class="hljs-literal">None</span>)<br>    frontier = QueueFrontier()<br>    frontier.add(start)<br><br>    <span class="hljs-comment"># explored 用于记录已访问的 person_id，避免重复扩展</span><br>    explored = <span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-comment"># 主循环：直到 frontier 为空</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> frontier.empty():<br>        node = frontier.remove()<br><br>        <span class="hljs-comment"># 如果当前节点是目标节点，则回溯构造路径并返回</span><br>        <span class="hljs-keyword">if</span> node.state == target:<br>            path = []<br>            <span class="hljs-comment"># 从目标回溯到起点，收集 (movie_id, person_id)</span><br>            <span class="hljs-keyword">while</span> node.parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                path.append((node.action, node.state))<br>                node = node.parent<br>            path.reverse()<br>            <span class="hljs-keyword">return</span> path<br><br>        <span class="hljs-comment"># 标记当前节点为已探索</span><br>        explored.add(node.state)<br><br>        <span class="hljs-comment"># 展开邻居：neighbors_for_person 返回 (movie_id, person_id)</span><br>        <span class="hljs-keyword">for</span> movie_id, person_id <span class="hljs-keyword">in</span> neighbors_for_person(node.state):<br>            <span class="hljs-comment"># 如果该人未被探索且不在 frontier 中，则创建子节点并加入 frontier</span><br>            <span class="hljs-keyword">if</span> person_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> explored <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> frontier.contains_state(person_id):<br>                child = Node(state=person_id, parent=node, action=movie_id)<br>                frontier.add(child)<br><br>    <span class="hljs-comment"># 遍历完仍未找到路径，返回 None 表示不连通</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50 AI project0 Tic-Tac-Toe</title>
    <link href="/2026/01/01/CS50X%20project0%20TicTacToc/"/>
    <url>/2026/01/01/CS50X%20project0%20TicTacToc/</url>
    
    <content type="html"><![CDATA[<h1 id="项目-0-Tic-Tac-Toe-井字棋"><a href="#项目-0-Tic-Tac-Toe-井字棋" class="headerlink" title="项目 0: Tic-Tac-Toe (井字棋)"></a>项目 0: Tic-Tac-Toe (井字棋)</h1><p>使用 Minimax 算法实现一个能够以最优策略玩井字棋的 AI。</p><p><img src="https://cs50.harvard.edu/ai/projects/0/tictactoe/images/game.png" alt="Tic-Tac-Toe 游戏界面"></p><h2 id="截止时间"><a href="#截止时间" class="headerlink" title="[截止时间]"></a>[截止时间]</h2><p><a href="https://time.cs50.io/20260630T235900Z">2026 年 7 月 1 日，星期三，北京时间 07:59</a></p><h2 id="如何寻求帮助"><a href="#如何寻求帮助" class="headerlink" title="[如何寻求帮助]"></a>[如何寻求帮助]</h2><ol><li>通过 <a href="https://cs50.edx.org/ed">Ed</a> 平台提问。</li><li>在 CS50 的任何<a href="https://cs50.harvard.edu/ai/communities/">社区</a>中交流。</li></ol><hr><h2 id="入门指南"><a href="#入门指南" class="headerlink" title="[入门指南]"></a>[入门指南]</h2><ul><li>从 <a href="https://cdn.cs50.net/ai/2023/x/projects/0/tictactoe.zip">此处</a> 下载分发代码并解压。</li><li>进入项目目录后，运行以下命令安装所需的 Python 库（<code>pygame</code>）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install -r requirements.txt<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="项目理解"><a href="#项目理解" class="headerlink" title="[项目理解]"></a>[项目理解]</h2><p>该项目有两个主要文件：<code>runner.py</code> 和 <code>tictactoe.py</code>。</p><ul><li><code>runner.py</code>：已由课程方实现，包含运行图形化界面所需的所有代码。</li><li><code>tictactoe.py</code>：包含游戏的所有逻辑以及 AI 做出最优决策的逻辑。完成该文件中的所有函数后，运行 <code>python runner.py</code> 即可与你的 AI 对弈。</li></ul><h3 id="初始数据"><a href="#初始数据" class="headerlink" title="初始数据"></a>初始数据</h3><p>在 <code>tictactoe.py</code> 中，我们定义了三个变量：<code>X</code>、<code>O</code> 和 <code>EMPTY</code> 来表示棋盘上的状态。棋盘被表示为一个包含三个列表的列表（即 3x3 矩阵）。</p><hr><h2 id="任务要求-Specification"><a href="#任务要求-Specification" class="headerlink" title="[任务要求 (Specification)]"></a>[任务要求 (Specification)]</h2><p>你需要完成 <code>player</code>、<code>actions</code>、<code>result</code> <code>winner</code>、<code>terminal</code>、<code>utility</code> 和 <code>minimax</code> 函数的实现。</p><ul><li><strong><code>player(board)</code></strong>：返回当前轮到哪位玩家（<code>X</code> 或 <code>O</code>）。<ul><li>初始状态下由 <code>X</code> 先手。</li></ul></li><li><strong><code>actions(board)</code></strong>：返回当前棋盘上所有可能的动作。<ul><li>动作应表示为元组 <code>(i, j)</code>，其中 <code>i</code> 是行，<code>j</code> 是列（范围均在 0-2 之间）。</li></ul></li><li><strong><code>result(board, action)</code></strong>：返回一个新棋盘状态，而不修改原棋盘。<ul><li>如果动作无效，应 <a href="https://docs.python.org/3/tutorial/errors.html#raising-exceptions">抛出异常</a>。</li><li><strong>重要</strong>：Minimax 需要考虑许多不同的状态，因此必须在不改变原始数据的情况下生成新棋盘。建议使用 <code>copy.deepcopy()</code>。</li></ul></li><li><strong><code>winner(board)</code></strong>：如果有赢家，返回 <code>X</code> 或 <code>O</code>；否则返回 <code>None</code>。<ul><li>获胜条件：在水平、垂直或对角线上连成三子。</li></ul></li><li><strong><code>terminal(board)</code></strong>：返回布尔值，判断游戏是否结束（有人获胜或棋盘填满）。</li><li><strong><code>utility(board)</code></strong>：返回终端棋盘的效用值。<ul><li><code>X</code> 获胜返回 <code>1</code>；<code>O</code> 获胜返回 <code>-1</code>；平局返回 <code>0</code>。</li></ul></li><li><strong><code>minimax(board)</code></strong>：返回当前玩家的最优动作 <code>(i, j)</code>。<ul><li>如果棋盘已结束，返回 <code>None</code>。</li></ul></li></ul><hr><h2 id="提示-Hints"><a href="#提示-Hints" class="headerlink" title="[提示 (Hints)]"></a>[提示 (Hints)]</h2><ul><li>如果你想在不同的文件中测试函数，可以使用 <code>from tictactoe import initial_state</code>。</li><li>你可以添加辅助函数，只要不与现有变量名冲突。</li><li><strong>Alpha-beta 剪枝</strong>（Alpha-beta pruning）是可选的，但它会让你的 AI 运行效率大幅提高！</li></ul><hr><h2 id="测试与提交"><a href="#测试与提交" class="headerlink" title="[测试与提交]"></a>[测试与提交]</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>使用 <code>check50</code> 检查正确性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">check50 ai50/projects/2024/x/tictactoe<br></code></pre></td></tr></table></figure></p><p>使用 <code>style50</code> 检查代码风格。</p><h3 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h3><ol><li>在 <a href="https://submit.cs50.io/invites/d03c31aef1984c29b5e7b268c3a87b7b">submit.cs50.io</a> 授权并加入课程。</li><li>使用 <code>submit50</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">submit50 ai50/projects/2024/x/tictactoe<br></code></pre></td></tr></table></figure></li></ol><hr><p><strong>注意</strong>：由于井字棋在双方均采取最优策略时必然会平局，因此当你完成代码后，你应该<strong>永远无法战胜</strong>你的 AI（但如果你失误了，它会打败你）。</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><strong>状态表示与追踪</strong>：<ul><li>利用 <code>player</code> 函数动态计算棋盘上 <code>X</code> 和 <code>O</code> 的数量差，从而确定当前回合。由于 X 先手且每次只能下一子，只需判断 <code>count(X) == count(O)</code> 即可确定轮到 X。</li></ul></li><li><strong>对抗搜索 (Minimax)</strong>：<ul><li><strong>递归回溯</strong>：通过 <code>max_value</code> 和 <code>min_value</code> 互相调用，模拟出所有可能的对弈分支。</li><li><strong>效用分配</strong>：游戏结束时，胜利、失败和平局分别被量化为 <code>1</code>, <code>-1</code>, <code>0</code>。X 作为 Max 玩家追求分值最大化，O 作为 Min 玩家追求分值最小化。</li></ul></li><li><strong>性能优化 (Alpha-Beta Pruning)</strong>：<ul><li>引入 <code>alpha</code>（Max 玩家保证能得到的最小值）和 <code>beta</code>（Min 玩家保证能允许的最大值）。</li><li>当 <code>v &gt;= beta</code> 或 <code>v &lt;= alpha</code> 时即刻停止搜索该分支，因为理性的对手绝不会允许局面进入这些分支，从而大幅减少计算量。</li></ul></li></ul><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Tic Tac Toe Player</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> math<br><br>X = <span class="hljs-string">&quot;X&quot;</span><br>O = <span class="hljs-string">&quot;O&quot;</span><br>EMPTY = <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">initial_state</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns starting state of the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> [[EMPTY, EMPTY, EMPTY],<br>            [EMPTY, EMPTY, EMPTY],<br>            [EMPTY, EMPTY, EMPTY]]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">player</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns player who has the next turn on a board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 计算当前棋盘上 X 和 O 的数量，决定下一位行动的玩家。</span><br>    <span class="hljs-comment"># 规则：若 X 和 O 的数量相等，则 X 先行；否则为 O。</span><br>    x_count = <span class="hljs-number">0</span><br>    o_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> board:<br>        <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row:<br>            <span class="hljs-keyword">if</span> cell == X:<br>                x_count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> cell == O:<br>                o_count += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 若 X 的数量不多于 O，说明轮到 X；否则轮到 O</span><br>    <span class="hljs-keyword">if</span> x_count &lt;= o_count:<br>        <span class="hljs-keyword">return</span> X<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> O<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">actions</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns set of all possible actions (i, j) available on the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 返回一个包含所有空位置的集合，集合元素为 (行, 列) 二元组。</span><br>    possible = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>            <span class="hljs-keyword">if</span> board[i][j] == EMPTY:<br>                possible.add((i, j))<br>    <span class="hljs-keyword">return</span> possible<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">result</span>(<span class="hljs-params">board, action</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the board that results from making move (i, j) on the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 返回一个新的棋盘（不修改原 board），表示在 action 位置下当前玩家的一步。</span><br>    <span class="hljs-comment"># 验证 action 格式并检查目标格是否为空。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-built_in">isinstance</span>(action, <span class="hljs-built_in">tuple</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(action) == <span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Action must be a tuple (i, j)&quot;</span>)<br><br>    i, j = action<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span> &lt;= i &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= j &lt; <span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Action indices out of bounds&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> board[i][j] != EMPTY:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Action must be on an empty cell&quot;</span>)<br><br>    <span class="hljs-comment"># 深拷贝棋盘以避免修改原对象</span><br>    new_board = [row.copy() <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> board]<br><br>    <span class="hljs-comment"># 将当前玩家的符号放到指定位置</span><br>    new_board[i][j] = player(board)<br>    <span class="hljs-keyword">return</span> new_board<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">winner</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the winner of the game, if there is one.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 检查行三连</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">if</span> board[i][<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[i][<span class="hljs-number">0</span>] == board[i][<span class="hljs-number">1</span>] == board[i][<span class="hljs-number">2</span>]:<br>            <span class="hljs-keyword">return</span> board[i][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 检查列三连</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][j] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[<span class="hljs-number">0</span>][j] == board[<span class="hljs-number">1</span>][j] == board[<span class="hljs-number">2</span>][j]:<br>            <span class="hljs-keyword">return</span> board[<span class="hljs-number">0</span>][j]<br><br>    <span class="hljs-comment"># 检查主对角线</span><br>    <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]:<br>        <span class="hljs-keyword">return</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 检查副对角线</span><br>    <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] == board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == board[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]:<br>        <span class="hljs-keyword">return</span> board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]<br><br>    <span class="hljs-comment"># 若无胜者则返回 None</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">terminal</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns True if game is over, False otherwise.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 游戏结束的两种情况：存在胜者，或棋盘已满（无 EMPTY）。</span><br>    <span class="hljs-keyword">if</span> winner(board) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-comment"># 检查是否还有空位</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> board:<br>        <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row:<br>            <span class="hljs-keyword">if</span> cell == EMPTY:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 无空位且无胜者 -&gt; 平局，也视为游戏结束</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">utility</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns 1 if X has won the game, -1 if O has won, 0 otherwise.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用 winner() 判断胜者并返回对应效用值</span><br>    win = winner(board)<br>    <span class="hljs-keyword">if</span> win == X:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> win == O:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minimax</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Returns the optimal action for the current player on the board.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 若棋局已结束，无可用动作，返回 None</span><br>    <span class="hljs-keyword">if</span> terminal(board):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 使用 Alpha-Beta 剪枝的递归实现。alpha 表示当前已知的最大下界，beta 表示最小上界。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">max_value</span>(<span class="hljs-params">state, alpha, beta</span>):<br>        <span class="hljs-keyword">if</span> terminal(state):<br>            <span class="hljs-keyword">return</span> utility(state)<br>        v = -math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(state):<br>            v = <span class="hljs-built_in">max</span>(v, min_value(result(state, action), alpha, beta))<br>            <span class="hljs-comment"># 如果当前值已经不小于 beta，后续分支不会被选中，剪枝</span><br>            <span class="hljs-keyword">if</span> v &gt;= beta:<br>                <span class="hljs-keyword">return</span> v<br>            alpha = <span class="hljs-built_in">max</span>(alpha, v)<br>        <span class="hljs-keyword">return</span> v<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">min_value</span>(<span class="hljs-params">state, alpha, beta</span>):<br>        <span class="hljs-keyword">if</span> terminal(state):<br>            <span class="hljs-keyword">return</span> utility(state)<br>        v = math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(state):<br>            v = <span class="hljs-built_in">min</span>(v, max_value(result(state, action), alpha, beta))<br>            <span class="hljs-comment"># 如果当前值已经不大于 alpha，后续分支不会被选中，剪枝</span><br>            <span class="hljs-keyword">if</span> v &lt;= alpha:<br>                <span class="hljs-keyword">return</span> v<br>            beta = <span class="hljs-built_in">min</span>(beta, v)<br>        <span class="hljs-keyword">return</span> v<br><br>    current = player(board)<br>    best_action = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 根节点初始化 alpha/beta</span><br>    alpha = -math.inf<br>    beta = math.inf<br><br>    <span class="hljs-keyword">if</span> current == X:<br>        best_val = -math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(board):<br>            value = min_value(result(board, action), alpha, beta)<br>            <span class="hljs-keyword">if</span> value &gt; best_val:<br>                best_val = value<br>                best_action = action<br>            alpha = <span class="hljs-built_in">max</span>(alpha, best_val)<br>            <span class="hljs-comment"># 找到必胜走法可提前结束</span><br>            <span class="hljs-keyword">if</span> best_val == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        best_val = math.inf<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions(board):<br>            value = max_value(result(board, action), alpha, beta)<br>            <span class="hljs-keyword">if</span> value &lt; best_val:<br>                best_val = value<br>                best_action = action<br>            beta = <span class="hljs-built_in">min</span>(beta, best_val)<br>            <span class="hljs-keyword">if</span> best_val == -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">return</span> best_action<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WLS2网络配置</title>
    <link href="/2025/12/31/WLS2%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/12/31/WLS2%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="WSL2-网络代理一键配置指南"><a href="#WSL2-网络代理一键配置指南" class="headerlink" title="WSL2 网络代理一键配置指南"></a>WSL2 网络代理一键配置指南</h1><h2 id="1-背景与原理"><a href="#1-背景与原理" class="headerlink" title="1. 背景与原理"></a>1. 背景与原理</h2><p>WSL2 运行在 Hyper-V 虚拟机中，拥有独立的 IP 地址。因此，WSL2 不能直接通过 <code>127.0.0.1</code> 访问宿主机（Windows）上的代理软件。本配置通过自动抓取宿主机虚拟网卡 IP，实现代理的一键开关。</p><h2 id="2-前置准备"><a href="#2-前置准备" class="headerlink" title="2. 前置准备"></a>2. 前置准备</h2><p>在开始配置前，请确保 Windows 端的代理软件已完成以下设置：</p><ol><li><strong>允许局域网连接 (Allow LAN)</strong>：必须勾选，否则 Windows 会拒绝来自 WSL2 的连接。</li><li><strong>确认端口</strong>：确认你的代理软件监听端口（如 <code>10808</code> 或 <code>7890</code>）。</li></ol><hr><h2 id="3-配置步骤"><a href="#3-配置步骤" class="headerlink" title="3. 配置步骤"></a>3. 配置步骤</h2><h3 id="A-修改-Bash-配置文件"><a href="#A-修改-Bash-配置文件" class="headerlink" title="A. 修改 Bash 配置文件"></a>A. 修改 Bash 配置文件</h3><p>在 WSL 终端中运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano ~/.bashrc<br></code></pre></td></tr></table></figure></p><h3 id="B-写入配置脚本"><a href="#B-写入配置脚本" class="headerlink" title="B. 写入配置脚本"></a>B. 写入配置脚本</h3><p>将以下代码粘贴到文件末尾。注意将 <code>10808</code> 修改为你实际的代理端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ---------- WSL2 Proxy Helper ----------</span><br><span class="hljs-comment"># 建议端口与 Windows 代理软件保持一致</span><br><span class="hljs-built_in">export</span> PROXY_PORT=<span class="hljs-string">&quot;10808&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">proxy_on</span></span>() &#123;<br>    <span class="hljs-comment"># 1. 自动获取宿主机 IP (resolv.conf 中的 nameserver)</span><br>    <span class="hljs-built_in">export</span> host_ip=$(grep -m 1 nameserver /etc/resolv.conf | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 2. 设置环境变量 (HTTP/HTTPS/SOCKS5)</span><br>    <span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    <span class="hljs-built_in">export</span> ALL_PROXY=<span class="hljs-string">&quot;socks5://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    <br>    <span class="hljs-comment"># 3. 同步配置 Git 代理</span><br>    git config --global http.proxy <span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>    git config --global https.proxy <span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;host_ip&#125;</span>:<span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br><br>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32m[√] Proxy Enabled\033[0m&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Host IP: <span class="hljs-variable">$&#123;host_ip&#125;</span>&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Port: <span class="hljs-variable">$&#123;PROXY_PORT&#125;</span>&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">proxy_off</span></span>() &#123;<br>    <span class="hljs-comment"># 1. 取消环境变量</span><br>    <span class="hljs-built_in">unset</span> http_proxy<br>    <span class="hljs-built_in">unset</span> https_proxy<br>    <span class="hljs-built_in">unset</span> ALL_PROXY<br>    <br>    <span class="hljs-comment"># 2. 取消 Git 代理</span><br>    git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>    git config --global --<span class="hljs-built_in">unset</span> https.proxy<br><br>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31m[×] Proxy Disabled\033[0m&quot;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">proxy_test</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Testing connection to Google...&quot;</span><br>    curl -I https://www.google.com<br>&#125;<br><span class="hljs-comment"># --------------------------------------</span><br></code></pre></td></tr></table></figure><h3 id="C-使配置生效"><a href="#C-使配置生效" class="headerlink" title="C. 使配置生效"></a>C. 使配置生效</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><hr><h2 id="4-使用指南"><a href="#4-使用指南" class="headerlink" title="4. 使用指南"></a>4. 使用指南</h2><ul><li><strong>开启代理</strong>：输入 <code>proxy_on</code>。适用于 <code>apt update</code>、<code>git clone</code>、<code>pip install</code> 等。</li><li><strong>关闭代理</strong>：输入 <code>proxy_off</code>。</li><li><strong>检查状态</strong>：输入 <code>proxy_test</code>。</li></ul><hr><h2 id="5-常见问题排查"><a href="#5-常见问题排查" class="headerlink" title="5. 常见问题排查"></a>5. 常见问题排查</h2><h3 id="Q-proxy-on-后依然连接超时-Timeout-？"><a href="#Q-proxy-on-后依然连接超时-Timeout-？" class="headerlink" title="Q: proxy_on 后依然连接超时 (Timeout)？"></a>Q: proxy_on 后依然连接超时 (Timeout)？</h3><ol><li><strong>检查 Windows 防火墙</strong>：以管理员身份在 Windows PowerShell 运行以下命令，允许来自 WSL 的流量：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">New-NetFirewallRule</span> <span class="hljs-literal">-DisplayName</span> <span class="hljs-string">&quot;WSL&quot;</span> <span class="hljs-literal">-Direction</span> Inbound <span class="hljs-literal">-InterfaceAlias</span> <span class="hljs-string">&quot;vEthernet (WSL)&quot;</span> <span class="hljs-literal">-Action</span> Allow<br></code></pre></td></tr></table></figure></li><li><strong>检查代理软件</strong>：确保开启了 “Allow LAN”。</li></ol><h3 id="Q-为什么-ping-google-com-不通？"><a href="#Q-为什么-ping-google-com-不通？" class="headerlink" title="Q: 为什么 ping google.com 不通？"></a>Q: 为什么 ping google.com 不通？</h3><p><code>ping</code> 使用的是 <strong>ICMP 协议</strong>，而大多数应用层代理只转发 <strong>TCP/UDP</strong>。请以 <code>curl -I https://www.google.com</code> 的结果为准。</p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WLS2</tag>
      
      <tag>CS50，网络配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WLS2和Python配置</title>
    <link href="/2025/12/31/WSL2%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/12/31/WSL2%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>CS50中check作业和提交作业的check50和submit50需要在Linux环境下运行，因此配置下WLS。</p><h2 id="1-WSL2-架构与磁盘管理"><a href="#1-WSL2-架构与磁盘管理" class="headerlink" title="1. WSL2 架构与磁盘管理"></a>1. WSL2 架构与磁盘管理</h2><h3 id="1-1-核心安装与升级"><a href="#1-1-核心安装与升级" class="headerlink" title="1.1 核心安装与升级"></a>1.1 核心安装与升级</h3><ul><li><strong>一键安装</strong>：<code>wsl --install</code>（默认安装 Ubuntu）。</li><li><strong>查看版本</strong>：<code>wsl -l -v</code>。确保版本号显示为 <code>2</code>。</li></ul><h3 id="1-2-F-盘迁移与权限“避坑”指南"><a href="#1-2-F-盘迁移与权限“避坑”指南" class="headerlink" title="1.2 F 盘迁移与权限“避坑”指南"></a>1.2 F 盘迁移与权限“避坑”指南</h3><p>为了保护 C 盘空间，我们将 Ubuntu 移动到了 <code>F:\WSL\Ubuntu</code>。</p><ul><li><strong>错误复现</strong>：报错 <code>E_ACCESSDENIED</code> (拒绝访问)。</li><li><strong>深度排查</strong>：WSL2 的 <code>.vhdx</code> 虚拟磁盘文件本质上是一个实时挂载的磁盘。</li><li><strong>解决方案</strong>：<br>由于你将系统文件放在了非系统盘，有时权限没有正确继承，导致 WSL 服务（以特定系统账户运行）无法读取。</li></ul><ol><li><p>右键点击 <code>F:\WSL</code>（或 <code>Ubuntu</code> 文件夹），选择 <strong>属性</strong>。</p></li><li><p>切换到 <strong>安全</strong> 选项卡。</p></li><li><p>点击 <strong>编辑</strong> -&gt; <strong>添加</strong>。</p></li><li><p>在对象名称框中输入 <code>Everyone</code>（或者你的电脑用户名），点击确定。</p></li><li><p>在权限列表中，勾选 <strong>完全控制</strong>。</p></li><li><p>点击确定应用。</p></li></ol><hr><h2 id="2-Linux-系统配置与优化"><a href="#2-Linux-系统配置与优化" class="headerlink" title="2. Linux 系统配置与优化"></a>2. Linux 系统配置与优化</h2><h3 id="2-1-软件源刷新-解决“找不到包”报错"><a href="#2-1-软件源刷新-解决“找不到包”报错" class="headerlink" title="2.1 软件源刷新 (解决“找不到包”报错)"></a>2.1 软件源刷新 (解决“找不到包”报错)</h3><ul><li><strong>现象</strong>：执行 <code>sudo apt install python3-venv</code> 提示 <code>no installation candidate</code>。</li><li><strong>原理</strong>：Ubuntu 刚装好时，本地的软件包索引是空的，它不知道去哪里下载。</li><li><strong>操作</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br></code></pre></td></tr></table></figure>  <em>这步操作会从服务器拉取最新的软件清单。</em></li></ul><h3 id="2-2-彻底静音处理"><a href="#2-2-彻底静音处理" class="headerlink" title="2.2 彻底静音处理"></a>2.2 彻底静音处理</h3><ul><li><strong>痛点</strong>：按 Tab 或 Backspace 时，系统发出刺耳的蜂鸣音。<h3 id="3-关闭-Windows-Terminal-的全局提示音"><a href="#3-关闭-Windows-Terminal-的全局提示音" class="headerlink" title="3. 关闭 Windows Terminal 的全局提示音"></a>3. 关闭 Windows Terminal 的全局提示音</h3></li></ul><p>如果你使用的是 <strong>Windows Terminal</strong>（就是你截图里那个带有标签页的黑色窗口），它本身也有一个设置：</p><ol><li><p>点击窗口顶部的 <strong>向下小箭头</strong>，选择 <strong>设置 (Settings)</strong>。</p></li><li><p>在左侧菜单点击 <strong>默认值 (Defaults)</strong>。</p></li><li><p>在右侧找到 <strong>高级 (Advanced)</strong>。</p></li><li><p>找到 <strong>钟声通知样式 (Bell notification style)</strong>，将其设置为 <strong>无 (None)</strong>。</p></li><li><p>点击右下角的 <strong>保存</strong>。</p></li></ol><hr><h2 id="3-Python-虚拟环境-Virtual-Environment-深度实战"><a href="#3-Python-虚拟环境-Virtual-Environment-深度实战" class="headerlink" title="3. Python 虚拟环境 (Virtual Environment) 深度实战"></a>3. Python 虚拟环境 (Virtual Environment) 深度实战</h2><p>对于 CS50 AI 的 <code>degrees</code> 项目，必须使用 <code>venv</code> 来隔离环境。</p><h3 id="3-1-环境安装"><a href="#3-1-环境安装" class="headerlink" title="3.1 环境安装"></a>3.1 环境安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 安装 pip 包管理器和 venv 模块</span><br><span class="hljs-built_in">sudo</span> apt install python3-pip python3-venv -y<br></code></pre></td></tr></table></figure><h3 id="3-2-虚拟环境“三部曲”"><a href="#3-2-虚拟环境“三部曲”" class="headerlink" title="3.2 虚拟环境“三部曲”"></a>3.2 虚拟环境“三部曲”</h3><ol><li><strong>创建环境</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在项目目录下创建一个名为 venv 的“小房间”</span><br>python3 -m venv venv<br></code></pre></td></tr></table></figure></li><li><strong>激活环境</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这一步会修改当前终端的 PATH 变量</span><br><span class="hljs-built_in">source</span> venv/bin/activate<br></code></pre></td></tr></table></figure><em>激活后，命令行首部会出现 <code>(venv)</code> 标识。</em></li><li><p><strong>隔离原理对比</strong>：</p><ul><li><strong>未激活</strong>：系统默认调用 <code>/usr/bin/python3</code>。</li><li><strong>激活后</strong>：终端会拦截指令，优先使用 <code>~/cs50ai/project0/degrees/venv/bin/python3</code>。</li></ul></li></ol><h3 id="3-3-运行-CS50-AI-项目"><a href="#3-3-运行-CS50-AI-项目" class="headerlink" title="3.3 运行 CS50 AI 项目"></a>3.3 运行 CS50 AI 项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入作业目录</span><br><span class="hljs-built_in">cd</span> ~/cs50ai/project0/degrees<br><br><span class="hljs-comment"># 运行程序并带上 large 数据集参数</span><br>python3 degrees.py large<br></code></pre></td></tr></table></figure><hr><h2 id="4-后端开发常用“互通”命令"><a href="#4-后端开发常用“互通”命令" class="headerlink" title="4. 后端开发常用“互通”命令"></a>4. 后端开发常用“互通”命令</h2><p>作为准 Java 后端开发，你会频繁用到这些跨界操作：</p><div class="table-container"><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">命令</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left"><strong>文件管理</strong></td><td style="text-align:left"><code>explorer.exe .</code></td><td style="text-align:left">弹窗 Windows 文件夹显示 Linux 当前路径</td></tr><tr><td style="text-align:left"><strong>代码编辑</strong></td><td style="text-align:left"><code>code .</code></td><td style="text-align:left">启动 VS Code 并利用 WSL 插件进行开发</td></tr><tr><td style="text-align:left"><strong>系统监控</strong></td><td style="text-align:left"><code>htop</code></td><td style="text-align:left">Linux 风格的动态资源监视器</td></tr><tr><td style="text-align:left"><strong>解压作业</strong></td><td style="text-align:left"><code>unzip degrees.zip</code></td><td style="text-align:left">需先安装 <code>sudo apt install unzip</code></td></tr></tbody></table></div><hr>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WLS2</tag>
      
      <tag>CS50</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="/2025/12/29/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2025/12/29/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/IDEA快捷键/2025-12-29-13-14-07.png" alt=""></p><h2 id="一、-精准检索：在代码海洋中定位"><a href="#一、-精准检索：在代码海洋中定位" class="headerlink" title="一、 精准检索：在代码海洋中定位"></a>一、 精准检索：在代码海洋中定位</h2><h3 id="1-内容搜索"><a href="#1-内容搜索" class="headerlink" title="1. 内容搜索"></a>1. 内容搜索</h3><ul><li><strong>当前文件查找 (<code>Ctrl + F</code>)</strong>：在当前打开的文件中搜索关键字。</li><li><strong>全局内容查找 (<code>Ctrl + Shift + F</code>)</strong>：在整个项目中搜索特定字符串，支持路径过滤。</li><li><strong>当前文件替换 (<code>Ctrl + R</code>)</strong>：快速替换当前类中的特定字符。</li><li><strong>全局内容替换 (<code>Ctrl + Shift + R</code>)</strong>：批量修改整个项目的字符串或配置。</li></ul><h3 id="2-对象搜索-最常用"><a href="#2-对象搜索-最常用" class="headerlink" title="2. 对象搜索 (最常用)"></a>2. 对象搜索 (最常用)</h3><ul><li><strong>查找类名 (<code>Ctrl + N</code>)</strong>：输入类名快速打开 Java 文件，支持模糊匹配。</li><li><strong>查找文件名 (<code>Ctrl + Shift + N</code>)</strong>：不仅是 Java 类，还可以快速找 XML、Properties、JSON 等配置文件。</li><li><strong>跳转指定行 (<code>Ctrl + G</code>)</strong>：当报错堆栈提示行号时，这是最快的定位方式。</li></ul><hr><h2 id="二、-优雅导航：在逻辑森林中穿行"><a href="#二、-优雅导航：在逻辑森林中穿行" class="headerlink" title="二、 优雅导航：在逻辑森林中穿行"></a>二、 优雅导航：在逻辑森林中穿行</h2><h3 id="1-结构与跳转"><a href="#1-结构与跳转" class="headerlink" title="1. 结构与跳转"></a>1. 结构与跳转</h3><ul><li><strong>最近打开文件 (<code>Ctrl + E</code>)</strong>：展示最近编辑过的文件列表，是文件切换的“第一核心键”。</li><li><strong>跳转到前/后方法 (<code>Alt + Up/Down</code>)</strong>：在类的方法之间快速跳跃，无需滚动滑轮。</li><li><strong>查看类结构 (<code>Ctrl + F12</code>)</strong>：弹窗展示当前类的所有方法和成员变量，支持直接输入搜索。</li></ul><h3 id="2-深度溯源"><a href="#2-深度溯源" class="headerlink" title="2. 深度溯源"></a>2. 深度溯源</h3><ul><li><strong>跳转到定义 (<code>Ctrl + B</code> 或 <code>Ctrl + Click</code>)</strong>：查看变量、类或方法的源代码。</li><li><strong>跳转到实现类 (<code>Ctrl + Alt + B</code>)</strong>：<strong>超级好用！</strong> 面对接口时，直接跳过接口定义，进到具体的业务实现类中。</li><li><strong>回退/前进浏览记录 (<code>Ctrl + Alt + Left/Right</code>)</strong>：就像浏览器的前进后退，快速回到刚才看代码的地方。</li></ul><hr><h2 id="三、-智能辅助：让-IDEA-为你“代工”"><a href="#三、-智能辅助：让-IDEA-为你“代工”" class="headerlink" title="三、 智能辅助：让 IDEA 为你“代工”"></a>三、 智能辅助：让 IDEA 为你“代工”</h2><h3 id="1-自动生成"><a href="#1-自动生成" class="headerlink" title="1. 自动生成"></a>1. 自动生成</h3><ul><li><strong>万能意图键 (<code>Alt + Enter</code>)</strong>：代码报错了？想导包？想创建实现类？按它就对了。</li><li><strong>代码格式化 (<code>Ctrl + Alt + L</code>)</strong>：保持代码整洁的最高效手段，建议每次写完方法都按一下。</li><li><strong>智能代码补全 (<code>Ctrl + Shift + Space</code>)</strong>：比普通补全更聪明，会根据类型推断你最可能需要的变量或方法。</li><li><strong>语句自动完成 (<code>Ctrl + Shift + Enter</code>)</strong>：自动补齐括号、大括号并在行末加分号。</li></ul><h3 id="2-编码细节"><a href="#2-编码细节" class="headerlink" title="2. 编码细节"></a>2. 编码细节</h3><ul><li><strong>参数信息提示 (<code>Ctrl + P</code>)</strong>：在调用方法时，忘记要传什么参数？按一下即刻显示参数列表。</li><li><strong>快速注释</strong>：<ul><li><code>Ctrl + /</code>：行注释。</li><li><code>Ctrl + Shift + /</code>：块注释。</li></ul></li><li><strong>包裹代码 (<code>Ctrl + Alt + T</code>)</strong>：快速把一段逻辑包进 <code>if</code>、<code>try-catch</code> 或 <code>synchronized</code> 块中。</li></ul><hr><h2 id="四、-代码重构：像外科医生一样精准"><a href="#四、-代码重构：像外科医生一样精准" class="headerlink" title="四、 代码重构：像外科医生一样精准"></a>四、 代码重构：像外科医生一样精准</h2><h3 id="1-元素重命名"><a href="#1-元素重命名" class="headerlink" title="1. 元素重命名"></a>1. 元素重命名</h3><ul><li><strong>重命名 (<code>Shift + F6</code>)</strong>：修改变量、方法或类名，它会自动帮你把项目中所有引用的地方同步更新。</li></ul><h3 id="2-提取神器-大幅提升代码可读性"><a href="#2-提取神器-大幅提升代码可读性" class="headerlink" title="2. 提取神器 (大幅提升代码可读性)"></a>2. 提取神器 (大幅提升代码可读性)</h3><ul><li><strong>提取变量 (<code>Ctrl + Alt + V</code>)</strong>：将冗长的表达式结果自动声明为局部变量。</li><li><strong>提取方法 (<code>Ctrl + Alt + M</code>)</strong>：选中一段复杂的逻辑，将其“抽离”成一个独立的方法。</li><li><strong>提取常量 (<code>Ctrl + Alt + C</code>)</strong>：将魔法值（如硬编码的字符串）提取为类常量。</li><li><strong>提取参数 (<code>Ctrl + Alt + P</code>)</strong>：将局部变量转变为方法参数，方便逻辑复用。</li></ul><hr><h2 id="五、-编辑小技巧"><a href="#五、-编辑小技巧" class="headerlink" title="五、 编辑小技巧"></a>五、 编辑小技巧</h2><ul><li><strong>复制当前行 (<code>Ctrl + D</code>)</strong>：将光标所在行直接复制到下一行。</li><li><strong>删除当前行 (<code>Ctrl + Y</code> 或 <code>Ctrl + X</code>)</strong>：快速清理无用代码。</li><li><strong>代码行交换顺序 (<code>Ctrl + Shift + Up/Down</code>)</strong>：无需剪切粘贴，直接上下平移代码行。</li><li><strong>扩大/回退选择 (<code>Ctrl + W</code> / <code>Ctrl + Shift + W</code>)</strong>：以词/块为单位逐步扩大选中范围，配合重构功能堪称绝配。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>快捷键</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50AI note0</title>
    <link href="/2025/12/26/CS50%20AI%20note%200/"/>
    <url>/2025/12/26/CS50%20AI%20note%200/</url>
    
    <content type="html"><![CDATA[<h2 id="第-0-讲"><a href="#第-0-讲" class="headerlink" title="第 0 讲"></a><a href="https://cs50.harvard.edu/ai/notes/0/#lecture-0">第 0 讲</a></h2><h2 id="人工智能-Artificial-Intelligence"><a href="#人工智能-Artificial-Intelligence" class="headerlink" title="人工智能 (Artificial Intelligence)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#artificial-intelligence">人工智能 (Artificial Intelligence)</a></h2><p>人工智能 (AI) 涵盖了一系列让计算机表现出类似拥有“感知”行为的技术。例如，AI 被用于识别社交媒体照片中的人脸、在国际象棋中击败世界冠军，以及在你与手机上的 Siri 或 Alexa 对话时处理你的语音。</p><p>在本课程中，我们将探讨使 AI 成为可能的一些核心思想：</p><ol><li><p><strong>搜索 (Search)</strong></p><p>寻找问题的解决方案，例如导航应用程序寻找从起点到终点的最佳路线，或者在玩游戏时计算下一步该怎么走。</p></li><li><p><strong>知识 (Knowledge)</strong></p><p>表示信息并从中进行推理。</p></li><li><p><strong>不确定性 (Uncertainty)</strong></p><p>利用概率论处理不确定事件。</p></li><li><p><strong>优化 (Optimization)</strong></p><p>不仅要找到解决问题的正确方法，还要找到更好——甚至最好——的解决方法。</p></li><li><p><strong>学习 (Learning)</strong></p><p>通过访问数据和经验来提高性能。例如，你的电子邮件系统能够根据过去的经验区分垃圾邮件和非垃圾邮件。</p></li><li><p><strong>神经网络 (Neural Networks)</strong></p><p>一种受人脑启发的程序结构，能够有效地执行任务。</p></li><li><p><strong>语言 (Language)</strong></p><p>处理自然语言，即人类产生和理解的语言。</p></li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：这门课程的结构非常经典，不仅仅关注现在流行的“深度学习”，而是涵盖了 AI 的基础逻辑（如符号主义、概率推理等）。“搜索”是 AI 的基石，本质上是在无数种可能中找到达成目标的路径。</p></blockquote><h2 id="搜索-Search"><a href="#搜索-Search" class="headerlink" title="搜索 (Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#search">搜索 (Search)</a></h2><p>搜索问题涉及一个<strong>智能体 (Agent)</strong>，它被赋予一个<strong>初始状态</strong>和一个<strong>目标状态</strong>，它的任务是返回如何从前者到达后者的解决方案。导航应用就是典型的搜索过程，智能体（程序的思考部分）接收你当前的位置和想要去的目的地作为输入，并基于搜索算法返回建议的路径。当然，还有许多其他形式的搜索问题，如拼图或迷宫。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/15puzzle.png" alt="15 puzzle"></p><p>找到 15 数字推盘游戏的解法需要使用搜索算法。</p><ul><li><p><strong>智能体 (Agent)</strong></p><p>一个能够感知环境并对环境采取行动的实体。例如在导航应用中，智能体代表一辆需要决定采取哪些行动才能到达目的地的汽车。</p></li><li><p><strong>状态 (State)</strong></p><p>智能体在其环境中的一种配置。例如，在 <a href="https://en.wikipedia.org/wiki/15_puzzle">15 数字推盘</a>中，一个状态就是板上数字排列的任意一种方式。</p><ul><li><strong>初始状态 (Initial State)</strong><br>搜索算法开始的状态。在导航应用中，就是当前位置。</li></ul></li><li><p><strong>动作 (Actions)</strong></p><p>在一个状态下可以做出的选择。更准确地说，动作可以定义为一个函数。接收状态 <code>s</code> 作为输入，<code>Actions(s)</code> 返回在状态 <code>s</code> 下可执行的动作集合作为输出。例如，在 <em>15 数字推盘</em>中，给定状态的动作就是你滑动方块的方式（如果空位在中间则有 4 种，如果在边上则有 3 种，在角落则有 2 种）。</p></li><li><p><strong>转移模型 (Transition Model)</strong></p><p>描述在任何状态下执行任何适用动作后会产生什么状态。更准确地说，转移模型可以定义为一个函数。接收状态 <code>s</code> 和动作 <code>a</code> 作为输入，<code>Results(s, a)</code> 返回在状态 <code>s</code> 下执行动作 <code>a</code> 后产生的新状态。例如，给定 <em>15 数字推盘</em>的某种配置（状态 <code>s</code>），向任何方向移动一个方块（动作 <code>a</code>）都会带来拼图的新配置（新状态）。</p></li><li><p><strong>状态空间 (State Space)</strong></p><p>从初始状态通过任意动作序列可到达的所有状态的集合。例如，在 15 数字推盘中，状态空间由所有从初始状态可到达的 16!/2 种棋盘配置组成。状态空间可以可视化为一个有向图，状态表示为节点，动作表示为节点之间的箭头。</p></li></ul><p><img src="https://cs50.harvard.edu/ai/notes/0/statespace.png" alt="State Space"></p><ul><li><p><strong>目标测试 (Goal Test)</strong></p><p>确定给定状态是否为目标状态的条件。例如，在导航应用中，目标测试是检查智能体（汽车的代表）的当前位置是否在目的地。如果是——问题解决。如果不是——我们继续搜索。</p></li><li><p><strong>路径代价 (Path Cost)</strong></p><p>与给定路径相关的数值成本。例如，导航应用不仅带你到达目标；它会在最小化路径代价的同时这样做，即为你找到到达目标状态的最快方式。</p></li></ul><blockquote><p><strong>🔍 [译者注释]</strong>：理解这些术语至关重要。</p><ul><li><strong>状态 (State)</strong> 是“我们在哪里”。</li><li><strong>动作 (Action)</strong> 是“我们能做什么”。</li><li><strong>转移模型 (Transition)</strong> 是“做了之后会发生什么”。</li><li><strong>状态空间 (State Space)</strong> 是“所有可能情况的地图”。搜索算法本质上就是在这个巨大的“地图”中寻找一条路线。</li></ul></blockquote><h2 id="解决搜索问题"><a href="#解决搜索问题" class="headerlink" title="解决搜索问题"></a><a href="https://cs50.harvard.edu/ai/notes/0/#solving-search-problems">解决搜索问题</a></h2><ul><li><p><strong>解 (Solution)</strong></p><p>从初始状态导致目标状态的一系列动作。</p><ul><li><strong>最优解 (Optimal Solution)</strong><br>在所有解中具有最低路径代价的解。</li></ul></li></ul><p>在搜索过程中，数据通常存储在 <strong><em>节点 (Node)</em></strong> 中，这是一种包含以下数据的数据结构：</p><ul><li>一个 <em>状态 (state)</em></li><li>它的 <em>父节点 (parent node)</em>，即生成当前节点的那个节点</li><li>从父节点的状态应用到当前节点的 <em>动作 (action)</em></li><li>从初始状态到此节点的 <em>路径代价 (path cost)</em></li></ul><p><em>节点</em> 包含的信息使它们对搜索算法非常有用。它们包含一个 <em>状态</em>，可以使用 <em>目标测试</em> 来检查它是否是最终状态。如果是，该节点的 <em>路径代价</em> 可以与其他节点的 <em>路径代价</em> 进行比较，从而允许选择 <em>最优解</em>。一旦选择了节点，由于存储了 <em>父节点</em> 和导致从 <em>父节点</em> 到当前节点的 <em>动作</em>，就可以从 <em>初始状态</em> 一步步回溯到该节点，这个动作序列就是 <em>解</em>。</p><p>然而，<em>节点</em> 只是数据结构——它们不进行搜索，它们只是持有信息。为了实际进行搜索，我们使用 <strong>前沿 (frontier)</strong>（或称边界），这是一种“管理” <em>节点</em> 的机制。<em>前沿</em> 开始时包含一个初始状态和一个空的已探索项集合，然后重复以下操作直到找到解：</p><p><strong>重复 (Repeat):</strong></p><ol><li>如果前沿 (frontier) 为空，<ul><li><em>停止。</em> 问题无解。</li></ul></li><li>从前沿中移除一个节点。这是将被考虑的节点。</li><li><p>如果该节点包含目标状态，</p><ul><li>返回解。<em>停止</em>。</li></ul><p>否则 (Else)，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">* 扩展该节点（找到从该节点可以到达的所有新节点），并将结果节点添加到前沿中。<br>* 将当前节点添加到已探索集合 (explored set) 中。<br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li><strong>节点 vs 状态</strong>：这是一个常见的混淆点。<strong>状态</strong>是物理世界的配置（例如“我在 A 城市”）。<strong>节点</strong>是算法记录的账本（例如“我在 A 城市，我是从 B 城市过来的，目前花了 100 块钱”）。同一个状态（A 城市）可能对应多个节点（你可以从 B 来，也可以从 C 来）。</li><li><strong>前沿 (Frontier)</strong>：可以把它想象成一个“待办事项列表”。算法不断从这个列表中取出任务（节点）来处理，并把新发现的任务加进去。</li></ul></blockquote><h3 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索 (Depth-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#depth-first-search">深度优先搜索 (Depth-First Search)</a></h3><p>在前面关于 <em>前沿</em> 的描述中，有一件事没有提到。在伪代码的第 2 步，应该移除哪个节点？这个选择对解的质量以及找到解的速度有影响。有多种方法来决定应该首先考虑哪些节点，其中两种可以用 <strong>栈 (stack)</strong>（用于 <em>深度优先</em> 搜索）和 <strong>队列 (queue)</strong>（用于 <em>广度优先</em> 搜索）的数据结构来表示（<a href="https://www.google.com/search?q=dfs+vs+bfs+gif">这是一个可爱的卡通演示</a>）。</p><p>我们从 <em>深度优先</em> 搜索 (<em>DFS</em>) 方法开始。</p><p><em>深度优先</em> 搜索算法在尝试另一个方向之前会耗尽每一个方向。在这种情况下，前沿作为 <em>栈</em> 数据结构进行管理。你需要记住的口号是“<strong>后进先出 (Last-In First-Out)</strong>”。在节点被添加到前沿后，第一个被移除并考虑的节点是最后被添加的那一个。这导致搜索算法会在第一个阻碍它的方向上尽可能深地搜索，而将所有其他方向留待稍后处理。</p><p>（课程外的例子：假设你在找钥匙。在 <em>深度优先</em> 搜索方法中，如果你选择从裤子开始找，你会先检查每一个口袋，清空每个口袋并仔细检查内容物。只有当你完全检查完裤子的每一个口袋后，你才会停止在裤子里搜索并开始在其他地方搜索。）</p><ul><li><strong>优点</strong>:<ul><li>在最好的情况下，这个算法是最快的。如果它“运气好”并且总是（偶然地）选择通往解的正确路径，那么 <em>深度优先</em> 搜索花费的时间最少。</li></ul></li><li><strong>缺点</strong>:<ul><li>找到的解可能不是最优的。</li><li>在最坏的情况下，这个算法会在找到解之前探索每一条可能的路径，因此在到达解之前花费最长的时间。</li></ul></li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义从前沿移除节点并返回它的函数。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 如果前沿为空，则终止搜索，因为这意味着没有解。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;empty frontier&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 保存列表中的最后一项（即最新添加的节点）</span><br>        node = <span class="hljs-variable language_">self</span>.frontier[-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 保存列表中除了最后一个节点之外的所有项（即移除最后一个节点）</span><br>        <span class="hljs-variable language_">self</span>.frontier = <span class="hljs-variable language_">self</span>.frontier[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure><h3 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索 (Breadth-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#breadth-first-search">广度优先搜索 (Breadth-First Search)</a></h3><p><em>深度优先</em> 搜索的对立面是 <em>广度优先</em> 搜索 (<em>BFS</em>)。</p><p><em>广度优先</em> 搜索算法将同时沿着多个方向前进，在每个可能的方向上迈出一步，然后在每个方向上迈出第二步。在这种情况下，前沿作为 <em>队列</em> 数据结构进行管理。你需要记住的口号是“<strong>先进先出 (First-In First-Out)</strong>”。在这种情况下，所有新节点排队等候，根据添加的顺序来考虑节点（先到先得！）。这导致搜索算法在任何一个方向采取第二步之前，先在每个可能的方向上采取一步。</p><p>（课程外的例子：假设你在找钥匙。在这种情况下，如果你从裤子开始，你会看一眼右口袋。之后，你不会接着看左口袋，而是会看一眼抽屉。然后是桌子上。依此类推，在你通过所有想到的位置各看一眼之后。只有当你遍历了所有位置后，你才会回到裤子并搜索下一个口袋。）</p><ul><li><strong>优点</strong>:<ul><li>该算法<strong>保证</strong>找到最优解。</li></ul></li><li><strong>缺点</strong>:<ul><li>该算法几乎肯定比最小运行时间要长。</li><li>在最坏的情况下，该算法需要最长的时间运行。</li></ul></li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义从前沿移除节点并返回它的函数。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 如果前沿为空，则终止搜索，因为这意味着没有解。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;empty frontier&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 保存列表中的最老项（即第一个被添加的项）</span><br>        node = <span class="hljs-variable language_">self</span>.frontier[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 保存列表中除了第一项之外的所有项（即移除第一个节点）</span><br>        <span class="hljs-variable language_">self</span>.frontier = <span class="hljs-variable language_">self</span>.frontier[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li><strong>DFS (深度优先)</strong> 就像走迷宫时“一条路走到黑”，撞墙了再退回来。如果你运气好选对了路，很快就能到；运气不好，可能会绕很远。<strong>它不保证找到最近的路。</strong></li><li><strong>BFS (广度优先)</strong> 就像水波纹扩散，一圈一圈向外找。因为它是按距离（步数）一层层找的，所以它<strong>一定能找到步数最少的解</strong>（最优解），但通常比较耗费内存。</li></ul></blockquote><h3 id="贪婪最佳优先搜索-Greedy-Best-First-Search"><a href="#贪婪最佳优先搜索-Greedy-Best-First-Search" class="headerlink" title="贪婪最佳优先搜索 (Greedy Best-First Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#greedy-best-first-search">贪婪最佳优先搜索 (Greedy Best-First Search)</a></h3><p>广度优先和深度优先都是 <strong>无信息 (uninformed)</strong> 搜索算法。也就是说，这些算法除了通过自身探索获得的信息外，不利用任何关于问题的知识。然而，通常情况下，关于问题的一些知识实际上是可用的。例如，当人类迷宫解决者进入一个路口时，人类可以看到哪条路通向解的大致方向，哪条路不是。AI 也可以做同样的事情。一种考虑额外知识以试图提高其性能的算法称为 <strong>有信息 (informed)</strong> 搜索算法。</p><p><strong>贪婪最佳优先</strong> 搜索扩展那个由 <strong>启发式函数 (heuristic function)</strong> <em>h(n)</em> 确定为最接近目标的节点。顾名思义，该函数估计下一个节点距离目标有多近，但它可能会出错。<em>贪婪最佳优先</em> 算法的效率取决于启发式函数的好坏。例如，在迷宫中，算法可以使用一个依赖于可能节点与迷宫终点之间的 <strong>曼哈顿距离 (Manhattan distance)</strong> 的启发式函数。<em>曼哈顿距离</em> 忽略墙壁，计算从一个位置到达目标位置需要向上、向下或向两侧走多少步。这是一个基于当前位置和目标位置的 (x, y) 坐标可以得出的简单估算。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/manhattandistance.png" alt="Manhattan Distance"></p><p>曼哈顿距离</p><p>然而，必须强调的是，与任何启发式方法一样，它可能会出错并导致算法走上一条比其他路径更慢的路径。有可能 <em>无信息</em> 搜索算法会更快地提供更好的解，但它这样做的可能性比 <em>有信息</em> 算法要小。</p><blockquote><p><strong>🔍 [译者注释]</strong>：为什么叫“贪婪”？因为它只看眼前哪个节点离目标最近（由 $h(n)$ 决定），而不考虑它是怎么到达那个节点的（忽略了已经走过的成本）。这就像为了去某个地方，总是选择直线距离最近的路口，哪怕那条路其实很堵或者要绕远路。</p></blockquote><h3 id="A-搜索-A-Search"><a href="#A-搜索-A-Search" class="headerlink" title="A* 搜索 (A* Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#a-search">A* 搜索 (A* Search)</a></h3><p>作为 <em>贪婪最佳优先</em> 算法的发展，<em>A* 搜索</em> 不仅考虑 <em>h(n)</em>（从当前位置到目标的估计成本），还考虑 <em>g(n)</em>（直到当前位置所累积的成本）。通过结合这两个值，算法有一种更准确的方法来确定解的成本并动态优化其选择。算法跟踪 (<em>至今路径成本</em> + <em>到目标的估计成本</em>)，一旦它超过某个先前选项的估计成本，算法就会放弃当前路径并回到先前的选项，从而防止自己沿着 <em>h(n)</em> 错误地标记为最佳的一条长且低效的路径走下去。</p><p>同样，由于该算法也依赖于启发式，它的好坏取决于它所采用的启发式。在某些情况下，它可能比 <em>贪婪最佳优先</em> 搜索甚至 <em>无信息</em> 算法效率低。为了使 <em>A* 搜索</em> 成为最优的，启发式函数 <em>h(n)</em> 必须是：</p><ol><li><em>可采纳的 (Admissible)</em>，即通过不高估真实成本（即永远不大于实际成本）。</li><li><em>一致的 (Consistent)</em>，这意味着新节点到目标的估计路径成本加上从前一个节点转移到它的成本，大于或等于前一个节点到目标的估计路径成本。用方程形式表示，如果对于每个节点 <em>n</em> 和步长成本为 <em>c</em> 的后继节点 <em>n’</em>，都有 <em>h(n) ≤ h(n’) + c</em>，则 <em>h(n)</em> 是一致的。</li></ol><blockquote><p><strong>🔍 [译者注释]</strong>：A* 是目前最流行的寻路算法。</p><ul><li>公式：$f(n) = g(n) + h(n)$。<ul><li>$g(n)$：我已经走了多远（实际成本）。</li><li>$h(n)$：我估计还要走多远（启发式）。</li></ul></li><li><strong>可采纳性 (Admissible)</strong>：意味着你的估计必须是“乐观”的。如果你估计还需要走 10 步，但实际需要 5 步，那就不行；但如果你估计 10 步，实际需要 20 步，那是可以的。只要不高估，A* 就能保证找到最优解。</li></ul></blockquote><h3 id="对抗搜索-Adversarial-Search"><a href="#对抗搜索-Adversarial-Search" class="headerlink" title="对抗搜索 (Adversarial Search)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#adversarial-search">对抗搜索 (Adversarial Search)</a></h3><p>此前，我们讨论的算法需要找到问题的答案，而在 <strong>对抗搜索</strong> 中，算法面临着试图实现相反目标的对手。通常，使用对抗搜索的 AI 会出现在游戏中，例如井字棋 (Tic-Tac-Toe)。</p><h4 id="极小化极大算法-Minimax"><a href="#极小化极大算法-Minimax" class="headerlink" title="极小化极大算法 (Minimax)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#minimax">极小化极大算法 (Minimax)</a></h4><p>作为对抗搜索中的一种算法，<strong>Minimax</strong> 将胜利条件表示为一方 (-1) 和另一方 (+1)。进一步的行动将由这些条件驱动，最小化方试图获得最低分，最大化方试图获得最高分。</p><p><strong>表示井字棋 AI</strong>:</p><ul><li><em>S₀</em>: 初始状态（在我们的例子中，空的 3X3 棋盘）</li><li><em>Players(s)</em>: 给定状态 <em>s</em>，返回轮到哪个玩家（X 或 O）的函数。</li><li><em>Actions(s)</em>: 给定状态 <em>s</em>，返回该状态下所有合法移动（棋盘上哪些位置是空的）的函数。</li><li><em>Result(s, a)</em>: 给定状态 <em>s</em> 和动作 <em>a</em>，返回新状态的函数。这是在状态 <em>s</em> 上执行动作 <em>a</em>（在游戏中走一步）后产生的棋盘。</li><li><em>Terminal(s)</em>: 给定状态 <em>s</em>，检查这是否是游戏的最后一步（即是否有人赢了或平局）的函数。如果游戏结束返回 <em>True</em>，否则返回 <em>False</em>。</li><li><em>Utility(s)</em>: 给定终端状态 <em>s</em>，返回状态的效用值的函数：-1、0 或 1。</li></ul><p><strong>算法如何工作</strong>:</p><p>该算法递归地模拟从当前状态开始直到达到终端状态的所有可能发生的游戏。每个终端状态被赋值为 (-1)、0 或 (+1)。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/minimax_tictactoe.png" alt="Minimax in Tic Tac Toe"></p><p>井字棋中的 Minimax 算法</p><p>根据状态知道轮到谁，算法可以知道当前玩家在进行最佳操作时，会选择导致值更低还是更高的状态的动作。这样，在最小化和最大化之间交替，算法为每个可能动作导致的状态创建值。举个更具体的例子，我们可以想象最大化玩家在每一轮都会问：“如果我采取这个行动，将会产生一个新状态。如果最小化玩家玩得最好，那个玩家会采取什么行动来带来最低的值？”然而，要回答这个问题，最大化玩家必须问：“要知道最小化玩家会做什么，我需要在最小化玩家的脑海中模拟相同的过程：最小化玩家会试图问：‘如果我采取这个行动，最大化玩家可以采取什么行动来带来最高的值？’”这是一个递归过程，可能很难理解；看下面的伪代码会有所帮助。最终，通过这个递归推理过程，最大化玩家为当前状态下所有可能动作可能导致的状态生成值。拥有这些值后，最大化玩家选择最高的一个。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/minimax_theoretical.png" alt="Minimax Algorithm"></p><p>最大化者考虑未来状态的可能值。</p><p>用伪代码表示，Minimax 算法的工作方式如下：</p><ul><li>给定状态 <em>s</em><ul><li>最大化玩家在 <em>Actions(s)</em> 中选择动作 <em>a</em>，该动作产生 <em>Min-Value(Result(s, a))</em> 的最高值。</li><li>最小化玩家在 <em>Actions(s)</em> 中选择动作 <em>a</em>，该动作产生 <em>Max-Value(Result(s, a))</em> 的最低值。</li></ul></li><li>函数 <em>Max-Value(state)</em><ul><li><em>v = -∞</em></li><li>如果 <em>Terminal(state)</em>:<br>返回 <em>Utility(state)</em></li><li>对于 <em>Actions(state)</em> 中的 <em>action</em>:<br><em>v = Max(v, Min-Value(Result(state, action)))</em><br>返回 <em>v</em></li></ul></li><li>函数 <em>Min-Value(state)</em>:<ul><li><em>v = ∞</em></li><li>如果 <em>Terminal(state)</em>:<br>返回 <em>Utility(state)</em></li><li>对于 <em>Actions(state)</em> 中的 <em>action</em>:<br><em>v = Min(v, Max-Value(Result(state, action)))</em><br>返回 <em>v</em></li></ul></li></ul><blockquote><p><strong>🔍 [译者注释]</strong>：Minimax 的核心逻辑是“换位思考”。</p><ul><li><strong>Max (我)</strong>：我想赢（得分 +1）。</li><li><strong>Min (对手)</strong>：想让我输（得分 -1）。</li><li>在做决定时，我会假设对手极其聪明。如果我走 A 步，对手可能会走 X、Y 或 Z。我会看 X、Y、Z 中哪个对我<strong>最不利</strong>（因为对手会选那个）。然后我在所有可能的 A、B、C 步中，选择那个“最坏情况中最好的”结果。</li></ul></blockquote><h4 id="Alpha-Beta-剪枝-Alpha-Beta-Pruning"><a href="#Alpha-Beta-剪枝-Alpha-Beta-Pruning" class="headerlink" title="Alpha-Beta 剪枝 (Alpha-Beta Pruning)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#alpha-beta-pruning">Alpha-Beta 剪枝 (Alpha-Beta Pruning)</a></h4><p>作为优化 <em>Minimax</em> 的一种方法，<strong>Alpha-Beta 剪枝</strong> 跳过一些明显不利的递归计算。在确定了一个动作的值之后，如果有初步证据表明随后的动作可能让对手获得比已经确定的动作更好的分数，那么就没有必要进一步调查这个动作了，因为它肯定比先前确定的那个更不有利。</p><p>这用一个例子最容易展示：一个最大化玩家知道，在下一步，最小化玩家将试图获得最低分。假设最大化玩家有三个可能的动作，第一个动作的值为 4。然后玩家开始生成下一个动作的值。为此，玩家生成如果当前玩家采取此动作后最小化玩家动作的值，知道最小化者会选择最低的那个。然而，在完成最小化玩家所有可能动作的计算之前，玩家看到其中一个选项的值为 3。这意味着没有理由继续探索最小化玩家的其他可能动作了。尚未估值的动作的值是多少并不重要，无论是 10 还是 (-10)。如果值为 10，最小化者会选择最低的选项 3，这已经比预先确定的 4 差了。如果尚未估值的动作结果是 (-10)，最小化者将选择这个选项 (-10)，这对最大化者来说更加不利。因此，此时计算最小化者的其他可能动作对最大化者来说是无关紧要的，因为最大化玩家已经有了一个明确更好的选择，其值为 4。</p><p><img src="https://cs50.harvard.edu/ai/notes/0/alphabeta.png" alt="Alpha Beta Pruning"></p><blockquote><p><strong>🔍 [译者注释]</strong>：想象你在挑苹果，你想挑个最大的。</p><ul><li>第一筐里最小的苹果是 5 两重（所以这筐至少能给你 5 两）。</li><li>你开始看第二筐，拿起来第一个苹果是 3 两。</li><li><strong>剪枝</strong>：你不需要再看第二筐剩下的苹果了。因为你是最大化者（想要最大的），而这一步是对手（最小化者）在选。对手既然能在第二筐找到 3 两的，那他绝对不会让你在这一筐得到超过 3 两的结果。既然 3 两已经比第一筐的 5 两差了，第二筐就被你放弃了。</li></ul></blockquote><h4 id="深度受限-Minimax-Depth-Limited-Minimax"><a href="#深度受限-Minimax-Depth-Limited-Minimax" class="headerlink" title="深度受限 Minimax (Depth-Limited Minimax)"></a><a href="https://cs50.harvard.edu/ai/notes/0/#depth-limited-minimax">深度受限 Minimax (Depth-Limited Minimax)</a></h4><p>井字棋共有 255,168 种可能的游戏过程，而国际象棋有 10²⁹⁰⁰⁰ 种可能的游戏。目前所介绍的 Minimax 算法需要生成从某一点到终端条件的所有假设游戏。虽然现代计算机计算所有井字棋游戏并不构成挑战，但对国际象棋这样做目前是不可能的。</p><p><strong>深度受限 Minimax</strong> 仅考虑预定义数量的步数后就停止，而不必到达终端状态。然而，这不允许为每个动作获得精确的值，因为尚未到达假设游戏的结尾。为了解决这个问题，<em>深度受限 Minimax</em> 依赖于一个 <strong>评估函数 (evaluation function)</strong>，该函数估计从给定状态开始的游戏的预期效用，换句话说，为状态赋值。例如，在国际象棋游戏中，效用函数将接收棋盘的当前配置作为输入，尝试评估其预期效用（基于每个玩家拥有的棋子及其在棋盘上的位置），然后返回一个正值或负值，表示该棋盘对一个玩家相对于另一个玩家的有利程度。这些值可用于决定正确的动作，评估函数越好，依赖它的 Minimax 算法就越好。</p><blockquote><p><strong>🔍 [译者注释]</strong>：</p><ul><li>这就是现实中下棋软件（如早期的“深蓝”）的工作原理。它算不了无限远，只能算往后 10 步或 20 步。</li><li><strong>评估函数</strong> 是关键：当我看不到结局时，我必须凭经验判断现在的局势是好是坏。例如：“我有皇后，对方没有，所以我这局势+9分”。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>学院派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS50AI</tag>
      
      <tag>讲义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序算法</title>
    <link href="/2025/12/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2025/12/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="🧩-归并排序（Merge-Sort）：分而治之的艺术"><a href="#🧩-归并排序（Merge-Sort）：分而治之的艺术" class="headerlink" title="🧩 归并排序（Merge Sort）：分而治之的艺术"></a>🧩 归并排序（Merge Sort）：分而治之的艺术</h1><p>归并排序的核心思想是：<strong>先拆分，后合并</strong>。<br>它将一个大数组不断二分，直到每个小数组只有一个元素（此时每个小数组都是有序的），然后将这些有序的小数组两两合并，最终得到完整的有序数组。<br><img src="/img/归并排序/2025-12-29-13-14-29.png" alt=""></p><h2 id="1-核心原理：两个阶段"><a href="#1-核心原理：两个阶段" class="headerlink" title="1. 核心原理：两个阶段"></a>1. 核心原理：两个阶段</h2><ol><li><strong>分（Divide）</strong>：找到数组的中点，把数组一分为二。递归地对左右两半进行同样的操作，直到数组长度为 1。</li><li><strong>治/合（Merge）</strong>：这是最关键的一步。将两个<strong>已经排好序</strong>的子数组合并成一个新的有序数组。</li></ol><h3 id="💡-生动比喻"><a href="#💡-生动比喻" class="headerlink" title="💡 生动比喻"></a>💡 生动比喻</h3><p>想象你要整理一副乱序的扑克牌：</p><ul><li><strong>分</strong>：你把牌堆不断对半切开，直到每个人手里都只拿<strong>一张牌</strong>（一张牌自然是有序的）。</li><li><strong>合</strong>：两个拿牌的人比较谁手里的牌小，谁先放在桌上。接着四个人的两组牌再进行比较合并……最终整副牌就排好了。</li></ul><hr><h2 id="2-核心语法与实现（Java）"><a href="#2-核心语法与实现（Java）" class="headerlink" title="2. 核心语法与实现（Java）"></a>2. 核心语法与实现（Java）</h2><p>归并排序通常使用<strong>递归</strong>来实现。我们需要一个辅助函数来执行“合并”操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;排序前：&quot;</span> + Arrays.toString(arr));<br>        <br>        mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;排序后：&quot;</span> + Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-comment">// 递归拆分函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">// 找到中间索引，防止溢出的写法</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">// 递归拆分左半部分</span><br>            mergeSort(arr, left, mid);<br>            <span class="hljs-comment">// 递归拆分右半部分</span><br>            mergeSort(arr, mid + <span class="hljs-number">1</span>, right);<br><br>            <span class="hljs-comment">// 合并左右两部分</span><br>            merge(arr, left, mid, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 核心合并函数：将两个有序区间 [left, mid] 和 [mid+1, right] 合并</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建临时数组存放合并结果</span><br>        <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left;      <span class="hljs-comment">// 左子数组的起点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 右子数组的起点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;         <span class="hljs-comment">// 临时数组的索引</span><br><br>        <span class="hljs-comment">// 2. 比较两个子数组，谁小就谁进 temp</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) &#123;<br>                temp[k++] = arr[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp[k++] = arr[j++];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 将左边剩余元素放入 temp（如果有）</span><br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            temp[k++] = arr[i++];<br>        &#125;<br><br>        <span class="hljs-comment">// 4. 将右边剩余元素放入 temp（如果有）</span><br>        <span class="hljs-keyword">while</span> (j &lt;= right) &#123;<br>            temp[k++] = arr[j++];<br>        &#125;<br><br>        <span class="hljs-comment">// 5. 把排好序的 temp 复制回原数组 arr</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; p &lt; temp.length; p++) &#123;<br>            arr[left + p] = temp[p];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3. 性能分析"></a>3. 性能分析</h2><ul><li><strong>时间复杂度</strong>：始终是 $O(n \log n)$。不管原数组是乱序还是已经排好序，它的表现都非常稳定。</li><li><strong>空间复杂度</strong>：$O(n)$。因为合并过程中需要一个和原数组一样大的临时数组。</li><li><strong>稳定性</strong>：<strong>稳定</strong>排序。在合并逻辑中，如果 <code>arr[i] == arr[j]</code>，我们先放左边的 <code>arr[i]</code>，保证了相同元素的相对顺序不变。</li></ul><hr><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ol><li><strong>大规模数据排序</strong>：当内存装不下所有数据时，归并排序的思想可以用于<strong>外部排序</strong>（从磁盘读入部分数据排序后再合并）。</li><li><strong>求逆序对</strong>：这是归并排序的一个典型算法变种题。</li><li><strong>链表排序</strong>：在 LeetCode 中，排序链表的最佳选择通常是归并排序，因为链表不需要连续的内存空间。</li></ol><hr><h2 id="⚠️-讲师提醒：新手易错点"><a href="#⚠️-讲师提醒：新手易错点" class="headerlink" title="⚠️ 讲师提醒：新手易错点"></a>⚠️ 讲师提醒：新手易错点</h2><ol><li><strong>递归终止条件</strong>：一定要写 <code>if (left &lt; right)</code>，否则会进入死循环（栈溢出）。</li><li><strong>中点计算</strong>：使用 <code>mid = left + (right - left) / 2</code> 能够有效避免 <code>(left + right)</code> 导致的整数溢出风险。</li><li><strong>区间闭合</strong>：合并时注意 <code>while (i &lt;= mid)</code> 的等于号，漏掉会导致数组元素丢失。</li></ol>]]></content>
    
    
    <categories>
      
      <category>DS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java生成随机数</title>
    <link href="/2025/12/24/Java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <url>/2025/12/24/Java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="🎲-Java-核心：生成随机数的-4-种姿势"><a href="#🎲-Java-核心：生成随机数的-4-种姿势" class="headerlink" title="🎲 Java 核心：生成随机数的 4 种姿势"></a>🎲 Java 核心：生成随机数的 4 种姿势</h1><blockquote><p><strong>导读</strong>：<br>并不是所有的随机数都是“真随机”。<br>在 Java 中，你需要根据你的应用场景（是写个小Demo，还是写银行支付系统）来选择不同的随机数生成器。</p></blockquote><hr><h2 id="1-简易入门：Math-random"><a href="#1-简易入门：Math-random" class="headerlink" title="1. 简易入门：Math.random()"></a>1. 简易入门：Math.random()</h2><h3 id="📖-概念定义"><a href="#📖-概念定义" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是 Java 最基础的工具类 <code>Math</code> 提供的一个静态方法。它不需要 <code>new</code> 对象，直接调用即可。</p><h3 id="⚙️-核心规则"><a href="#⚙️-核心规则" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>返回值</strong>：它固定返回一个 <code>0.0</code> (包含) 到 <code>1.0</code> (不包含) 之间的 <code>double</code> 小数。</li><li><strong>底层</strong>：其实它底层也是调用了 <code>java.util.Random</code>，只是做了一层简单的封装。</li></ul><h3 id="💻-代码示例"><a href="#💻-代码示例" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathRandomDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 基础用法：生成 0.0 ~ 1.0 之间的小数</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Math.random();<br>        System.out.println(<span class="hljs-string">&quot;随机小数: &quot;</span> + d);<br><br>        <span class="hljs-comment">// 2. 进阶用法：生成 [0, 100) 之间的整数</span><br>        <span class="hljs-comment">// 逻辑：先把 0.x 放大100倍，再强制转成 int 去掉小数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>);<br>        System.out.println(<span class="hljs-string">&quot;0到99的整数: &quot;</span> + num);<br><br>        <span class="hljs-comment">// 3. 必背公式：生成 [min, max] 之间的整数 (包含两端)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">// 公式：(int)(Math.random() * (最大值 - 最小值 + 1)) + 最小值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rangeNum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * (max - min + <span class="hljs-number">1</span>)) + min;<br>        System.out.println(<span class="hljs-string">&quot;50到100的整数: &quot;</span> + rangeNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景"><a href="#🚀-应用场景" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li>快速测试、简单的脚本。</li><li><strong>缺点</strong>：写区间公式太麻烦，容易算错。</li></ul><hr><h2 id="2-标准通用：java-util-Random"><a href="#2-标准通用：java-util-Random" class="headerlink" title="2. 标准通用：java.util.Random"></a>2. 标准通用：java.util.Random</h2><h3 id="📖-概念定义-1"><a href="#📖-概念定义-1" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是 Java 面向对象标准的随机数生成器。你需要先创建一个“骰子”对象，然后摇它。</p><h3 id="⚙️-核心规则-1"><a href="#⚙️-核心规则-1" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>灵活性</strong>：可以直接生成 <code>int</code>, <code>boolean</code>, <code>float</code> 等多种类型，不需要像 <code>Math.random</code> 那样手动转换。</li><li><strong>种子 (Seed)</strong>：如果你在 new 的时候传入一个固定的数字（种子），那么每次运行生成的随机数序列是<strong>一模一样</strong>的（常用于复现 Bug）。</li></ul><h3 id="💻-代码示例-1"><a href="#💻-代码示例-1" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UtilRandomDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建随机数对象 (不带种子，默认以当前时间为种子)</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>        <span class="hljs-comment">// 2. 生成各种类型的随机数</span><br>        System.out.println(<span class="hljs-string">&quot;随机布尔值: &quot;</span> + r.nextBoolean()); <span class="hljs-comment">// true 或 false</span><br>        System.out.println(<span class="hljs-string">&quot;随机Double: &quot;</span> + r.nextDouble()); <span class="hljs-comment">// 0.0 ~ 1.0</span><br><br>        <span class="hljs-comment">// 3. 最好用的方法：nextInt(bound)</span><br>        <span class="hljs-comment">// 生成 [0, 10) 之间的整数 (不包含10)</span><br>        <span class="hljs-comment">// 也就是 0 ~ 9</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>); <br>        System.out.println(<span class="hljs-string">&quot;0到9的整数: &quot;</span> + i);<br>        <br>        <span class="hljs-comment">// ------------------------------------</span><br>        <span class="hljs-comment">// 特殊情况：带种子的随机 (伪随机的真相)</span><br>        <span class="hljs-comment">// 只要种子一样，生成的随机数顺序永远一样</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">rFixed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">100</span>); <br>        System.out.println(<span class="hljs-string">&quot;固定随机数1: &quot;</span> + rFixed.nextInt(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 每次运行都是同一个数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-1"><a href="#🚀-应用场景-1" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li>大多数业务开发、游戏逻辑、模拟数据。</li></ul><hr><h2 id="3-高性能并发：ThreadLocalRandom-Java-7"><a href="#3-高性能并发：ThreadLocalRandom-Java-7" class="headerlink" title="3. 高性能并发：ThreadLocalRandom (Java 7+)"></a>3. 高性能并发：ThreadLocalRandom (Java 7+)</h2><h3 id="📖-概念定义-2"><a href="#📖-概念定义-2" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是为了解决多线程问题而生的工具。</p><h3 id="💡-通俗理解"><a href="#💡-通俗理解" class="headerlink" title="💡 通俗理解"></a>💡 通俗理解</h3><p><code>java.util.Random</code> 是线程安全的，但在多线程高并发时（比如 1000 个人同时去抢一个骰子），会产生<strong>竞争</strong>，导致性能下降。<br><code>ThreadLocalRandom</code> 相当于<strong>给每个线程发了一个专用的骰子</strong>，互不干扰，速度极快。</p><h3 id="💻-代码示例-2"><a href="#💻-代码示例-2" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TLRDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 注意：不能 new，要用 current() 获取当前线程的实例</span><br>        <span class="hljs-type">ThreadLocalRandom</span> <span class="hljs-variable">tlr</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current();<br><br>        <span class="hljs-comment">// 用法和 Random 几乎一样，但性能更高</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> tlr.nextInt(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 直接支持生成 [10, 20) 的范围，超方便！</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;10到19的整数: &quot;</span> + val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-2"><a href="#🚀-应用场景-2" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li><strong>高并发系统</strong>、多线程环境。</li><li>在 JDK 7 之后，<strong>强烈推荐</strong>在多线程能替代 <code>Random</code> 的地方都用这个。</li></ul><hr><h2 id="4-银行级安全：java-security-SecureRandom"><a href="#4-银行级安全：java-security-SecureRandom" class="headerlink" title="4. 银行级安全：java.security.SecureRandom"></a>4. 银行级安全：java.security.SecureRandom</h2><h3 id="📖-概念定义-3"><a href="#📖-概念定义-3" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>真·随机数生成器。前面的 <code>Random</code> 实际上是根据算法算出来的（伪随机），如果黑客知道了算法和种子，就能预测下一个数。<br><code>SecureRandom</code> 利用操作系统的随机源（如鼠标移动、键盘敲击、CPU热噪声等）来生成随机数。</p><h3 id="⚙️-核心规则-2"><a href="#⚙️-核心规则-2" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>不可预测性</strong>：极其难以被破解。</li><li><strong>性能</strong>：比普通的 Random 慢很多（因为生成过程很复杂）。</li></ul><h3 id="💻-代码示例-3"><a href="#💻-代码示例-3" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">sr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>        <br>        <span class="hljs-comment">// 用法和 Random 一样</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">passwordPart</span> <span class="hljs-operator">=</span> sr.nextInt(<span class="hljs-number">10000</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;安全随机数: &quot;</span> + passwordPart);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-3"><a href="#🚀-应用场景-3" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li><strong>生成密码、Token、Session ID、加密密钥</strong>。</li><li>凡是涉及到<strong>钱</strong>和<strong>安全</strong>的地方，严禁使用 <code>Math.random</code> 或 <code>Random</code>，必须用 <code>SecureRandom</code>。</li></ul><hr><h2 id="📝-总结：我该用哪个？"><a href="#📝-总结：我该用哪个？" class="headerlink" title="📝 总结：我该用哪个？"></a>📝 总结：我该用哪个？</h2><div class="table-container"><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">推荐方式</th><th style="text-align:left">理由</th></tr></thead><tbody><tr><td style="text-align:left"><strong>写个小Demo / 教学</strong></td><td style="text-align:left"><code>Math.random()</code></td><td style="text-align:left">代码最短，不用导包。</td></tr><tr><td style="text-align:left"><strong>一般业务 / 单线程</strong></td><td style="text-align:left"><code>java.util.Random</code></td><td style="text-align:left">API 丰富，符合直觉。</td></tr><tr><td style="text-align:left"><strong>高并发 / 多线程</strong></td><td style="text-align:left"><code>ThreadLocalRandom</code></td><td style="text-align:left"><strong>性能王者</strong>，不堵车。</td></tr><tr><td style="text-align:left"><strong>生成密码 / 涉及钱</strong></td><td style="text-align:left"><code>SecureRandom</code></td><td style="text-align:left"><strong>安全王者</strong>，黑客猜不到。</td></tr></tbody></table></div><h3 id="💡-讲师提示"><a href="#💡-讲师提示" class="headerlink" title="💡 讲师提示"></a>💡 讲师提示</h3><p>作为新手，你现阶段主要掌握 <strong><code>java.util.Random</code></strong> 就足够应对 90% 的学习场景了。但记住，等到以后做Web项目生成验证码时，一定要想起来用 <code>SecureRandom</code> 哦！</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JavaSE</tag>
      
      <tag>语法知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数组常用API</title>
    <link href="/2025/12/24/Java%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8API/"/>
    <url>/2025/12/24/Java%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h1 id="🚀-Java-进阶：数组常用-API-与经典操作实战"><a href="#🚀-Java-进阶：数组常用-API-与经典操作实战" class="headerlink" title="🚀 Java 进阶：数组常用 API 与经典操作实战"></a>🚀 Java 进阶：数组常用 API 与经典操作实战</h1><blockquote><p><strong>导读</strong>：<br>这一节我们将解锁 Java 数组的“瑞士军刀”——<code>java.util.Arrays</code> 类，它可以让你一行代码搞定排序、查找和打印。<br>同时，我们也会深入底层，手写几个经典的数组算法（如反转、扩容），这是理解数据结构逻辑的关键。</p></blockquote><hr><h2 id="第一部分：Java-数组的“瑞士军刀”-常用-API"><a href="#第一部分：Java-数组的“瑞士军刀”-常用-API" class="headerlink" title="第一部分：Java 数组的“瑞士军刀” (常用 API)"></a>第一部分：Java 数组的“瑞士军刀” (常用 API)</h2><p>Java 官方为了不让我们重复造轮子，提供了一个强大的工具类 <code>java.util.Arrays</code>。使用前请记得 <code>import java.util.Arrays;</code>。</p><h3 id="1-🔍-查看与打印：toString-amp-deepToString"><a href="#1-🔍-查看与打印：toString-amp-deepToString" class="headerlink" title="1. 🔍 查看与打印：toString() &amp; deepToString()"></a>1. 🔍 查看与打印：<code>toString()</code> &amp; <code>deepToString()</code></h3><p>直接打印数组变量只能看到内存地址，必须用这个方法才能看到“真面目”。</p><ul><li><strong>场景</strong>：调试代码，查看数组里的内容。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(Arrays.toString(arr)); <br><span class="hljs-comment">// 输出: [1, 2, 3]</span><br><br><span class="hljs-type">int</span>[][] matrix = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;;<br><span class="hljs-comment">// 注意：多维数组要用 deepToString，否则里面的数组还是显示地址</span><br>System.out.println(Arrays.deepToString(matrix)); <br><span class="hljs-comment">// 输出: [[1, 2], [3, 4]]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-🔢-排序：sort"><a href="#2-🔢-排序：sort" class="headerlink" title="2. 🔢 排序：sort()"></a>2. 🔢 排序：<code>sort()</code></h3><p>将数组元素按照从小到大（升序）排列。底层使用了双轴快速排序等高效算法。</p><ul><li><strong>场景</strong>：排行榜、数据整理。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] scores = &#123;<span class="hljs-number">88</span>, <span class="hljs-number">50</span>, <span class="hljs-number">99</span>, <span class="hljs-number">70</span>&#125;;<br>Arrays.sort(scores);<br>System.out.println(Arrays.toString(scores)); <br><span class="hljs-comment">// 输出: [50, 70, 88, 99] (自动变成有序了)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-🔎-查找：binarySearch-二分查找"><a href="#3-🔎-查找：binarySearch-二分查找" class="headerlink" title="3. 🔎 查找：binarySearch() (二分查找)"></a>3. 🔎 查找：<code>binarySearch()</code> (二分查找)</h3><p>在一个<strong>有序</strong>的数组中快速查找某个元素的位置。</p><ul><li><strong>⚠️ 注意</strong>：使用此方法前，<strong>必须先排序</strong>！如果数组是乱序的，结果不可预测。</li><li><p><strong>返回值</strong>：如果找到，返回索引；如果找不到，返回负数。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;; <span class="hljs-comment">// 必须是有序的</span><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums, <span class="hljs-number">30</span>);<br>System.out.println(<span class="hljs-string">&quot;30的下标是：&quot;</span> + index); <span class="hljs-comment">// 输出: 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">errorIndex</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums, <span class="hljs-number">25</span>);<br>System.out.println(<span class="hljs-string">&quot;找不存在的数：&quot;</span> + errorIndex); <span class="hljs-comment">// 输出负数 (例如 -3)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-👯-比较：equals"><a href="#4-👯-比较：equals" class="headerlink" title="4. 👯 比较：equals()"></a>4. 👯 比较：<code>equals()</code></h3><p>判断两个数组的<strong>内容</strong>是否完全一致（长度相同，且对应位置元素相同）。</p><ul><li><p><strong>注意</strong>：直接用 <code>==</code> 比较的是两个数组的内存地址，通常都是 <code>false</code>。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] arr2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>System.out.println(arr1 == arr2);       <span class="hljs-comment">// false (它是两个不同的对象)</span><br>System.out.println(Arrays.equals(arr1, arr2)); <span class="hljs-comment">// true (内容一样)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5-🛠-填充：fill"><a href="#5-🛠-填充：fill" class="headerlink" title="5. 🛠 填充：fill()"></a>5. 🛠 填充：<code>fill()</code></h3><p>快速把数组的所有位置（或指定范围）都填成同一个值。</p><ul><li><strong>场景</strong>：初始化游戏地图、重置数据。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>Arrays.fill(box, <span class="hljs-number">666</span>); <span class="hljs-comment">// 把整个数组都填满 666</span><br><span class="hljs-comment">// 输出: [666, 666, 666, 666, 666]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6-📋-复制与截取：copyOf-amp-copyOfRange"><a href="#6-📋-复制与截取：copyOf-amp-copyOfRange" class="headerlink" title="6. 📋 复制与截取：copyOf() &amp; copyOfRange()"></a>6. 📋 复制与截取：<code>copyOf()</code> &amp; <code>copyOfRange()</code></h3><ul><li><code>copyOf(原数组, 新长度)</code>：从头开始复制，可用于扩容或截断。</li><li><p><code>copyOfRange(原数组, start, end)</code>：复制中间某一段（含头不含尾）。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><br><span class="hljs-comment">// 复制前3个</span><br><span class="hljs-type">int</span>[] newArr = Arrays.copyOf(src, <span class="hljs-number">3</span>); <br><span class="hljs-comment">// 结果: [10, 20, 30]</span><br><br><span class="hljs-comment">// 扩容复制 (后面补默认值)</span><br><span class="hljs-type">int</span>[] bigArr = Arrays.copyOf(src, <span class="hljs-number">7</span>);<br><span class="hljs-comment">// 结果: [10, 20, 30, 40, 50, 0, 0]</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="⚡-补充：一个高效的底层-API"><a href="#⚡-补充：一个高效的底层-API" class="headerlink" title="⚡ 补充：一个高效的底层 API"></a>⚡ 补充：一个高效的底层 API</h2><p>在阅读 Java 源码时，你会经常看到 <code>System.arraycopy</code>。它是最底层的数组复制方法，性能极高（直接操作内存），但参数比较多，容易写错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法：</span><br><span class="hljs-comment">// System.arraycopy(原数组, 原数组起始位置, 目标数组, 目标数组起始位置, 复制多少个);</span><br><br><span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span>[] dest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">// 把 src 的后两个元素 (3,4) 复制到 dest 的开头</span><br>System.arraycopy(src, <span class="hljs-number">2</span>, dest, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br><br>System.out.println(Arrays.toString(dest)); <br><span class="hljs-comment">// 输出: [3, 4, 0, 0]</span><br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>日常开发</strong>：首选 <code>java.util.Arrays</code> 类，代码简洁，可读性高。</li><li><strong>性能敏感/底层开发</strong>：使用 <code>System.arraycopy</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JavaSE</tag>
      
      <tag>语法知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java为什么不用const</title>
    <link href="/2025/12/23/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8const/"/>
    <url>/2025/12/23/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8const/</url>
    
    <content type="html"><![CDATA[<p>在学习 Java 时，很多从 C++ 或 C# 转过来的小伙伴都会下意识地去找 <code>const</code>。但在 Java 中，情况有点特殊。</p><hr><h2 id="1-const：有名无实的“保留字”"><a href="#1-const：有名无实的“保留字”" class="headerlink" title="1. const：有名无实的“保留字”"></a>1. <code>const</code>：有名无实的“保留字”</h2><p><strong>概念定义</strong>：在 Java 中，<code>const</code> 被称为<strong>保留字（Reserved Word）</strong>，而不是<strong>关键字（Keyword）</strong>。</p><ul><li><strong>现状</strong>：它在 Java 源码中存在，但没有任何语法功能。</li><li><strong>规则</strong>：你不能用 <code>const</code> 来定义常量，同时你也<strong>不能</strong>用 <code>const</code> 作为你的变量名。</li><li><strong>为什么保留它？</strong>：主要是为了防止程序员在写 Java 时误用了 C++ 的习惯，或者为了将来可能的版本升级预留位置。</li></ul><hr><h2 id="2-真正的常量主角：final"><a href="#2-真正的常量主角：final" class="headerlink" title="2. 真正的常量主角：final"></a>2. 真正的常量主角：<code>final</code></h2><p><strong>概念定义</strong>：在 Java 中，如果你想定义一个“一旦赋值就不能改变”的量，必须使用关键字 <strong><code>final</code></strong>。</p><h3 id="核心规则："><a href="#核心规则：" class="headerlink" title="核心规则："></a>核心规则：</h3><ol><li><strong>不可变性</strong>：被 <code>final</code> 修饰的变量，只能被赋值一次，之后再尝试修改会直接报错。</li><li><strong>命名规范</strong>：Java 中的常量通常要求<strong>全部大写</strong>，多个单词之间用下划线 <code>_</code> 分隔（例如：<code>MAX_SPEED</code>）。</li><li><strong>修饰位置</strong>：<code>final</code> 既可以修饰局部变量，也可以修饰类成员变量。</li></ol><hr><h2 id="3-代码示例：如何正确定义常量"><a href="#3-代码示例：如何正确定义常量" class="headerlink" title="3. 代码示例：如何正确定义常量"></a>3. 代码示例：如何正确定义常量</h2><p>在实际开发中，我们通常结合 <code>static</code> 和 <code>final</code> 来定义一个全局常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstantDemo</span> &#123;<br>    <span class="hljs-comment">// 1. 类级别的全局常量（最常见用法）</span><br>    <span class="hljs-comment">// static 让它属于类，final 保证它不可变</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926535</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_LOGIN_ATTEMPTS</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 2. 局部常量</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <br>        <span class="hljs-comment">// age = 21; // ❌ 编译报错：无法为最终变量 age 分配值</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;圆周率是：&quot;</span> + PI);<br>        System.out.println(<span class="hljs-string">&quot;我的年龄是：&quot;</span> + age);<br>        <br>        <span class="hljs-comment">// 3. 错误示范（如果你非要用 const）</span><br>        <span class="hljs-comment">// int const = 10; // ❌ 编译报错：const 是保留字，不能用作标识符</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-final-与-const-的对比-Java-vs-其他语言"><a href="#4-final-与-const-的对比-Java-vs-其他语言" class="headerlink" title="4. final 与 const 的对比 (Java vs 其他语言)"></a>4. <code>final</code> 与 <code>const</code> 的对比 (Java vs 其他语言)</h2><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Java 的 <code>final</code></th><th style="text-align:left">C++/C# 的 <code>const</code></th></tr></thead><tbody><tr><td style="text-align:left"><strong>定义常量</strong></td><td style="text-align:left">✅ 完美支持</td><td style="text-align:left">✅ 完美支持</td></tr><tr><td style="text-align:left"><strong>运行期赋值</strong></td><td style="text-align:left">✅ 支持（可以在运行时计算值再锁定）</td><td style="text-align:left">❌ 通常要求编译期确定值</td></tr><tr><td style="text-align:left"><strong>修饰类/方法</strong></td><td style="text-align:left">✅ 可以（防止类被继承或方法被重写）</td><td style="text-align:left">❌ 通常只修饰变量</td></tr></tbody></table></div><h1 id="进阶笔记：Java-final-vs-C-C-const-的三大本质区别"><a href="#进阶笔记：Java-final-vs-C-C-const-的三大本质区别" class="headerlink" title="进阶笔记：Java final vs C++/C# const 的三大本质区别"></a>进阶笔记：Java <code>final</code> vs C++/C# <code>const</code> 的三大本质区别</h1><p>很多编程语言都有 <code>const</code>，但在 Java 中，<code>final</code> 承担了更多的职责。你提到的“运行期赋值”和“修饰类/方法”正是它的灵魂所在。</p><hr><h3 id="4-1-运行期赋值：不仅仅是“死板”的常量"><a href="#4-1-运行期赋值：不仅仅是“死板”的常量" class="headerlink" title="4.1. 运行期赋值：不仅仅是“死板”的常量"></a>4.1. 运行期赋值：不仅仅是“死板”的常量</h3><p>在 C# 等语言中，<code>const</code> 要求在<strong>编译时</strong>就确定值（比如 <code>3.14</code>）。但 Java 的 <code>final</code> 允许你在<strong>运行时</strong>再决定它的值，一旦定下来，就不再更改。</p><p><strong>比喻</strong>：<code>const</code> 是“出厂即刻字”，而 <code>final</code> 是“发货前才填写的终身快递单”。</p><p><strong>代码示例</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalRuntimeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 运行期赋值：每次运行，value 的值可能都不一样</span><br>        <span class="hljs-comment">// 但在同一个生命周期内，value 一旦被赋值就不能再改</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;本次运行确定的常量值：&quot;</span> + value);<br>        <br>        <span class="hljs-comment">// value = 200; // ❌ 依然会报错，因为它已经是 final 了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><strong>应用场景</strong>：比如根据用户的输入、数据库的查询结果、或者是当前系统的年份来初始化一个“只读变量”。</p><hr><h3 id="2-架构防线：修饰类与方法"><a href="#2-架构防线：修饰类与方法" class="headerlink" title="2. 架构防线：修饰类与方法"></a>2. 架构防线：修饰类与方法</h3><p>这是 <code>const</code> 完全无法触及的领域。在 Java 中，<code>final</code> 被用来保护代码的<strong>继承结构</strong>。</p><h4 id="A-修饰方法-Prevent-Overriding"><a href="#A-修饰方法-Prevent-Overriding" class="headerlink" title="A. 修饰方法 (Prevent Overriding)"></a>A. 修饰方法 (Prevent Overriding)</h4><p><strong>规则</strong>：父类的方法被 <code>final</code> 修饰后，子类<strong>不能重写</strong>它。<br><strong>意义</strong>：锁定核心逻辑，防止子类“乱改”导致逻辑崩溃。</p><h4 id="B-修饰类-Prevent-Inheritance"><a href="#B-修饰类-Prevent-Inheritance" class="headerlink" title="B. 修饰类 (Prevent Inheritance)"></a>B. 修饰类 (Prevent Inheritance)</h4><p><strong>规则</strong>：类被 <code>final</code> 修饰后，<strong>不能被继承</strong>。<br><strong>意义</strong>：比如 <code>String</code> 类就是 <code>final</code> 的。如果人人都能继承并修改 <code>String</code> 的行为，整个 Java 世界就乱套了。</p><p><strong>代码示例</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是一个 final 类，不能有“儿子”</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecuritySystem</span> &#123;<br>    <br>    <span class="hljs-comment">// 这是一个 final 方法，子类即便能继承（如果类不是 final），也不能修改</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verifyIdentity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行极其严格的身份核验逻辑，禁止修改！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class HackSystem extends SecuritySystem &#123; &#125; // ❌ 报错：无法从最终类继承</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="3-深度对比表：为什么-final-比-const-更强大？"><a href="#3-深度对比表：为什么-final-比-const-更强大？" class="headerlink" title="3. 深度对比表：为什么 final 比 const 更强大？"></a>3. 深度对比表：为什么 <code>final</code> 比 <code>const</code> 更强大？</h3><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Java <code>final</code></th><th style="text-align:left">典型 <code>const</code> (如 C#)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>赋值时机</strong></td><td style="text-align:left"><strong>编译期 或 运行期</strong></td><td style="text-align:left">通常只能是 <strong>编译期</strong></td></tr><tr><td style="text-align:left"><strong>修饰变量</strong></td><td style="text-align:left">✅ 锁定引用/值</td><td style="text-align:left">✅ 锁定值</td></tr><tr><td style="text-align:left"><strong>修饰类</strong></td><td style="text-align:left">✅ 禁止继承</td><td style="text-align:left">❌ 不支持 (C# 用 <code>sealed</code>)</td></tr><tr><td style="text-align:left"><strong>修饰方法</strong></td><td style="text-align:left">✅ 禁止重写</td><td style="text-align:left">❌ 不支持</td></tr><tr><td style="text-align:left"><strong>对象控制</strong></td><td style="text-align:left">只能锁定“盒子”不换，不能锁“内容”</td><td style="text-align:left">深度锁定（C++ 的 const 语义更强）</td></tr></tbody></table></div><hr><h3 id="4-重点避坑：引用不变-vs-内容不变"><a href="#4-重点避坑：引用不变-vs-内容不变" class="headerlink" title="4. 重点避坑：引用不变 vs 内容不变"></a>4. 重点避坑：引用不变 vs 内容不变</h3><p>这是新手最容易掉坑的地方：<strong><code>final</code> 修饰对象时，只是锁定了“地址”，没锁定“属性”。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>user.setName(<span class="hljs-string">&quot;Jerry&quot;</span>); <span class="hljs-comment">// ✅ 允许！内容可以变</span><br><span class="hljs-comment">// user = new User(&quot;Jack&quot;); // ❌ 报错！不能把 user 指向新对象</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>javatomd 总结</strong>：</p><h2 id="C-等语言追求的是“数据的绝对不可变”（Const-correctness），而-Java-的-final-追求的是-“引用的稳定性”-和-“架构的安全性”。"><a href="#C-等语言追求的是“数据的绝对不可变”（Const-correctness），而-Java-的-final-追求的是-“引用的稳定性”-和-“架构的安全性”。" class="headerlink" title="C++ 等语言追求的是“数据的绝对不可变”（Const-correctness），而 Java 的 final 追求的是 “引用的稳定性” 和 “架构的安全性”。"></a>C++ 等语言追求的是“数据的绝对不可变”（Const-correctness），而 Java 的 <code>final</code> 追求的是 <strong>“引用的稳定性”</strong> 和 <strong>“架构的安全性”</strong>。</h2></blockquote><h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><ul><li><strong>固定配置</strong>：如数据库连接地址、API 的基础 URL。</li><li><strong>数学常数</strong>：如 $\pi$、自然对数 $e$ 等。</li><li><strong>业务逻辑限制</strong>：如订单的最大重试次数、用户的最小注册年龄。</li></ul><blockquote><p><strong>javatomd 总结</strong>：<br>记住一句话：<strong>在 Java 里想定义常量，请把 <code>final</code> 请出来，让 <code>const</code> 继续在角落里吃灰吧！</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo每次一定要“三件套”吗？</title>
    <link href="/2025/12/22/%E6%AF%8F%E6%AC%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E2%80%9C%E4%B8%89%E4%BB%B6%E5%A5%97%E2%80%9D%E5%90%97%EF%BC%9F/"/>
    <url>/2025/12/22/%E6%AF%8F%E6%AC%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E2%80%9C%E4%B8%89%E4%BB%B6%E5%A5%97%E2%80%9D%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>很多新手在开始使用 Hexo 时，习惯性地每次修改都执行 <code>hexo clean</code>, <code>hexo g</code>, <code>hexo s</code>。但在实际开发和写作中，这样做非常浪费时间。以下是根据不同场景推荐的最佳工作流，帮你把时间花在写作上，而不是等待编译。</p><h2 id="1-场景一：日常写文章-修改内容（最常见）"><a href="#1-场景一：日常写文章-修改内容（最常见）" class="headerlink" title="1. 场景一：日常写文章 / 修改内容（最常见）"></a>1. 场景一：日常写文章 / 修改内容（最常见）</h2><p><strong>场景描述</strong>：你在 <code>source/_posts</code> 下新建了一个 <code>.md</code>，或者修改了已有的文章内容、错别字。</p><ul><li><strong>是否需要三连？</strong>：<strong>完全不需要。</strong></li><li><strong>最佳操作</strong>：<ol><li>保持终端里的 <code>hexo s</code> 运行着不要关闭。</li><li>在编辑器里直接修改并保存 <code>.md</code> 文件。</li><li><strong>直接刷新浏览器页面</strong>。</li></ol></li><li><strong>原理</strong>：<code>hexo s</code> 带有“局部监听”功能，它会自动检测 <code>source</code> 文件夹的变化并实时渲染，速度极快。</li></ul><h2 id="2-场景二：修改了配置文件"><a href="#2-场景二：修改了配置文件" class="headerlink" title="2. 场景二：修改了配置文件"></a>2. 场景二：修改了配置文件</h2><p><strong>场景描述</strong>：你修改了根目录的 <code>_config.yml</code> 或主题的 <code>_config.fluid.yml</code>（例如改了网站标题、换了封面图路径）。</p><ul><li><strong>是否需要三连？</strong>：<strong>建议重启并 Clean。</strong></li><li><strong>最佳操作</strong>：<ol><li>在终端按下 <code>Ctrl + C</code> 关闭当前预览服务。</li><li>执行 <code>hexo clean</code>（确保清除旧的配置缓存）。</li><li>执行 <code>hexo s</code> 重新启动。</li></ol></li><li><strong>原理</strong>：配置文件只在服务器启动的一瞬间被读取，热重载通常无法捕捉到这些全局参数的变化。</li></ul><h2 id="3-场景三：删除了文件或移动了文件夹"><a href="#3-场景三：删除了文件或移动了文件夹" class="headerlink" title="3. 场景三：删除了文件或移动了文件夹"></a>3. 场景三：删除了文件或移动了文件夹</h2><p><strong>场景描述</strong>：你删除了某篇旧文章，或者把 <code>source/img</code> 里的图片重命名了。</p><ul><li><strong>是否需要三连？</strong>：<strong>必须执行。</strong></li><li><strong>原因</strong>：如果不执行 <code>clean</code>，<code>public</code>（生成的静态文件夹）里还会残留以前生成的旧文件。这会导致预览时出现已经删掉的文章依然存在，或者图片出现 404 的情况。</li></ul><h2 id="4-场景四：发布到正式环境（如-GitHub-Pages）"><a href="#4-场景四：发布到正式环境（如-GitHub-Pages）" class="headerlink" title="4. 场景四：发布到正式环境（如 GitHub Pages）"></a>4. 场景四：发布到正式环境（如 GitHub Pages）</h2><p><strong>场景描述</strong>：你在本地预览一切完美，准备部署上线。</p><ul><li><strong>最佳操作</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo d  <span class="hljs-comment"># 部署命令</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="⚡-提高效率的小技巧"><a href="#⚡-提高效率的小技巧" class="headerlink" title="⚡ 提高效率的小技巧"></a>⚡ 提高效率的小技巧</h2><h3 id="1-复合命令"><a href="#1-复合命令" class="headerlink" title="1. 复合命令"></a>1. 复合命令</h3><p>你可以用 <code>&amp;&amp;</code> 符号把命令连起来，输入一次回车，电脑会自动按顺序执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改了配置想重启预览</span><br>hexo clean &amp;&amp; hexo s<br><br><span class="hljs-comment"># 准备一键部署</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure></p><h3 id="2-什么时候才必须用-clean？"><a href="#2-什么时候才必须用-clean？" class="headerlink" title="2. 什么时候才必须用 clean？"></a>2. 什么时候才必须用 <code>clean</code>？</h3><ul><li><p>修改了主题的源码（如 CSS 或 JS 文件）。</p></li><li><p>发现网页显示莫名其妙。</p></li><li><p>在准备提交发布（<code>hexo d</code>）之前。</p></li></ul><hr><p><strong>总结</strong>：<strong>写文只需 <code>Ctrl + S</code> + 刷新；改配置才需要 <code>Clean</code> 重启。</strong> </p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>教程</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 主题更换Fluid</title>
    <link href="/2025/12/22/%E6%9B%B4%E6%8D%A2Fluid%E4%B8%BB%E9%A2%98/"/>
    <url>/2025/12/22/%E6%9B%B4%E6%8D%A2Fluid%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天对 Hexo 博客进行了“大整容”，将默认主题更换为了 <strong>Fluid</strong>。过程中由于安装方式和文件路径问题踩了不少坑，现将完整的更换流程与解决方案总结如下。</p><h2 id="1-主题更换流程"><a href="#1-主题更换流程" class="headerlink" title="1 主题更换流程"></a>1 主题更换流程</h2><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">主题官网</a></p><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 安装主题</h3><p>按照官网教程，Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><br>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><h3 id="1-2-配置文件初始化"><a href="#1-2-配置文件初始化" class="headerlink" title="1.2. 配置文件初始化"></a>1.2. 配置文件初始化</h3><p>由于 <code>themes</code> 文件夹为空，需要在博客根目录下手动创建 <strong><code>_config.fluid.yml</code></strong>。<br><strong>关键点</strong>：可以前往 Fluid 官方 GitHub 仓库复制完整的<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">配置模板内容</a>并粘贴进 <strong><code>_config.fluid.yml</code></strong>。</p><h2 id="2-标题修改"><a href="#2-标题修改" class="headerlink" title="2. 标题修改"></a>2. 标题修改</h2><p>标题分为三个层级：浏览器标签页标题、导航栏文字、封面大标题。</p><h3 id="2-1-浏览器标签页标题-Browser-Tab-Title"><a href="#2-1-浏览器标签页标题-Browser-Tab-Title" class="headerlink" title="2.1 浏览器标签页标题 (Browser Tab Title)"></a>2.1 浏览器标签页标题 (Browser Tab Title)</h3><p>这是显示在浏览器最顶端标签上的文字。</p><ul><li><strong>修改文件</strong>：根目录下的 <code>_config.yml</code> (全局配置)。</li><li><strong>操作</strong>：修改 <code>title</code> 字段。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># _config.yml</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">大雪深埋</span>  <span class="hljs-comment"># 这里的修改会直接改变浏览器标签页显示的内容</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="3-首页封面-Banner-修改"><a href="#3-首页封面-Banner-修改" class="headerlink" title="3. 首页封面 (Banner) 修改"></a>3. 首页封面 (Banner) 修改</h2><h3 id="3-1-封面背景图修改-banner-img"><a href="#3-1-封面背景图修改-banner-img" class="headerlink" title="3.1 封面背景图修改 (banner_img)"></a>3.1 封面背景图修改 (banner_img)</h3><p>这是最容易踩坑的地方，涉及路径和存放位置。</p><ul><li><strong>正确存放</strong>：将图片放入 <code>source/img/</code>（例如 <code>guts.png</code>）。</li><li><strong>路径配置</strong>：在 <code>_config.fluid.yml</code> 中搜索 <code>banner_img</code>。</li><li><strong>注意事项</strong>：必须使用<strong>正斜杠 <code>/</code></strong>。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># _config.fluid.yml</span><br><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/guts.png</span>  <span class="hljs-comment"># 路径必须从 /img 开始</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-问题——封面图消失"><a href="#4-问题——封面图消失" class="headerlink" title="4.问题——封面图消失"></a>4.问题——封面图消失</h2><p>在配置 <code>banner_img</code> 封面图时遇到了图片在预览时消失的问题，总结原因如下：</p><ul><li><strong>存放路径错误</strong>：图片不能直接放在 <code>public</code> 文件夹中，因为每次执行 <code>hexo clean</code> 时，该文件夹都会被清空。</li><li><strong>正确位置</strong>：必须将图片存放在 <strong><code>source/img/</code></strong> 文件夹下，由 Hexo 编译后自动同步到 public 目录。</li><li><strong>路径语法限制</strong>：在配置文件中，路径必须使用<strong>正斜杠 <code>/</code></strong>（例如 <code>/img/guts.png</code>），不能使用 Windows 风格的反斜杠 <code>\</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo和GitHub搭建博客全记录</title>
    <link href="/2025/12/21/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/12/21/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>确保你的电脑环境已经安装了以下软件：</p><ul><li><strong>Node.js</strong>: 建议安装 LTS 版本。</li><li><strong>Git</strong>: 用于将代码推送到 GitHub。</li></ul><h2 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h2><p>在终端依次输入以下命令进行初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全局安装脚手架</span><br>npm install -g hexo-cli<br><br><span class="hljs-comment"># 初始化项目文件夹</span><br>hexo init myblog<br><span class="hljs-built_in">cd</span> myblog<br><br><span class="hljs-comment"># 安装依赖</span><br>npm install<br></code></pre></td></tr></table></figure><h2 id="3-联动-GitHub-关键步骤"><a href="#3-联动-GitHub-关键步骤" class="headerlink" title="3. 联动 GitHub (关键步骤)"></a>3. 联动 GitHub (关键步骤)</h2><p>在本地搭建好 Hexo 后，需要通过以下配置将其发布到 GitHub。</p><h3 id="3-1-创建-GitHub-仓库"><a href="#3-1-创建-GitHub-仓库" class="headerlink" title="3.1 创建 GitHub 仓库"></a>3.1 创建 GitHub 仓库</h3><ol><li><p>登录 GitHub，新建一个仓库（New repository）。</p></li><li><p><strong>仓库名（Repository Name）</strong> 必须填：<code>你的用户名.github.io</code>。</p></li><li><p>确保仓库设为 <strong>Public</strong>。</p></li></ol><h3 id="3-2-安装-Git-部署插件"><a href="#3-2-安装-Git-部署插件" class="headerlink" title="3.2 安装 Git 部署插件"></a>3.2 安装 Git 部署插件</h3><p>在你的博客根目录（<code>myblog</code>）下运行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="3-3-修改站点配置文件"><a href="#3-3-修改站点配置文件" class="headerlink" title="3.3 修改站点配置文件"></a>3.3 修改站点配置文件</h3><p>打开目录下的 <code>_config.yml</code> 文件，拉到最底部，修改 <code>deploy</code> 部分：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:你的用户名/你的用户名.github.io.git<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：YAML 格式要求冒号 <code>:</code> 后必须留一个空格。建议使用 SSH 链接以避免频繁输入密码。</p></blockquote><h2 id="4-遇到的坑与解决方法"><a href="#4-遇到的坑与解决方法" class="headerlink" title="4. 遇到的坑与解决方法"></a>4. 遇到的坑与解决方法</h2><h3 id="问题一：无法连接-GitHub"><a href="#问题一：无法连接-GitHub" class="headerlink" title="问题一：无法连接 GitHub"></a>问题一：无法连接 GitHub</h3><p>报错信息：fatal: unable to access … Failed to connect to port 443</p><p>解决方法：</p><p>这是因为网络问题导致无法直接访问 GitHub。如果你有代理服务器（例如端口是 10808），可以设置 Git 全局代理：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-selector-attr">[http://127.0.0.1:10808]</span>(http:<span class="hljs-comment">//127.0.0.1:10808)</span><br>git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-selector-attr">[https://127.0.0.1:10808]</span>(https:<span class="hljs-comment">//127.0.0.1:10808)</span><br></code></pre></td></tr></table></figure><h3 id="问题二：部署后-404-或样式乱码"><a href="#问题二：部署后-404-或样式乱码" class="headerlink" title="问题二：部署后 404 或样式乱码"></a>问题二：部署后 404 或样式乱码</h3><p><strong>原因</strong>：</p><ol><li><p>仓库设为了 Private（私有）。</p></li><li><p>_config.yml 中的 url 配置不正确。</p><p> 解决方法：</p></li><li><p>进入 GitHub 仓库 Settings -&gt; Danger Zone -&gt; Change visibility，改为 <strong>Public</strong>。</p></li><li><p>检查 <code>_config.yml</code> 中的 <code>url</code> 是否填写的为 <code>https://你的用户名.github.io</code>。</p></li></ol><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5. 常用命令"></a>5. 常用命令</h2><p>每次更新博客只需要这三步：</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>命令</strong></td><td><strong>作用</strong></td><td><strong>简写</strong></td></tr><tr><td><code>hexo clean</code></td><td>清除缓存（推荐部署前执行）</td><td>无</td></tr><tr><td><code>hexo generate</code></td><td>生成静态网页文件</td><td><code>hexo g</code></td></tr><tr><td><code>hexo server</code></td><td>启动本地预览（localhost:4000）</td><td><code>hexo s</code></td></tr><tr><td><code>hexo deploy</code></td><td>推送到 GitHub 线上</td><td><code>hexo d</code></td></tr></tbody></table></div><p><strong>标准发布流程：</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
