<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java数组常用API</title>
    <link href="/2025/12/24/Java%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8API/"/>
    <url>/2025/12/24/Java%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h1 id="🚀-Java-进阶：数组常用-API-与经典操作实战"><a href="#🚀-Java-进阶：数组常用-API-与经典操作实战" class="headerlink" title="🚀 Java 进阶：数组常用 API 与经典操作实战"></a>🚀 Java 进阶：数组常用 API 与经典操作实战</h1><blockquote><p><strong>导读</strong>：<br>这一节我们将解锁 Java 数组的“瑞士军刀”——<code>java.util.Arrays</code> 类，它可以让你一行代码搞定排序、查找和打印。<br>同时，我们也会深入底层，手写几个经典的数组算法（如反转、扩容），这是理解数据结构逻辑的关键。</p></blockquote><hr><h2 id="第一部分：Java-数组的“瑞士军刀”-常用-API"><a href="#第一部分：Java-数组的“瑞士军刀”-常用-API" class="headerlink" title="第一部分：Java 数组的“瑞士军刀” (常用 API)"></a>第一部分：Java 数组的“瑞士军刀” (常用 API)</h2><p>Java 官方为了不让我们重复造轮子，提供了一个强大的工具类 <code>java.util.Arrays</code>。使用前请记得 <code>import java.util.Arrays;</code>。</p><h3 id="1-🔍-查看与打印：toString-deepToString"><a href="#1-🔍-查看与打印：toString-deepToString" class="headerlink" title="1. 🔍 查看与打印：toString() &amp; deepToString()"></a>1. 🔍 查看与打印：<code>toString()</code> &amp; <code>deepToString()</code></h3><p>直接打印数组变量只能看到内存地址，必须用这个方法才能看到“真面目”。</p><ul><li><strong>场景</strong>：调试代码，查看数组里的内容。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(Arrays.toString(arr)); <br><span class="hljs-comment">// 输出: [1, 2, 3]</span><br><br><span class="hljs-type">int</span>[][] matrix = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;;<br><span class="hljs-comment">// 注意：多维数组要用 deepToString，否则里面的数组还是显示地址</span><br>System.out.println(Arrays.deepToString(matrix)); <br><span class="hljs-comment">// 输出: [[1, 2], [3, 4]]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-🔢-排序：sort"><a href="#2-🔢-排序：sort" class="headerlink" title="2. 🔢 排序：sort()"></a>2. 🔢 排序：<code>sort()</code></h3><p>将数组元素按照从小到大（升序）排列。底层使用了双轴快速排序等高效算法。</p><ul><li><strong>场景</strong>：排行榜、数据整理。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] scores = &#123;<span class="hljs-number">88</span>, <span class="hljs-number">50</span>, <span class="hljs-number">99</span>, <span class="hljs-number">70</span>&#125;;<br>Arrays.sort(scores);<br>System.out.println(Arrays.toString(scores)); <br><span class="hljs-comment">// 输出: [50, 70, 88, 99] (自动变成有序了)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-🔎-查找：binarySearch-二分查找"><a href="#3-🔎-查找：binarySearch-二分查找" class="headerlink" title="3. 🔎 查找：binarySearch() (二分查找)"></a>3. 🔎 查找：<code>binarySearch()</code> (二分查找)</h3><p>在一个<strong>有序</strong>的数组中快速查找某个元素的位置。</p><ul><li><p><strong>⚠️ 注意</strong>：使用此方法前，<strong>必须先排序</strong>！如果数组是乱序的，结果不可预测。</p></li><li><p><strong>返回值</strong>：如果找到，返回索引；如果找不到，返回负数。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;; <span class="hljs-comment">// 必须是有序的</span><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums, <span class="hljs-number">30</span>);<br>System.out.println(<span class="hljs-string">&quot;30的下标是：&quot;</span> + index); <span class="hljs-comment">// 输出: 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">errorIndex</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums, <span class="hljs-number">25</span>);<br>System.out.println(<span class="hljs-string">&quot;找不存在的数：&quot;</span> + errorIndex); <span class="hljs-comment">// 输出负数 (例如 -3)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-👯-比较：equals"><a href="#4-👯-比较：equals" class="headerlink" title="4. 👯 比较：equals()"></a>4. 👯 比较：<code>equals()</code></h3><p>判断两个数组的<strong>内容</strong>是否完全一致（长度相同，且对应位置元素相同）。</p><ul><li><p><strong>注意</strong>：直接用 <code>==</code> 比较的是两个数组的内存地址，通常都是 <code>false</code>。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] arr2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>System.out.println(arr1 == arr2);       <span class="hljs-comment">// false (它是两个不同的对象)</span><br>System.out.println(Arrays.equals(arr1, arr2)); <span class="hljs-comment">// true (内容一样)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5-🛠-填充：fill"><a href="#5-🛠-填充：fill" class="headerlink" title="5. 🛠 填充：fill()"></a>5. 🛠 填充：<code>fill()</code></h3><p>快速把数组的所有位置（或指定范围）都填成同一个值。</p><ul><li><strong>场景</strong>：初始化游戏地图、重置数据。</li><li><strong>代码示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>Arrays.fill(box, <span class="hljs-number">666</span>); <span class="hljs-comment">// 把整个数组都填满 666</span><br><span class="hljs-comment">// 输出: [666, 666, 666, 666, 666]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6-📋-复制与截取：copyOf-copyOfRange"><a href="#6-📋-复制与截取：copyOf-copyOfRange" class="headerlink" title="6. 📋 复制与截取：copyOf() &amp; copyOfRange()"></a>6. 📋 复制与截取：<code>copyOf()</code> &amp; <code>copyOfRange()</code></h3><ul><li><p><code>copyOf(原数组, 新长度)</code>：从头开始复制，可用于扩容或截断。</p></li><li><p><code>copyOfRange(原数组, start, end)</code>：复制中间某一段（含头不含尾）。</p></li><li><p><strong>代码示例</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><br><span class="hljs-comment">// 复制前3个</span><br><span class="hljs-type">int</span>[] newArr = Arrays.copyOf(src, <span class="hljs-number">3</span>); <br><span class="hljs-comment">// 结果: [10, 20, 30]</span><br><br><span class="hljs-comment">// 扩容复制 (后面补默认值)</span><br><span class="hljs-type">int</span>[] bigArr = Arrays.copyOf(src, <span class="hljs-number">7</span>);<br><span class="hljs-comment">// 结果: [10, 20, 30, 40, 50, 0, 0]</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="⚡-补充：一个高效的底层-API"><a href="#⚡-补充：一个高效的底层-API" class="headerlink" title="⚡ 补充：一个高效的底层 API"></a>⚡ 补充：一个高效的底层 API</h2><p>在阅读 Java 源码时，你会经常看到 <code>System.arraycopy</code>。它是最底层的数组复制方法，性能极高（直接操作内存），但参数比较多，容易写错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法：</span><br><span class="hljs-comment">// System.arraycopy(原数组, 原数组起始位置, 目标数组, 目标数组起始位置, 复制多少个);</span><br><br><span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span>[] dest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">// 把 src 的后两个元素 (3,4) 复制到 dest 的开头</span><br>System.arraycopy(src, <span class="hljs-number">2</span>, dest, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br><br>System.out.println(Arrays.toString(dest)); <br><span class="hljs-comment">// 输出: [3, 4, 0, 0]</span><br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>日常开发</strong>：首选 <code>java.util.Arrays</code> 类，代码简洁，可读性高。</li><li><strong>性能敏感&#x2F;底层开发</strong>：使用 <code>System.arraycopy</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java</tag>
      
      <tag>语法知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java生成随机数</title>
    <link href="/2025/12/24/Java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <url>/2025/12/24/Java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="🎲-Java-核心：生成随机数的-4-种姿势"><a href="#🎲-Java-核心：生成随机数的-4-种姿势" class="headerlink" title="🎲 Java 核心：生成随机数的 4 种姿势"></a>🎲 Java 核心：生成随机数的 4 种姿势</h1><blockquote><p><strong>导读</strong>：<br>并不是所有的随机数都是“真随机”。<br>在 Java 中，你需要根据你的应用场景（是写个小Demo，还是写银行支付系统）来选择不同的随机数生成器。</p></blockquote><hr><h2 id="1-简易入门：Math-random"><a href="#1-简易入门：Math-random" class="headerlink" title="1. 简易入门：Math.random()"></a>1. 简易入门：Math.random()</h2><h3 id="📖-概念定义"><a href="#📖-概念定义" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是 Java 最基础的工具类 <code>Math</code> 提供的一个静态方法。它不需要 <code>new</code> 对象，直接调用即可。</p><h3 id="⚙️-核心规则"><a href="#⚙️-核心规则" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>返回值</strong>：它固定返回一个 <code>0.0</code> (包含) 到 <code>1.0</code> (不包含) 之间的 <code>double</code> 小数。</li><li><strong>底层</strong>：其实它底层也是调用了 <code>java.util.Random</code>，只是做了一层简单的封装。</li></ul><h3 id="💻-代码示例"><a href="#💻-代码示例" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathRandomDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 基础用法：生成 0.0 ~ 1.0 之间的小数</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Math.random();<br>        System.out.println(<span class="hljs-string">&quot;随机小数: &quot;</span> + d);<br><br>        <span class="hljs-comment">// 2. 进阶用法：生成 [0, 100) 之间的整数</span><br>        <span class="hljs-comment">// 逻辑：先把 0.x 放大100倍，再强制转成 int 去掉小数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>);<br>        System.out.println(<span class="hljs-string">&quot;0到99的整数: &quot;</span> + num);<br><br>        <span class="hljs-comment">// 3. 必背公式：生成 [min, max] 之间的整数 (包含两端)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">// 公式：(int)(Math.random() * (最大值 - 最小值 + 1)) + 最小值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rangeNum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * (max - min + <span class="hljs-number">1</span>)) + min;<br>        System.out.println(<span class="hljs-string">&quot;50到100的整数: &quot;</span> + rangeNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景"><a href="#🚀-应用场景" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li>快速测试、简单的脚本。</li><li><strong>缺点</strong>：写区间公式太麻烦，容易算错。</li></ul><hr><h2 id="2-标准通用：java-util-Random"><a href="#2-标准通用：java-util-Random" class="headerlink" title="2. 标准通用：java.util.Random"></a>2. 标准通用：java.util.Random</h2><h3 id="📖-概念定义-1"><a href="#📖-概念定义-1" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是 Java 面向对象标准的随机数生成器。你需要先创建一个“骰子”对象，然后摇它。</p><h3 id="⚙️-核心规则-1"><a href="#⚙️-核心规则-1" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>灵活性</strong>：可以直接生成 <code>int</code>, <code>boolean</code>, <code>float</code> 等多种类型，不需要像 <code>Math.random</code> 那样手动转换。</li><li><strong>种子 (Seed)<strong>：如果你在 new 的时候传入一个固定的数字（种子），那么每次运行生成的随机数序列是</strong>一模一样</strong>的（常用于复现 Bug）。</li></ul><h3 id="💻-代码示例-1"><a href="#💻-代码示例-1" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UtilRandomDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建随机数对象 (不带种子，默认以当前时间为种子)</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>        <span class="hljs-comment">// 2. 生成各种类型的随机数</span><br>        System.out.println(<span class="hljs-string">&quot;随机布尔值: &quot;</span> + r.nextBoolean()); <span class="hljs-comment">// true 或 false</span><br>        System.out.println(<span class="hljs-string">&quot;随机Double: &quot;</span> + r.nextDouble()); <span class="hljs-comment">// 0.0 ~ 1.0</span><br><br>        <span class="hljs-comment">// 3. 最好用的方法：nextInt(bound)</span><br>        <span class="hljs-comment">// 生成 [0, 10) 之间的整数 (不包含10)</span><br>        <span class="hljs-comment">// 也就是 0 ~ 9</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>); <br>        System.out.println(<span class="hljs-string">&quot;0到9的整数: &quot;</span> + i);<br>        <br>        <span class="hljs-comment">// ------------------------------------</span><br>        <span class="hljs-comment">// 特殊情况：带种子的随机 (伪随机的真相)</span><br>        <span class="hljs-comment">// 只要种子一样，生成的随机数顺序永远一样</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">rFixed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">100</span>); <br>        System.out.println(<span class="hljs-string">&quot;固定随机数1: &quot;</span> + rFixed.nextInt(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 每次运行都是同一个数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-1"><a href="#🚀-应用场景-1" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li>大多数业务开发、游戏逻辑、模拟数据。</li></ul><hr><h2 id="3-高性能并发：ThreadLocalRandom-Java-7"><a href="#3-高性能并发：ThreadLocalRandom-Java-7" class="headerlink" title="3. 高性能并发：ThreadLocalRandom (Java 7+)"></a>3. 高性能并发：ThreadLocalRandom (Java 7+)</h2><h3 id="📖-概念定义-2"><a href="#📖-概念定义-2" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>这是为了解决多线程问题而生的工具。</p><h3 id="💡-通俗理解"><a href="#💡-通俗理解" class="headerlink" title="💡 通俗理解"></a>💡 通俗理解</h3><p><code>java.util.Random</code> 是线程安全的，但在多线程高并发时（比如 1000 个人同时去抢一个骰子），会产生<strong>竞争</strong>，导致性能下降。<br><code>ThreadLocalRandom</code> 相当于<strong>给每个线程发了一个专用的骰子</strong>，互不干扰，速度极快。</p><h3 id="💻-代码示例-2"><a href="#💻-代码示例-2" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TLRDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 注意：不能 new，要用 current() 获取当前线程的实例</span><br>        <span class="hljs-type">ThreadLocalRandom</span> <span class="hljs-variable">tlr</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current();<br><br>        <span class="hljs-comment">// 用法和 Random 几乎一样，但性能更高</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> tlr.nextInt(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 直接支持生成 [10, 20) 的范围，超方便！</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;10到19的整数: &quot;</span> + val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-2"><a href="#🚀-应用场景-2" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li><strong>高并发系统</strong>、多线程环境。</li><li>在 JDK 7 之后，<strong>强烈推荐</strong>在多线程能替代 <code>Random</code> 的地方都用这个。</li></ul><hr><h2 id="4-银行级安全：java-security-SecureRandom"><a href="#4-银行级安全：java-security-SecureRandom" class="headerlink" title="4. 银行级安全：java.security.SecureRandom"></a>4. 银行级安全：java.security.SecureRandom</h2><h3 id="📖-概念定义-3"><a href="#📖-概念定义-3" class="headerlink" title="📖 概念定义"></a>📖 概念定义</h3><p>真·随机数生成器。前面的 <code>Random</code> 实际上是根据算法算出来的（伪随机），如果黑客知道了算法和种子，就能预测下一个数。<br><code>SecureRandom</code> 利用操作系统的随机源（如鼠标移动、键盘敲击、CPU热噪声等）来生成随机数。</p><h3 id="⚙️-核心规则-2"><a href="#⚙️-核心规则-2" class="headerlink" title="⚙️ 核心规则"></a>⚙️ 核心规则</h3><ul><li><strong>不可预测性</strong>：极其难以被破解。</li><li><strong>性能</strong>：比普通的 Random 慢很多（因为生成过程很复杂）。</li></ul><h3 id="💻-代码示例-3"><a href="#💻-代码示例-3" class="headerlink" title="💻 代码示例"></a>💻 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">sr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>        <br>        <span class="hljs-comment">// 用法和 Random 一样</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">passwordPart</span> <span class="hljs-operator">=</span> sr.nextInt(<span class="hljs-number">10000</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;安全随机数: &quot;</span> + passwordPart);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀-应用场景-3"><a href="#🚀-应用场景-3" class="headerlink" title="🚀 应用场景"></a>🚀 应用场景</h3><ul><li><strong>生成密码、Token、Session ID、加密密钥</strong>。</li><li>凡是涉及到<strong>钱</strong>和<strong>安全</strong>的地方，严禁使用 <code>Math.random</code> 或 <code>Random</code>，必须用 <code>SecureRandom</code>。</li></ul><hr><h2 id="📝-总结：我该用哪个？"><a href="#📝-总结：我该用哪个？" class="headerlink" title="📝 总结：我该用哪个？"></a>📝 总结：我该用哪个？</h2><table><thead><tr><th align="left">场景</th><th align="left">推荐方式</th><th align="left">理由</th></tr></thead><tbody><tr><td align="left"><strong>写个小Demo &#x2F; 教学</strong></td><td align="left"><code>Math.random()</code></td><td align="left">代码最短，不用导包。</td></tr><tr><td align="left"><strong>一般业务 &#x2F; 单线程</strong></td><td align="left"><code>java.util.Random</code></td><td align="left">API 丰富，符合直觉。</td></tr><tr><td align="left"><strong>高并发 &#x2F; 多线程</strong></td><td align="left"><code>ThreadLocalRandom</code></td><td align="left"><strong>性能王者</strong>，不堵车。</td></tr><tr><td align="left"><strong>生成密码 &#x2F; 涉及钱</strong></td><td align="left"><code>SecureRandom</code></td><td align="left"><strong>安全王者</strong>，黑客猜不到。</td></tr></tbody></table><h3 id="💡-讲师提示"><a href="#💡-讲师提示" class="headerlink" title="💡 讲师提示"></a>💡 讲师提示</h3><p>作为新手，你现阶段主要掌握 <strong><code>java.util.Random</code></strong> 就足够应对 90% 的学习场景了。但记住，等到以后做Web项目生成验证码时，一定要想起来用 <code>SecureRandom</code> 哦！</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Java</tag>
      
      <tag>语法知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java为什么不用const</title>
    <link href="/2025/12/23/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8const/"/>
    <url>/2025/12/23/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8const/</url>
    
    <content type="html"><![CDATA[<p>在学习 Java 时，很多从 C++ 或 C# 转过来的小伙伴都会下意识地去找 <code>const</code>。但在 Java 中，情况有点特殊。</p><hr><h2 id="1-const：有名无实的“保留字”"><a href="#1-const：有名无实的“保留字”" class="headerlink" title="1. const：有名无实的“保留字”"></a>1. <code>const</code>：有名无实的“保留字”</h2><p><strong>概念定义</strong>：在 Java 中，<code>const</code> 被称为<strong>保留字（Reserved Word）</strong>，而不是<strong>关键字（Keyword）</strong>。</p><ul><li><strong>现状</strong>：它在 Java 源码中存在，但没有任何语法功能。</li><li><strong>规则</strong>：你不能用 <code>const</code> 来定义常量，同时你也<strong>不能</strong>用 <code>const</code> 作为你的变量名。</li><li><strong>为什么保留它？</strong>：主要是为了防止程序员在写 Java 时误用了 C++ 的习惯，或者为了将来可能的版本升级预留位置。</li></ul><hr><h2 id="2-真正的常量主角：final"><a href="#2-真正的常量主角：final" class="headerlink" title="2. 真正的常量主角：final"></a>2. 真正的常量主角：<code>final</code></h2><p><strong>概念定义</strong>：在 Java 中，如果你想定义一个“一旦赋值就不能改变”的量，必须使用关键字 **<code>final</code>**。</p><h3 id="核心规则："><a href="#核心规则：" class="headerlink" title="核心规则："></a>核心规则：</h3><ol><li><strong>不可变性</strong>：被 <code>final</code> 修饰的变量，只能被赋值一次，之后再尝试修改会直接报错。</li><li><strong>命名规范</strong>：Java 中的常量通常要求<strong>全部大写</strong>，多个单词之间用下划线 <code>_</code> 分隔（例如：<code>MAX_SPEED</code>）。</li><li><strong>修饰位置</strong>：<code>final</code> 既可以修饰局部变量，也可以修饰类成员变量。</li></ol><hr><h2 id="3-代码示例：如何正确定义常量"><a href="#3-代码示例：如何正确定义常量" class="headerlink" title="3. 代码示例：如何正确定义常量"></a>3. 代码示例：如何正确定义常量</h2><p>在实际开发中，我们通常结合 <code>static</code> 和 <code>final</code> 来定义一个全局常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstantDemo</span> &#123;<br>    <span class="hljs-comment">// 1. 类级别的全局常量（最常见用法）</span><br>    <span class="hljs-comment">// static 让它属于类，final 保证它不可变</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926535</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_LOGIN_ATTEMPTS</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 2. 局部常量</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <br>        <span class="hljs-comment">// age = 21; // ❌ 编译报错：无法为最终变量 age 分配值</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;圆周率是：&quot;</span> + PI);<br>        System.out.println(<span class="hljs-string">&quot;我的年龄是：&quot;</span> + age);<br>        <br>        <span class="hljs-comment">// 3. 错误示范（如果你非要用 const）</span><br>        <span class="hljs-comment">// int const = 10; // ❌ 编译报错：const 是保留字，不能用作标识符</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-final-与-const-的对比-Java-vs-其他语言"><a href="#4-final-与-const-的对比-Java-vs-其他语言" class="headerlink" title="4. final 与 const 的对比 (Java vs 其他语言)"></a>4. <code>final</code> 与 <code>const</code> 的对比 (Java vs 其他语言)</h2><table><thead><tr><th align="left">特性</th><th align="left">Java 的 <code>final</code></th><th align="left">C++&#x2F;C# 的 <code>const</code></th></tr></thead><tbody><tr><td align="left"><strong>定义常量</strong></td><td align="left">✅ 完美支持</td><td align="left">✅ 完美支持</td></tr><tr><td align="left"><strong>运行期赋值</strong></td><td align="left">✅ 支持（可以在运行时计算值再锁定）</td><td align="left">❌ 通常要求编译期确定值</td></tr><tr><td align="left"><strong>修饰类&#x2F;方法</strong></td><td align="left">✅ 可以（防止类被继承或方法被重写）</td><td align="left">❌ 通常只修饰变量</td></tr></tbody></table><h1 id="进阶笔记：Java-final-vs-C-C-const-的三大本质区别"><a href="#进阶笔记：Java-final-vs-C-C-const-的三大本质区别" class="headerlink" title="进阶笔记：Java final vs C++&#x2F;C# const 的三大本质区别"></a>进阶笔记：Java <code>final</code> vs C++&#x2F;C# <code>const</code> 的三大本质区别</h1><p>很多编程语言都有 <code>const</code>，但在 Java 中，<code>final</code> 承担了更多的职责。你提到的“运行期赋值”和“修饰类&#x2F;方法”正是它的灵魂所在。</p><hr><h3 id="4-1-运行期赋值：不仅仅是“死板”的常量"><a href="#4-1-运行期赋值：不仅仅是“死板”的常量" class="headerlink" title="4.1. 运行期赋值：不仅仅是“死板”的常量"></a>4.1. 运行期赋值：不仅仅是“死板”的常量</h3><p>在 C# 等语言中，<code>const</code> 要求在<strong>编译时</strong>就确定值（比如 <code>3.14</code>）。但 Java 的 <code>final</code> 允许你在<strong>运行时</strong>再决定它的值，一旦定下来，就不再更改。</p><p><strong>比喻</strong>：<code>const</code> 是“出厂即刻字”，而 <code>final</code> 是“发货前才填写的终身快递单”。</p><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalRuntimeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 运行期赋值：每次运行，value 的值可能都不一样</span><br>        <span class="hljs-comment">// 但在同一个生命周期内，value 一旦被赋值就不能再改</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;本次运行确定的常量值：&quot;</span> + value);<br>        <br>        <span class="hljs-comment">// value = 200; // ❌ 依然会报错，因为它已经是 final 了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong>：比如根据用户的输入、数据库的查询结果、或者是当前系统的年份来初始化一个“只读变量”。</p><hr><h3 id="2-架构防线：修饰类与方法"><a href="#2-架构防线：修饰类与方法" class="headerlink" title="2. 架构防线：修饰类与方法"></a>2. 架构防线：修饰类与方法</h3><p>这是 <code>const</code> 完全无法触及的领域。在 Java 中，<code>final</code> 被用来保护代码的<strong>继承结构</strong>。</p><h4 id="A-修饰方法-Prevent-Overriding"><a href="#A-修饰方法-Prevent-Overriding" class="headerlink" title="A. 修饰方法 (Prevent Overriding)"></a>A. 修饰方法 (Prevent Overriding)</h4><p><strong>规则</strong>：父类的方法被 <code>final</code> 修饰后，子类<strong>不能重写</strong>它。<br><strong>意义</strong>：锁定核心逻辑，防止子类“乱改”导致逻辑崩溃。</p><h4 id="B-修饰类-Prevent-Inheritance"><a href="#B-修饰类-Prevent-Inheritance" class="headerlink" title="B. 修饰类 (Prevent Inheritance)"></a>B. 修饰类 (Prevent Inheritance)</h4><p><strong>规则</strong>：类被 <code>final</code> 修饰后，<strong>不能被继承</strong>。<br><strong>意义</strong>：比如 <code>String</code> 类就是 <code>final</code> 的。如果人人都能继承并修改 <code>String</code> 的行为，整个 Java 世界就乱套了。</p><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是一个 final 类，不能有“儿子”</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecuritySystem</span> &#123;<br>    <br>    <span class="hljs-comment">// 这是一个 final 方法，子类即便能继承（如果类不是 final），也不能修改</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verifyIdentity</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行极其严格的身份核验逻辑，禁止修改！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class HackSystem extends SecuritySystem &#123; &#125; // ❌ 报错：无法从最终类继承</span><br></code></pre></td></tr></table></figure><hr><h3 id="3-深度对比表：为什么-final-比-const-更强大？"><a href="#3-深度对比表：为什么-final-比-const-更强大？" class="headerlink" title="3. 深度对比表：为什么 final 比 const 更强大？"></a>3. 深度对比表：为什么 <code>final</code> 比 <code>const</code> 更强大？</h3><table><thead><tr><th align="left">特性</th><th align="left">Java <code>final</code></th><th align="left">典型 <code>const</code> (如 C#)</th></tr></thead><tbody><tr><td align="left"><strong>赋值时机</strong></td><td align="left"><strong>编译期 或 运行期</strong></td><td align="left">通常只能是 <strong>编译期</strong></td></tr><tr><td align="left"><strong>修饰变量</strong></td><td align="left">✅ 锁定引用&#x2F;值</td><td align="left">✅ 锁定值</td></tr><tr><td align="left"><strong>修饰类</strong></td><td align="left">✅ 禁止继承</td><td align="left">❌ 不支持 (C# 用 <code>sealed</code>)</td></tr><tr><td align="left"><strong>修饰方法</strong></td><td align="left">✅ 禁止重写</td><td align="left">❌ 不支持</td></tr><tr><td align="left"><strong>对象控制</strong></td><td align="left">只能锁定“盒子”不换，不能锁“内容”</td><td align="left">深度锁定（C++ 的 const 语义更强）</td></tr></tbody></table><hr><h3 id="4-重点避坑：引用不变-vs-内容不变"><a href="#4-重点避坑：引用不变-vs-内容不变" class="headerlink" title="4. 重点避坑：引用不变 vs 内容不变"></a>4. 重点避坑：引用不变 vs 内容不变</h3><p>这是新手最容易掉坑的地方：**<code>final</code> 修饰对象时，只是锁定了“地址”，没锁定“属性”。**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>user.setName(<span class="hljs-string">&quot;Jerry&quot;</span>); <span class="hljs-comment">// ✅ 允许！内容可以变</span><br><span class="hljs-comment">// user = new User(&quot;Jack&quot;); // ❌ 报错！不能把 user 指向新对象</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>javatomd 总结</strong>：<br>C++ 等语言追求的是“数据的绝对不可变”（Const-correctness），而 Java 的 <code>final</code> 追求的是 <strong>“引用的稳定性”</strong> 和 <strong>“架构的安全性”</strong>。</p></blockquote><hr><h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><ul><li><strong>固定配置</strong>：如数据库连接地址、API 的基础 URL。</li><li><strong>数学常数</strong>：如 $\pi$、自然对数 $e$ 等。</li><li><strong>业务逻辑限制</strong>：如订单的最大重试次数、用户的最小注册年龄。</li></ul><blockquote><p><strong>javatomd 总结</strong>：<br>记住一句话：<strong>在 Java 里想定义常量，请把 <code>final</code> 请出来，让 <code>const</code> 继续在角落里吃灰吧！</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo每次一定要“三件套”吗？</title>
    <link href="/2025/12/22/%E6%AF%8F%E6%AC%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E2%80%9C%E4%B8%89%E4%BB%B6%E5%A5%97%E2%80%9D%E5%90%97%EF%BC%9F/"/>
    <url>/2025/12/22/%E6%AF%8F%E6%AC%A1%E4%B8%80%E5%AE%9A%E8%A6%81%E2%80%9C%E4%B8%89%E4%BB%B6%E5%A5%97%E2%80%9D%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>很多新手在开始使用 Hexo 时，习惯性地每次修改都执行 <code>hexo clean</code>, <code>hexo g</code>, <code>hexo s</code>。但在实际开发和写作中，这样做非常浪费时间。以下是根据不同场景推荐的最佳工作流，帮你把时间花在写作上，而不是等待编译。</p><h2 id="1-场景一：日常写文章-修改内容（最常见）"><a href="#1-场景一：日常写文章-修改内容（最常见）" class="headerlink" title="1. 场景一：日常写文章 &#x2F; 修改内容（最常见）"></a>1. 场景一：日常写文章 &#x2F; 修改内容（最常见）</h2><p><strong>场景描述</strong>：你在 <code>source/_posts</code> 下新建了一个 <code>.md</code>，或者修改了已有的文章内容、错别字。</p><ul><li><strong>是否需要三连？</strong>：<strong>完全不需要。</strong></li><li><strong>最佳操作</strong>：<ol><li>保持终端里的 <code>hexo s</code> 运行着不要关闭。</li><li>在编辑器里直接修改并保存 <code>.md</code> 文件。</li><li><strong>直接刷新浏览器页面</strong>。</li></ol></li><li><strong>原理</strong>：<code>hexo s</code> 带有“局部监听”功能，它会自动检测 <code>source</code> 文件夹的变化并实时渲染，速度极快。</li></ul><h2 id="2-场景二：修改了配置文件"><a href="#2-场景二：修改了配置文件" class="headerlink" title="2. 场景二：修改了配置文件"></a>2. 场景二：修改了配置文件</h2><p><strong>场景描述</strong>：你修改了根目录的 <code>_config.yml</code> 或主题的 <code>_config.fluid.yml</code>（例如改了网站标题、换了封面图路径）。</p><ul><li><strong>是否需要三连？</strong>：<strong>建议重启并 Clean。</strong></li><li><strong>最佳操作</strong>：<ol><li>在终端按下 <code>Ctrl + C</code> 关闭当前预览服务。</li><li>执行 <code>hexo clean</code>（确保清除旧的配置缓存）。</li><li>执行 <code>hexo s</code> 重新启动。</li></ol></li><li><strong>原理</strong>：配置文件只在服务器启动的一瞬间被读取，热重载通常无法捕捉到这些全局参数的变化。</li></ul><h2 id="3-场景三：删除了文件或移动了文件夹"><a href="#3-场景三：删除了文件或移动了文件夹" class="headerlink" title="3. 场景三：删除了文件或移动了文件夹"></a>3. 场景三：删除了文件或移动了文件夹</h2><p><strong>场景描述</strong>：你删除了某篇旧文章，或者把 <code>source/img</code> 里的图片重命名了。</p><ul><li><strong>是否需要三连？</strong>：<strong>必须执行。</strong></li><li><strong>原因</strong>：如果不执行 <code>clean</code>，<code>public</code>（生成的静态文件夹）里还会残留以前生成的旧文件。这会导致预览时出现已经删掉的文章依然存在，或者图片出现 404 的情况。</li></ul><h2 id="4-场景四：发布到正式环境（如-GitHub-Pages）"><a href="#4-场景四：发布到正式环境（如-GitHub-Pages）" class="headerlink" title="4. 场景四：发布到正式环境（如 GitHub Pages）"></a>4. 场景四：发布到正式环境（如 GitHub Pages）</h2><p><strong>场景描述</strong>：你在本地预览一切完美，准备部署上线。</p><ul><li><strong>最佳操作</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo d  <span class="hljs-comment"># 部署命令</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="⚡-提高效率的小技巧"><a href="#⚡-提高效率的小技巧" class="headerlink" title="⚡ 提高效率的小技巧"></a>⚡ 提高效率的小技巧</h2><h3 id="1-复合命令"><a href="#1-复合命令" class="headerlink" title="1. 复合命令"></a>1. 复合命令</h3><p>你可以用 <code>&amp;&amp;</code> 符号把命令连起来，输入一次回车，电脑会自动按顺序执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改了配置想重启预览</span><br>hexo clean &amp;&amp; hexo s<br><br><span class="hljs-comment"># 准备一键部署</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><h3 id="2-什么时候才必须用-clean？"><a href="#2-什么时候才必须用-clean？" class="headerlink" title="2. 什么时候才必须用 clean？"></a>2. 什么时候才必须用 <code>clean</code>？</h3><ul><li><p>修改了主题的源码（如 CSS 或 JS 文件）。</p></li><li><p>发现网页显示莫名其妙。</p></li><li><p>在准备提交发布（<code>hexo d</code>）之前。</p></li></ul><hr><p><strong>总结</strong>：<strong>写文只需 <code>Ctrl + S</code> + 刷新；改配置才需要 <code>Clean</code> 重启。</strong> </p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>教程</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 主题更换Fluid</title>
    <link href="/2025/12/22/%E6%9B%B4%E6%8D%A2Fluid%E4%B8%BB%E9%A2%98/"/>
    <url>/2025/12/22/%E6%9B%B4%E6%8D%A2Fluid%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天对 Hexo 博客进行了“大整容”，将默认主题更换为了 <strong>Fluid</strong>。过程中由于安装方式和文件路径问题踩了不少坑，现将完整的更换流程与解决方案总结如下。</p><h2 id="1-主题更换流程"><a href="#1-主题更换流程" class="headerlink" title="1 主题更换流程"></a>1 主题更换流程</h2><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">主题官网</a></p><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 安装主题</h3><p>按照官网教程，Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><h3 id="1-2-配置文件初始化"><a href="#1-2-配置文件初始化" class="headerlink" title="1.2. 配置文件初始化"></a>1.2. 配置文件初始化</h3><p>由于 <code>themes</code> 文件夹为空，需要在博客根目录下手动创建 **<code>_config.fluid.yml</code>**。<br><strong>关键点</strong>：可以前往 Fluid 官方 GitHub 仓库复制完整的<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">配置模板内容</a>并粘贴进 **<code>_config.fluid.yml</code>**。</p><h2 id="2-标题修改"><a href="#2-标题修改" class="headerlink" title="2. 标题修改"></a>2. 标题修改</h2><p>标题分为三个层级：浏览器标签页标题、导航栏文字、封面大标题。</p><h3 id="2-1-浏览器标签页标题-Browser-Tab-Title"><a href="#2-1-浏览器标签页标题-Browser-Tab-Title" class="headerlink" title="2.1 浏览器标签页标题 (Browser Tab Title)"></a>2.1 浏览器标签页标题 (Browser Tab Title)</h3><p>这是显示在浏览器最顶端标签上的文字。</p><ul><li><strong>修改文件</strong>：根目录下的 <code>_config.yml</code> (全局配置)。</li><li><strong>操作</strong>：修改 <code>title</code> 字段。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># _config.yml</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">大雪深埋</span>  <span class="hljs-comment"># 这里的修改会直接改变浏览器标签页显示的内容</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="3-首页封面-Banner-修改"><a href="#3-首页封面-Banner-修改" class="headerlink" title="3. 首页封面 (Banner) 修改"></a>3. 首页封面 (Banner) 修改</h2><h3 id="3-1-封面背景图修改-banner-img"><a href="#3-1-封面背景图修改-banner-img" class="headerlink" title="3.1 封面背景图修改 (banner_img)"></a>3.1 封面背景图修改 (banner_img)</h3><p>这是最容易踩坑的地方，涉及路径和存放位置。</p><ul><li><strong>正确存放</strong>：将图片放入 <code>source/img/</code>（例如 <code>guts.png</code>）。</li><li><strong>路径配置</strong>：在 <code>_config.fluid.yml</code> 中搜索 <code>banner_img</code>。</li><li><strong>注意事项</strong>：必须使用**正斜杠 <code>/</code>**。  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># _config.fluid.yml</span><br><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/guts.png</span>  <span class="hljs-comment"># 路径必须从 /img 开始</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-问题——封面图消失"><a href="#4-问题——封面图消失" class="headerlink" title="4.问题——封面图消失"></a>4.问题——封面图消失</h2><p>在配置 <code>banner_img</code> 封面图时遇到了图片在预览时消失的问题，总结原因如下：</p><ul><li><strong>存放路径错误</strong>：图片不能直接放在 <code>public</code> 文件夹中，因为每次执行 <code>hexo clean</code> 时，该文件夹都会被清空。</li><li><strong>正确位置</strong>：必须将图片存放在 <strong><code>source/img/</code></strong> 文件夹下，由 Hexo 编译后自动同步到 public 目录。</li><li><strong>路径语法限制</strong>：在配置文件中，路径必须使用**正斜杠 <code>/</code>**（例如 <code>/img/guts.png</code>），不能使用 Windows 风格的反斜杠 <code>\</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo和GitHub搭建博客全记录</title>
    <link href="/2025/12/21/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/12/21/Hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>确保你的电脑环境已经安装了以下软件：</p><ul><li><strong>Node.js</strong>: 建议安装 LTS 版本。</li><li><strong>Git</strong>: 用于将代码推送到 GitHub。</li></ul><h2 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h2><p>在终端依次输入以下命令进行初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全局安装脚手架</span><br>npm install -g hexo-cli<br><br><span class="hljs-comment"># 初始化项目文件夹</span><br>hexo init myblog<br><span class="hljs-built_in">cd</span> myblog<br><br><span class="hljs-comment"># 安装依赖</span><br>npm install<br></code></pre></td></tr></table></figure><h2 id="3-联动-GitHub-关键步骤"><a href="#3-联动-GitHub-关键步骤" class="headerlink" title="3. 联动 GitHub (关键步骤)"></a>3. 联动 GitHub (关键步骤)</h2><p>在本地搭建好 Hexo 后，需要通过以下配置将其发布到 GitHub。</p><h3 id="3-1-创建-GitHub-仓库"><a href="#3-1-创建-GitHub-仓库" class="headerlink" title="3.1 创建 GitHub 仓库"></a>3.1 创建 GitHub 仓库</h3><ol><li><p>登录 GitHub，新建一个仓库（New repository）。</p></li><li><p><strong>仓库名（Repository Name）</strong> 必须填：<code>你的用户名.github.io</code>。</p></li><li><p>确保仓库设为 <strong>Public</strong>。</p></li></ol><h3 id="3-2-安装-Git-部署插件"><a href="#3-2-安装-Git-部署插件" class="headerlink" title="3.2 安装 Git 部署插件"></a>3.2 安装 Git 部署插件</h3><p>在你的博客根目录（<code>myblog</code>）下运行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="3-3-修改站点配置文件"><a href="#3-3-修改站点配置文件" class="headerlink" title="3.3 修改站点配置文件"></a>3.3 修改站点配置文件</h3><p>打开目录下的 <code>_config.yml</code> 文件，拉到最底部，修改 <code>deploy</code> 部分：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:你的用户名/你的用户名.github.io.git<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：YAML 格式要求冒号 <code>:</code> 后必须留一个空格。建议使用 SSH 链接以避免频繁输入密码。</p></blockquote><h2 id="4-遇到的坑与解决方法"><a href="#4-遇到的坑与解决方法" class="headerlink" title="4. 遇到的坑与解决方法"></a>4. 遇到的坑与解决方法</h2><h3 id="问题一：无法连接-GitHub"><a href="#问题一：无法连接-GitHub" class="headerlink" title="问题一：无法连接 GitHub"></a>问题一：无法连接 GitHub</h3><p>报错信息：fatal: unable to access … Failed to connect to port 443</p><p>解决方法：</p><p>这是因为网络问题导致无法直接访问 GitHub。如果你有代理服务器（例如端口是 10808），可以设置 Git 全局代理：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-selector-attr">[http://127.0.0.1:10808]</span>(http:<span class="hljs-comment">//127.0.0.1:10808)</span><br>git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> <span class="hljs-selector-attr">[https://127.0.0.1:10808]</span>(https:<span class="hljs-comment">//127.0.0.1:10808)</span><br></code></pre></td></tr></table></figure><h3 id="问题二：部署后-404-或样式乱码"><a href="#问题二：部署后-404-或样式乱码" class="headerlink" title="问题二：部署后 404 或样式乱码"></a>问题二：部署后 404 或样式乱码</h3><p><strong>原因</strong>：</p><ol><li><p>仓库设为了 Private（私有）。</p></li><li><p>_config.yml 中的 url 配置不正确。</p><p> 解决方法：</p></li><li><p>进入 GitHub 仓库 Settings -&gt; Danger Zone -&gt; Change visibility，改为 <strong>Public</strong>。</p></li><li><p>检查 <code>_config.yml</code> 中的 <code>url</code> 是否填写的为 <code>https://你的用户名.github.io</code>。</p></li></ol><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5. 常用命令"></a>5. 常用命令</h2><p>每次更新博客只需要这三步：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>命令</strong></td><td><strong>作用</strong></td><td><strong>简写</strong></td></tr><tr><td><code>hexo clean</code></td><td>清除缓存（推荐部署前执行）</td><td>无</td></tr><tr><td><code>hexo generate</code></td><td>生成静态网页文件</td><td><code>hexo g</code></td></tr><tr><td><code>hexo server</code></td><td>启动本地预览（localhost:4000）</td><td><code>hexo s</code></td></tr><tr><td><code>hexo deploy</code></td><td>推送到 GitHub 线上</td><td><code>hexo d</code></td></tr></tbody></table><p><strong>标准发布流程：</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
