

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/biaoqian.jpg">
  <link rel="icon" href="/img/biaoqian.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jay">
  <meta name="keywords" content="">
  
    <meta name="description" content="第 0 讲人工智能 (Artificial Intelligence)人工智能 (AI) 涵盖了一系列让计算机表现出类似拥有“感知”行为的技术。例如，AI 被用于识别社交媒体照片中的人脸、在国际象棋中击败世界冠军，以及在你与手机上的 Siri 或 Alexa 对话时处理你的语音。 在本课程中，我们将探讨使 AI 成为可能的一些核心思想：  搜索 (Search) 寻找问题的解决方案，例如导航应用程">
<meta property="og:type" content="article">
<meta property="og:title" content="CS50AI note1">
<meta property="og:url" content="https://zjjyyds.github.io/2025/12/26/CS50%20AI%20note1/index.html">
<meta property="og:site_name" content="大雪深埋">
<meta property="og:description" content="第 0 讲人工智能 (Artificial Intelligence)人工智能 (AI) 涵盖了一系列让计算机表现出类似拥有“感知”行为的技术。例如，AI 被用于识别社交媒体照片中的人脸、在国际象棋中击败世界冠军，以及在你与手机上的 Siri 或 Alexa 对话时处理你的语音。 在本课程中，我们将探讨使 AI 成为可能的一些核心思想：  搜索 (Search) 寻找问题的解决方案，例如导航应用程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cs50.harvard.edu/ai/notes/0/15puzzle.png">
<meta property="og:image" content="https://cs50.harvard.edu/ai/notes/0/statespace.png">
<meta property="og:image" content="https://cs50.harvard.edu/ai/notes/0/manhattandistance.png">
<meta property="og:image" content="https://cs50.harvard.edu/ai/notes/0/minimax_tictactoe.png">
<meta property="og:image" content="https://cs50.harvard.edu/ai/notes/0/minimax_theoretical.png">
<meta property="og:image" content="https://cs50.harvard.edu/ai/notes/0/alphabeta.png">
<meta property="article:published_time" content="2025-12-26T14:16:00.000Z">
<meta property="article:modified_time" content="2025-12-26T14:52:04.825Z">
<meta property="article:author" content="Jay">
<meta property="article:tag" content="CS50 AI">
<meta property="article:tag" content="讲义">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cs50.harvard.edu/ai/notes/0/15puzzle.png">
  
  
  
  <title>CS50AI note1 - 大雪深埋</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zjjyyds.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>大雪深埋</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/guts.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CS50AI note1"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-12-26 22:16" pubdate>
          2025年12月26日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          51 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CS50AI note1</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="第-0-讲"><a href="#第-0-讲" class="headerlink" title="第 0 讲"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#lecture-0">第 0 讲</a></h2><h2 id="人工智能-Artificial-Intelligence"><a href="#人工智能-Artificial-Intelligence" class="headerlink" title="人工智能 (Artificial Intelligence)"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#artificial-intelligence">人工智能 (Artificial Intelligence)</a></h2><p>人工智能 (AI) 涵盖了一系列让计算机表现出类似拥有“感知”行为的技术。例如，AI 被用于识别社交媒体照片中的人脸、在国际象棋中击败世界冠军，以及在你与手机上的 Siri 或 Alexa 对话时处理你的语音。</p>
<p>在本课程中，我们将探讨使 AI 成为可能的一些核心思想：</p>
<ol start="0">
<li><p><strong>搜索 (Search)</strong></p>
<p>寻找问题的解决方案，例如导航应用程序寻找从起点到终点的最佳路线，或者在玩游戏时计算下一步该怎么走。</p>
</li>
<li><p><strong>知识 (Knowledge)</strong></p>
<p>表示信息并从中进行推理。</p>
</li>
<li><p><strong>不确定性 (Uncertainty)</strong></p>
<p>利用概率论处理不确定事件。</p>
</li>
<li><p><strong>优化 (Optimization)</strong></p>
<p>不仅要找到解决问题的正确方法，还要找到更好——甚至最好——的解决方法。</p>
</li>
<li><p><strong>学习 (Learning)</strong></p>
<p>通过访问数据和经验来提高性能。例如，你的电子邮件系统能够根据过去的经验区分垃圾邮件和非垃圾邮件。</p>
</li>
<li><p><strong>神经网络 (Neural Networks)</strong></p>
<p>一种受人脑启发的程序结构，能够有效地执行任务。</p>
</li>
<li><p><strong>语言 (Language)</strong></p>
<p>处理自然语言，即人类产生和理解的语言。</p>
</li>
</ol>
<blockquote>
<p>**🔍 [译者注释]**：这门课程的结构非常经典，不仅仅关注现在流行的“深度学习”，而是涵盖了 AI 的基础逻辑（如符号主义、概率推理等）。“搜索”是 AI 的基石，本质上是在无数种可能中找到达成目标的路径。</p>
</blockquote>
<h2 id="搜索-Search"><a href="#搜索-Search" class="headerlink" title="搜索 (Search)"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#search">搜索 (Search)</a></h2><p>搜索问题涉及一个<strong>智能体 (Agent)<strong>，它被赋予一个</strong>初始状态</strong>和一个<strong>目标状态</strong>，它的任务是返回如何从前者到达后者的解决方案。导航应用就是典型的搜索过程，智能体（程序的思考部分）接收你当前的位置和想要去的目的地作为输入，并基于搜索算法返回建议的路径。当然，还有许多其他形式的搜索问题，如拼图或迷宫。</p>
<p><img src="https://cs50.harvard.edu/ai/notes/0/15puzzle.png" srcset="/img/loading.gif" lazyload alt="15 puzzle"></p>
<p>找到 15 数字推盘游戏的解法需要使用搜索算法。</p>
<ul>
<li><p><strong>智能体 (Agent)</strong></p>
<p>一个能够感知环境并对环境采取行动的实体。例如在导航应用中，智能体代表一辆需要决定采取哪些行动才能到达目的地的汽车。</p>
</li>
<li><p><strong>状态 (State)</strong></p>
<p>智能体在其环境中的一种配置。例如，在 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/15_puzzle">15 数字推盘</a>中，一个状态就是板上数字排列的任意一种方式。</p>
<ul>
<li><strong>初始状态 (Initial State)</strong><br>搜索算法开始的状态。在导航应用中，就是当前位置。</li>
</ul>
</li>
<li><p><strong>动作 (Actions)</strong></p>
<p>在一个状态下可以做出的选择。更准确地说，动作可以定义为一个函数。接收状态 <code>s</code> 作为输入，<code>Actions(s)</code> 返回在状态 <code>s</code> 下可执行的动作集合作为输出。例如，在 <em>15 数字推盘</em>中，给定状态的动作就是你滑动方块的方式（如果空位在中间则有 4 种，如果在边上则有 3 种，在角落则有 2 种）。</p>
</li>
<li><p><strong>转移模型 (Transition Model)</strong></p>
<p>描述在任何状态下执行任何适用动作后会产生什么状态。更准确地说，转移模型可以定义为一个函数。接收状态 <code>s</code> 和动作 <code>a</code> 作为输入，<code>Results(s, a)</code> 返回在状态 <code>s</code> 下执行动作 <code>a</code> 后产生的新状态。例如，给定 <em>15 数字推盘</em>的某种配置（状态 <code>s</code>），向任何方向移动一个方块（动作 <code>a</code>）都会带来拼图的新配置（新状态）。</p>
</li>
<li><p><strong>状态空间 (State Space)</strong></p>
<p>从初始状态通过任意动作序列可到达的所有状态的集合。例如，在 15 数字推盘中，状态空间由所有从初始状态可到达的 16!&#x2F;2 种棋盘配置组成。状态空间可以可视化为一个有向图，状态表示为节点，动作表示为节点之间的箭头。</p>
</li>
</ul>
<p><img src="https://cs50.harvard.edu/ai/notes/0/statespace.png" srcset="/img/loading.gif" lazyload alt="State Space"></p>
<ul>
<li><p><strong>目标测试 (Goal Test)</strong></p>
<p>确定给定状态是否为目标状态的条件。例如，在导航应用中，目标测试是检查智能体（汽车的代表）的当前位置是否在目的地。如果是——问题解决。如果不是——我们继续搜索。</p>
</li>
<li><p><strong>路径代价 (Path Cost)</strong></p>
<p>与给定路径相关的数值成本。例如，导航应用不仅带你到达目标；它会在最小化路径代价的同时这样做，即为你找到到达目标状态的最快方式。</p>
</li>
</ul>
<blockquote>
<p>**🔍 [译者注释]**：理解这些术语至关重要。</p>
<ul>
<li><strong>状态 (State)</strong> 是“我们在哪里”。</li>
<li><strong>动作 (Action)</strong> 是“我们能做什么”。</li>
<li><strong>转移模型 (Transition)</strong> 是“做了之后会发生什么”。</li>
<li><strong>状态空间 (State Space)</strong> 是“所有可能情况的地图”。搜索算法本质上就是在这个巨大的“地图”中寻找一条路线。</li>
</ul>
</blockquote>
<h2 id="解决搜索问题"><a href="#解决搜索问题" class="headerlink" title="解决搜索问题"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#solving-search-problems">解决搜索问题</a></h2><ul>
<li><p><strong>解 (Solution)</strong></p>
<p>从初始状态导致目标状态的一系列动作。</p>
<ul>
<li><strong>最优解 (Optimal Solution)</strong><br>在所有解中具有最低路径代价的解。</li>
</ul>
</li>
</ul>
<p>在搜索过程中，数据通常存储在 <strong><em>节点 (Node)</em></strong> 中，这是一种包含以下数据的数据结构：</p>
<ul>
<li>一个 <em>状态 (state)</em></li>
<li>它的 _父节点 (parent node)_，即生成当前节点的那个节点</li>
<li>从父节点的状态应用到当前节点的 <em>动作 (action)</em></li>
<li>从初始状态到此节点的 <em>路径代价 (path cost)</em></li>
</ul>
<p><em>节点</em> 包含的信息使它们对搜索算法非常有用。它们包含一个 _状态_，可以使用 <em>目标测试</em> 来检查它是否是最终状态。如果是，该节点的 <em>路径代价</em> 可以与其他节点的 <em>路径代价</em> 进行比较，从而允许选择 _最优解_。一旦选择了节点，由于存储了 <em>父节点</em> 和导致从 <em>父节点</em> 到当前节点的 _动作_，就可以从 <em>初始状态</em> 一步步回溯到该节点，这个动作序列就是 _解_。</p>
<p>然而，<em>节点</em> 只是数据结构——它们不进行搜索，它们只是持有信息。为了实际进行搜索，我们使用 **前沿 (frontier)**（或称边界），这是一种“管理” <em>节点</em> 的机制。<em>前沿</em> 开始时包含一个初始状态和一个空的已探索项集合，然后重复以下操作直到找到解：</p>
<p><strong>重复 (Repeat):</strong></p>
<ol>
<li><p>如果前沿 (frontier) 为空，</p>
<ul>
<li><em>停止。</em> 问题无解。</li>
</ul>
</li>
<li><p>从前沿中移除一个节点。这是将被考虑的节点。</p>
</li>
<li><p>如果该节点包含目标状态，</p>
<ul>
<li>返回解。_停止_。</li>
</ul>
<p>否则 (Else)，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">*</span> 扩展该节点（找到从该节点可以到达的所有新节点），并将结果节点添加到前沿中。<br><span class="hljs-operator">*</span> 将当前节点添加到已探索集合 (explored <span class="hljs-keyword">set</span>) 中。<br></code></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>**🔍 [译者注释]**：</p>
<ul>
<li><strong>节点 vs 状态</strong>：这是一个常见的混淆点。<strong>状态</strong>是物理世界的配置（例如“我在 A 城市”）。<strong>节点</strong>是算法记录的账本（例如“我在 A 城市，我是从 B 城市过来的，目前花了 100 块钱”）。同一个状态（A 城市）可能对应多个节点（你可以从 B 来，也可以从 C 来）。</li>
<li>**前沿 (Frontier)**：可以把它想象成一个“待办事项列表”。算法不断从这个列表中取出任务（节点）来处理，并把新发现的任务加进去。</li>
</ul>
</blockquote>
<h4 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索 (Depth-First Search)"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#depth-first-search">深度优先搜索 (Depth-First Search)</a></h4><p>在前面关于 <em>前沿</em> 的描述中，有一件事没有提到。在伪代码的第 2 步，应该移除哪个节点？这个选择对解的质量以及找到解的速度有影响。有多种方法来决定应该首先考虑哪些节点，其中两种可以用 **栈 (stack)**（用于 <em>深度优先</em> 搜索）和 **队列 (queue)**（用于 <em>广度优先</em> 搜索）的数据结构来表示（<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=2wM6_PuBIxY">这是一个可爱的卡通演示</a>，展示了两者的区别）。</p>
<p>我们从 <em>深度优先</em> 搜索 (<em>DFS</em>) 方法开始。</p>
<p><em>深度优先</em> 搜索算法在尝试另一个方向之前会耗尽每一个方向。在这种情况下，前沿作为 <em>栈</em> 数据结构进行管理。你需要记住的口号是“**后进先出 (Last-In First-Out)**”。在节点被添加到前沿后，第一个被移除并考虑的节点是最后被添加的那一个。这导致搜索算法会在第一个阻碍它的方向上尽可能深地搜索，而将所有其他方向留待稍后处理。</p>
<p>（课程外的例子：假设你在找钥匙。在 <em>深度优先</em> 搜索方法中，如果你选择从裤子开始找，你会先检查每一个口袋，清空每个口袋并仔细检查内容物。只有当你完全检查完裤子的每一个口袋后，你才会停止在裤子里搜索并开始在其他地方搜索。）</p>
<ul>
<li><strong>优点</strong>:<ul>
<li>在最好的情况下，这个算法是最快的。如果它“运气好”并且总是（偶然地）选择通往解的正确路径，那么 <em>深度优先</em> 搜索花费的时间最少。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>找到的解可能不是最优的。</li>
<li>在最坏的情况下，这个算法会在找到解之前探索每一条可能的路径，因此在到达解之前花费最长的时间。</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义从前沿移除节点并返回它的函数。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>      <span class="hljs-comment"># 如果前沿为空，则终止搜索，因为这意味着没有解。</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;empty frontier&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>          <span class="hljs-comment"># 保存列表中的最后一项（即最新添加的节点）</span><br>            node = <span class="hljs-variable language_">self</span>.frontier[-<span class="hljs-number">1</span>]<br>            <span class="hljs-comment"># 保存列表中除了最后一个节点之外的所有项（即移除最后一个节点）</span><br>            <span class="hljs-variable language_">self</span>.frontier = <span class="hljs-variable language_">self</span>.frontier[:-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure>

<h4 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索 (Breadth-First Search)"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#breadth-first-search">广度优先搜索 (Breadth-First Search)</a></h4><p><em>深度优先</em> 搜索的对立面是 <em>广度优先</em> 搜索 (<em>BFS</em>)。</p>
<p><em>广度优先</em> 搜索算法将同时沿着多个方向前进，在每个可能的方向上迈出一步，然后在每个方向上迈出第二步。在这种情况下，前沿作为 <em>队列</em> 数据结构进行管理。你需要记住的口号是“**先进先出 (First-In First-Out)**”。在这种情况下，所有新节点排队等候，根据添加的顺序来考虑节点（先到先得！）。这导致搜索算法在任何一个方向采取第二步之前，先在每个可能的方向上采取一步。</p>
<p>（课程外的例子：假设你在找钥匙。在这种情况下，如果你从裤子开始，你会看一眼右口袋。之后，你不会接着看左口袋，而是会看一眼抽屉。然后是桌子上。依此类推，在你通过所有想到的位置各看一眼之后。只有当你遍历了所有位置后，你才会回到裤子并搜索下一个口袋。）</p>
<ul>
<li><strong>优点</strong>:<ul>
<li>该算法<strong>保证</strong>找到最优解。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>该算法几乎肯定比最小运行时间要长。</li>
<li>在最坏的情况下，该算法需要最长的时间运行。</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义从前沿移除节点并返回它的函数。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>      <span class="hljs-comment"># 如果前沿为空，则终止搜索，因为这意味着没有解。</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.empty():<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;empty frontier&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 保存列表中的最老项（即第一个被添加的项）</span><br>            node = <span class="hljs-variable language_">self</span>.frontier[<span class="hljs-number">0</span>]<br>            <span class="hljs-comment"># 保存列表中除了第一项之外的所有项（即移除第一个节点）</span><br>            <span class="hljs-variable language_">self</span>.frontier = <span class="hljs-variable language_">self</span>.frontier[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure>

<blockquote>
<p>**🔍 [译者注释]**：</p>
<ul>
<li><strong>DFS (深度优先)</strong> 就像走迷宫时“一条路走到黑”，撞墙了再退回来。如果你运气好选对了路，很快就能到；运气不好，可能会绕很远。<strong>它不保证找到最近的路。</strong></li>
<li><strong>BFS (广度优先)</strong> 就像水波纹扩散，一圈一圈向外找。因为它是按距离（步数）一层层找的，所以它<strong>一定能找到步数最少的解</strong>（最优解），但通常比较耗费内存。</li>
</ul>
</blockquote>
<h4 id="贪婪最佳优先搜索-Greedy-Best-First-Search"><a href="#贪婪最佳优先搜索-Greedy-Best-First-Search" class="headerlink" title="贪婪最佳优先搜索 (Greedy Best-First Search)"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#greedy-best-first-search">贪婪最佳优先搜索 (Greedy Best-First Search)</a></h4><p>广度优先和深度优先都是 <strong>无信息 (uninformed)</strong> 搜索算法。也就是说，这些算法除了通过自身探索获得的信息外，不利用任何关于问题的知识。然而，通常情况下，关于问题的一些知识实际上是可用的。例如，当人类迷宫解决者进入一个路口时，人类可以看到哪条路通向解的大致方向，哪条路不是。AI 也可以做同样的事情。一种考虑额外知识以试图提高其性能的算法称为 <strong>有信息 (informed)</strong> 搜索算法。</p>
<p><strong>贪婪最佳优先</strong> 搜索扩展那个由 <strong>启发式函数 (heuristic function)</strong> <em>h(n)</em> 确定为最接近目标的节点。顾名思义，该函数估计下一个节点距离目标有多近，但它可能会出错。<em>贪婪最佳优先</em> 算法的效率取决于启发式函数的好坏。例如，在迷宫中，算法可以使用一个依赖于可能节点与迷宫终点之间的 <strong>曼哈顿距离 (Manhattan distance)</strong> 的启发式函数。<em>曼哈顿距离</em> 忽略墙壁，计算从一个位置到达目标位置需要向上、向下或向两侧走多少步。这是一个基于当前位置和目标位置的 (x, y) 坐标可以得出的简单估算。</p>
<p><img src="https://cs50.harvard.edu/ai/notes/0/manhattandistance.png" srcset="/img/loading.gif" lazyload alt="Manhattan Distance"></p>
<p>曼哈顿距离</p>
<p>然而，必须强调的是，与任何启发式方法一样，它可能会出错并导致算法走上一条比其他路径更慢的路径。有可能 <em>无信息</em> 搜索算法会更快地提供更好的解，但它这样做的可能性比 <em>有信息</em> 算法要小。</p>
<blockquote>
<p>**🔍 [译者注释]**：为什么叫“贪婪”？因为它只看眼前哪个节点离目标最近（由 $h(n)$ 决定），而不考虑它是怎么到达那个节点的（忽略了已经走过的成本）。这就像为了去某个地方，总是选择直线距离最近的路口，哪怕那条路其实很堵或者要绕远路。</p>
</blockquote>
<h4 id="A-搜索-A-Search"><a href="#A-搜索-A-Search" class="headerlink" title="A* 搜索 (A* Search)"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#a-search">A* 搜索 (A* Search)</a></h4><p>作为 <em>贪婪最佳优先</em> 算法的发展，<em>A* 搜索</em> 不仅考虑 _h(n)_（从当前位置到目标的估计成本），还考虑 _g(n)_（直到当前位置所累积的成本）。通过结合这两个值，算法有一种更准确的方法来确定解的成本并动态优化其选择。算法跟踪 (<em>至今路径成本</em> + <em>到目标的估计成本</em>)，一旦它超过某个先前选项的估计成本，算法就会放弃当前路径并回到先前的选项，从而防止自己沿着 <em>h(n)</em> 错误地标记为最佳的一条长且低效的路径走下去。</p>
<p>同样，由于该算法也依赖于启发式，它的好坏取决于它所采用的启发式。在某些情况下，它可能比 <em>贪婪最佳优先</em> 搜索甚至 <em>无信息</em> 算法效率低。为了使 <em>A* 搜索</em> 成为最优的，启发式函数 <em>h(n)</em> 必须是：</p>
<ol>
<li>_可采纳的 (Admissible)_，即通过不高估真实成本（即永远不大于实际成本）。</li>
<li>_一致的 (Consistent)_，这意味着新节点到目标的估计路径成本加上从前一个节点转移到它的成本，大于或等于前一个节点到目标的估计路径成本。用方程形式表示，如果对于每个节点 <em>n</em> 和步长成本为 <em>c</em> 的后继节点 _n’_，都有 _h(n) ≤ h(n’) + c_，则 <em>h(n)</em> 是一致的。</li>
</ol>
<blockquote>
<p>**🔍 [译者注释]*<em>：A</em> 是目前最流行的寻路算法。</p>
<ul>
<li>公式：$f(n) &#x3D; g(n) + h(n)$。<ul>
<li>$g(n)$：我已经走了多远（实际成本）。</li>
<li>$h(n)$：我估计还要走多远（启发式）。</li>
</ul>
</li>
<li>**可采纳性 (Admissible)*<em>：意味着你的估计必须是“乐观”的。如果你估计还需要走 10 步，但实际需要 5 步，那就不行；但如果你估计 10 步，实际需要 20 步，那是可以的。只要不高估，A</em> 就能保证找到最优解。</li>
</ul>
</blockquote>
<h3 id="对抗搜索-Adversarial-Search"><a href="#对抗搜索-Adversarial-Search" class="headerlink" title="对抗搜索 (Adversarial Search)"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#adversarial-search">对抗搜索 (Adversarial Search)</a></h3><p>此前，我们讨论的算法需要找到问题的答案，而在 <strong>对抗搜索</strong> 中，算法面临着试图实现相反目标的对手。通常，使用对抗搜索的 AI 会出现在游戏中，例如井字棋 (Tic-Tac-Toe)。</p>
<h4 id="极小化极大算法-Minimax"><a href="#极小化极大算法-Minimax" class="headerlink" title="极小化极大算法 (Minimax)"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#minimax">极小化极大算法 (Minimax)</a></h4><p>作为对抗搜索中的一种算法，<strong>Minimax</strong> 将胜利条件表示为一方 (-1) 和另一方 (+1)。进一步的行动将由这些条件驱动，最小化方试图获得最低分，最大化方试图获得最高分。</p>
<p><strong>表示井字棋 AI</strong>:</p>
<ul>
<li><em>S₀</em>: 初始状态（在我们的例子中，空的 3X3 棋盘）</li>
<li><em>Players(s)</em>: 给定状态 _s_，返回轮到哪个玩家（X 或 O）的函数。</li>
<li><em>Actions(s)</em>: 给定状态 _s_，返回该状态下所有合法移动（棋盘上哪些位置是空的）的函数。</li>
<li><em>Result(s, a)</em>: 给定状态 <em>s</em> 和动作 _a_，返回新状态的函数。这是在状态 <em>s</em> 上执行动作 _a_（在游戏中走一步）后产生的棋盘。</li>
<li><em>Terminal(s)</em>: 给定状态 _s_，检查这是否是游戏的最后一步（即是否有人赢了或平局）的函数。如果游戏结束返回 _True_，否则返回 _False_。</li>
<li><em>Utility(s)</em>: 给定终端状态 _s_，返回状态的效用值的函数：-1、0 或 1。</li>
</ul>
<p><strong>算法如何工作</strong>:</p>
<p>该算法递归地模拟从当前状态开始直到达到终端状态的所有可能发生的游戏。每个终端状态被赋值为 (-1)、0 或 (+1)。</p>
<p><img src="https://cs50.harvard.edu/ai/notes/0/minimax_tictactoe.png" srcset="/img/loading.gif" lazyload alt="Minimax in Tic Tac Toe"></p>
<p>井字棋中的 Minimax 算法</p>
<p>根据状态知道轮到谁，算法可以知道当前玩家在进行最佳操作时，会选择导致值更低还是更高的状态的动作。这样，在最小化和最大化之间交替，算法为每个可能动作导致的状态创建值。举个更具体的例子，我们可以想象最大化玩家在每一轮都会问：“如果我采取这个行动，将会产生一个新状态。如果最小化玩家玩得最好，那个玩家会采取什么行动来带来最低的值？”然而，要回答这个问题，最大化玩家必须问：“要知道最小化玩家会做什么，我需要在最小化玩家的脑海中模拟相同的过程：最小化玩家会试图问：‘如果我采取这个行动，最大化玩家可以采取什么行动来带来最高的值？’”这是一个递归过程，可能很难理解；看下面的伪代码会有所帮助。最终，通过这个递归推理过程，最大化玩家为当前状态下所有可能动作可能导致的状态生成值。拥有这些值后，最大化玩家选择最高的一个。</p>
<p><img src="https://cs50.harvard.edu/ai/notes/0/minimax_theoretical.png" srcset="/img/loading.gif" lazyload alt="Minimax Algorithm"></p>
<p>最大化者考虑未来状态的可能值。</p>
<p>用伪代码表示，Minimax 算法的工作方式如下：</p>
<ul>
<li>给定状态 <em>s</em><ul>
<li>最大化玩家在 <em>Actions(s)</em> 中选择动作 _a_，该动作产生 <em>Min-Value(Result(s, a))</em> 的最高值。</li>
<li>最小化玩家在 <em>Actions(s)</em> 中选择动作 _a_，该动作产生 <em>Max-Value(Result(s, a))</em> 的最低值。</li>
</ul>
</li>
<li>函数 <em>Max-Value(state)</em><ul>
<li><em>v &#x3D; -∞</em></li>
<li>如果 <em>Terminal(state)</em>:<br>返回 <em>Utility(state)</em></li>
<li>对于 <em>Actions(state)</em> 中的 <em>action</em>:<br><em>v &#x3D; Max(v, Min-Value(Result(state, action)))</em><br>返回 <em>v</em></li>
</ul>
</li>
<li>函数 <em>Min-Value(state)</em>:<ul>
<li><em>v &#x3D; ∞</em></li>
<li>如果 <em>Terminal(state)</em>:<br>返回 <em>Utility(state)</em></li>
<li>对于 <em>Actions(state)</em> 中的 <em>action</em>:<br><em>v &#x3D; Min(v, Max-Value(Result(state, action)))</em><br>返回 <em>v</em></li>
</ul>
</li>
</ul>
<blockquote>
<p>**🔍 [译者注释]**：Minimax 的核心逻辑是“换位思考”。</p>
<ul>
<li>**Max (我)**：我想赢（得分 +1）。</li>
<li>**Min (对手)**：想让我输（得分 -1）。</li>
<li>在做决定时，我会假设对手极其聪明。如果我走 A 步，对手可能会走 X、Y 或 Z。我会看 X、Y、Z 中哪个对我<strong>最不利</strong>（因为对手会选那个）。然后我在所有可能的 A、B、C 步中，选择那个“最坏情况中最好的”结果。</li>
</ul>
</blockquote>
<h4 id="Alpha-Beta-剪枝-Alpha-Beta-Pruning"><a href="#Alpha-Beta-剪枝-Alpha-Beta-Pruning" class="headerlink" title="Alpha-Beta 剪枝 (Alpha-Beta Pruning)"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#alpha-beta-pruning">Alpha-Beta 剪枝 (Alpha-Beta Pruning)</a></h4><p>作为优化 <em>Minimax</em> 的一种方法，<strong>Alpha-Beta 剪枝</strong> 跳过一些明显不利的递归计算。在确定了一个动作的值之后，如果有初步证据表明随后的动作可能让对手获得比已经确定的动作更好的分数，那么就没有必要进一步调查这个动作了，因为它肯定比先前确定的那个更不有利。</p>
<p>这用一个例子最容易展示：一个最大化玩家知道，在下一步，最小化玩家将试图获得最低分。假设最大化玩家有三个可能的动作，第一个动作的值为 4。然后玩家开始生成下一个动作的值。为此，玩家生成如果当前玩家采取此动作后最小化玩家动作的值，知道最小化者会选择最低的那个。然而，在完成最小化玩家所有可能动作的计算之前，玩家看到其中一个选项的值为 3。这意味着没有理由继续探索最小化玩家的其他可能动作了。尚未估值的动作的值是多少并不重要，无论是 10 还是 (-10)。如果值为 10，最小化者会选择最低的选项 3，这已经比预先确定的 4 差了。如果尚未估值的动作结果是 (-10)，最小化者将选择这个选项 (-10)，这对最大化者来说更加不利。因此，此时计算最小化者的其他可能动作对最大化者来说是无关紧要的，因为最大化玩家已经有了一个明确更好的选择，其值为 4。</p>
<p><img src="https://cs50.harvard.edu/ai/notes/0/alphabeta.png" srcset="/img/loading.gif" lazyload alt="Alpha Beta Pruning"></p>
<blockquote>
<p>**🔍 [译者注释]**：想象你在挑苹果，你想挑个最大的。</p>
<ul>
<li>第一筐里最小的苹果是 5 两重（所以这筐至少能给你 5 两）。</li>
<li>你开始看第二筐，拿起来第一个苹果是 3 两。</li>
<li><strong>剪枝</strong>：你不需要再看第二筐剩下的苹果了。因为你是最大化者（想要最大的），而这一步是对手（最小化者）在选。对手既然能在第二筐找到 3 两的，那他绝对不会让你在这一筐得到超过 3 两的结果。既然 3 两已经比第一筐的 5 两差了，第二筐就被你放弃了。</li>
</ul>
</blockquote>
<h4 id="深度受限-Minimax-Depth-Limited-Minimax"><a href="#深度受限-Minimax-Depth-Limited-Minimax" class="headerlink" title="深度受限 Minimax (Depth-Limited Minimax)"></a><a target="_blank" rel="noopener" href="https://cs50.harvard.edu/ai/notes/0/#depth-limited-minimax">深度受限 Minimax (Depth-Limited Minimax)</a></h4><p>井字棋共有 255,168 种可能的游戏过程，而国际象棋有 10²⁹⁰⁰⁰ 种可能的游戏。目前所介绍的 Minimax 算法需要生成从某一点到终端条件的所有假设游戏。虽然现代计算机计算所有井字棋游戏并不构成挑战，但对国际象棋这样做目前是不可能的。</p>
<p><strong>深度受限 Minimax</strong> 仅考虑预定义数量的步数后就停止，而不必到达终端状态。然而，这不允许为每个动作获得精确的值，因为尚未到达假设游戏的结尾。为了解决这个问题，<em>深度受限 Minimax</em> 依赖于一个 **评估函数 (evaluation function)**，该函数估计从给定状态开始的游戏的预期效用，换句话说，为状态赋值。例如，在国际象棋游戏中，效用函数将接收棋盘的当前配置作为输入，尝试评估其预期效用（基于每个玩家拥有的棋子及其在棋盘上的位置），然后返回一个正值或负值，表示该棋盘对一个玩家相对于另一个玩家的有利程度。这些值可用于决定正确的动作，评估函数越好，依赖它的 Minimax 算法就越好。</p>
<blockquote>
<p>**🔍 [译者注释]**：</p>
<ul>
<li>这就是现实中下棋软件（如早期的“深蓝”）的工作原理。它算不了无限远，只能算往后 10 步或 20 步。</li>
<li><strong>评估函数</strong> 是关键：当我看不到结局时，我必须凭经验判断现在的局势是好是坏。例如：“我有皇后，对方没有，所以我这局势+9分”。</li>
</ul>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AF%BE%E7%A8%8B%E8%AE%B2%E4%B9%89/" class="category-chain-item">课程讲义</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/CS50-AI/" class="print-no-link">#CS50 AI</a>
      
        <a href="/tags/%E8%AE%B2%E4%B9%89/" class="print-no-link">#讲义</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CS50AI note1</div>
      <div>https://zjjyyds.github.io/2025/12/26/CS50 AI note1/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jay</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年12月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" title="归并排序算法">
                        <span class="hidden-mobile">归并排序算法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
